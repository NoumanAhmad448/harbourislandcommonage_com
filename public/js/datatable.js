/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/js/lib/dataTables.tailwindcss.js":
/*!****************************************************!*\
  !*** ./resources/js/lib/dataTables.tailwindcss.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/*! DataTables Tailwind CSS integration
 */

(function (factory) {
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! datatables.net */ "./node_modules/datatables.net/js/dataTables.mjs")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($) {
      return factory($, window, document);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var cjsRequires, jq; }
})(function ($, window, document) {
  'use strict';

  var DataTable = $.fn.dataTable;

  /*
   * This is a tech preview of Tailwind CSS integration with DataTables.
   */

  // Set the defaults for DataTables initialisation
  $.extend(true, DataTable.defaults, {
    renderer: 'tailwindcss'
  });

  // Default class modification
  $.extend(true, DataTable.ext.classes, {
    container: "dt-container dt-tailwindcss",
    search: {
      input: "border placeholder-gray-500 ml-2 px-3 py-2 rounded-lg border-gray-200 focus:border-blue-500 focus:ring focus:ring-blue-500 focus:ring-opacity-50 dark:bg-gray-800 dark:border-gray-600 dark:focus:border-blue-500 dark:placeholder-gray-400"
    },
    length: {
      select: "border px-3 py-2 rounded-lg border-gray-200 focus:border-blue-500 focus:ring focus:ring-blue-500 focus:ring-opacity-50 dark:bg-gray-800 dark:border-gray-600 dark:focus:border-blue-500"
    },
    processing: {
      container: "dt-processing"
    },
    paging: {
      active: 'font-semibold bg-gray-100 dark:bg-gray-700/75',
      notActive: 'bg-white dark:bg-gray-800',
      button: 'relative inline-flex justify-center items-center space-x-2 border px-4 py-2 -mr-px leading-6 hover:z-10 focus:z-10 active:z-10 border-gray-200 active:border-gray-200 active:shadow-none dark:border-gray-700 dark:active:border-gray-700',
      first: 'rounded-l-lg',
      last: 'rounded-r-lg',
      enabled: 'text-gray-800 hover:text-gray-900 hover:border-gray-300 hover:shadow-sm focus:ring focus:ring-gray-300 focus:ring-opacity-25 dark:text-gray-300 dark:hover:border-gray-600 dark:hover:text-gray-200 dark:focus:ring-gray-600 dark:focus:ring-opacity-40',
      notEnabled: 'text-gray-300 dark:text-gray-600'
    },
    table: 'dataTable min-w-full text-sm align-middle whitespace-nowrap',
    thead: {
      row: 'border-b border-gray-100 dark:border-gray-700/50',
      cell: 'px-3 py-4 text-gray-900 bg-gray-100/75 font-semibold text-left dark:text-gray-50 dark:bg-gray-700/25'
    },
    tbody: {
      row: 'even:bg-gray-50 dark:even:bg-gray-900/50',
      cell: 'p-3'
    },
    tfoot: {
      row: 'even:bg-gray-50 dark:even:bg-gray-900/50',
      cell: 'p-3 text-left'
    }
  });
  DataTable.ext.renderer.pagingButton.tailwindcss = function (settings, buttonType, content, active, disabled) {
    var classes = settings.oClasses.paging;
    var btnClasses = [classes.button];
    btnClasses.push(active ? classes.active : classes.notActive);
    btnClasses.push(disabled ? classes.notEnabled : classes.enabled);
    var a = $('<a>', {
      'href': disabled ? null : '#',
      'class': btnClasses.join(' ')
    }).html(content);
    return {
      display: a,
      clicker: a
    };
  };
  DataTable.ext.renderer.pagingContainer.tailwindcss = function (settings, buttonEls) {
    var classes = settings.oClasses.paging;
    buttonEls[0].addClass(classes.first);
    buttonEls[buttonEls.length - 1].addClass(classes.last);
    return $('<ul/>').addClass('pagination').append(buttonEls);
  };
  DataTable.ext.renderer.layout.tailwindcss = function (settings, container, items) {
    var row = $('<div/>', {
      "class": items.full ? 'grid grid-cols-1 gap-4 mb-4' : 'grid grid-cols-2 gap-4 mb-4'
    }).appendTo(container);
    $.each(items, function (key, val) {
      var klass;

      // Apply start / end (left / right when ltr) margins
      if (val.table) {
        klass = 'col-span-2';
      } else if (key === 'start') {
        klass = 'justify-self-start';
      } else if (key === 'end') {
        klass = 'col-start-2 justify-self-end';
      } else {
        klass = 'col-span-2 justify-self-center';
      }
      $('<div/>', {
        id: val.id || null,
        "class": klass + ' ' + (val.className || '')
      }).append(val.contents).appendTo(row);
    });
  };
  return DataTable;
});

/***/ }),

/***/ "./resources/js/lib/tailwindcss.js":
/*!*****************************************!*\
  !*** ./resources/js/lib/tailwindcss.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var _excluded = ["extend"],
  _excluded2 = ["inputs"],
  _excluded3 = ["inputId"],
  _excluded4 = ["filterDefault"],
  _excluded5 = ["DEFAULT"],
  _excluded6 = ["DEFAULT"],
  _excluded7 = ["DEFAULT"],
  _excluded8 = ["DEFAULT"],
  _excluded9 = ["type"];
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } } return target; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e28) { throw _e28; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e29) { didErr = true; err = _e29; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
(function () {
  var _marked = /*#__PURE__*/_regeneratorRuntime().mark(fs),
    _marked2 = /*#__PURE__*/_regeneratorRuntime().mark(Xb),
    _marked3 = /*#__PURE__*/_regeneratorRuntime().mark(sC),
    _marked4 = /*#__PURE__*/_regeneratorRuntime().mark(dC),
    _marked5 = /*#__PURE__*/_regeneratorRuntime().mark(mC),
    _marked6 = /*#__PURE__*/_regeneratorRuntime().mark(io),
    _marked7 = /*#__PURE__*/_regeneratorRuntime().mark(WC),
    _marked8 = /*#__PURE__*/_regeneratorRuntime().mark(Eh),
    _marked9 = /*#__PURE__*/_regeneratorRuntime().mark(w2);
  var wb = Object.create;
  var li = Object.defineProperty;
  var bb = Object.getOwnPropertyDescriptor;
  var vb = Object.getOwnPropertyNames;
  var xb = Object.getPrototypeOf,
    kb = Object.prototype.hasOwnProperty;
  var au = function au(i) {
    return li(i, "__esModule", {
      value: !0
    });
  };
  var ou = function ou(i) {
    if (true) return __webpack_require__("./resources/js/lib sync recursive")(i);
    throw new Error('Dynamic require of "' + i + '" is not supported');
  };
  var C = function C(i, e) {
    return function () {
      return i && (e = i(i = 0)), e;
    };
  };
  var v = function v(i, e) {
      return function () {
        return e || i((e = {
          exports: {}
        }).exports, e), e.exports;
      };
    },
    Ae = function Ae(i, e) {
      au(i);
      for (var t in e) li(i, t, {
        get: e[t],
        enumerable: !0
      });
    },
    Sb = function Sb(i, e, t) {
      if (e && _typeof(e) == "object" || typeof e == "function") {
        var _iterator = _createForOfIteratorHelper(vb(e)),
          _step;
        try {
          var _loop = function _loop() {
            var r = _step.value;
            !kb.call(i, r) && r !== "default" && li(i, r, {
              get: function get() {
                return e[r];
              },
              enumerable: !(t = bb(e, r)) || t.enumerable
            });
          };
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            _loop();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      return i;
    },
    X = function X(i) {
      return Sb(au(li(i != null ? wb(xb(i)) : {}, "default", i && i.__esModule && "default" in i ? {
        get: function get() {
          return i["default"];
        },
        enumerable: !0
      } : {
        value: i,
        enumerable: !0
      })), i);
    };
  var h,
    l = C(function () {
      h = {
        platform: "",
        env: {},
        versions: {
          node: "14.17.6"
        }
      };
    });
  var Cb,
    te,
    je = C(function () {
      l();
      Cb = 0, te = {
        readFileSync: function readFileSync(i) {
          return self[i] || "";
        },
        statSync: function statSync() {
          return {
            mtimeMs: Cb++
          };
        },
        promises: {
          readFile: function readFile(i) {
            return Promise.resolve(self[i] || "");
          }
        }
      };
    });
  var Qn = v(function (PO, uu) {
    l();
    "use strict";
    var lu = /*#__PURE__*/function () {
      function lu() {
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        _classCallCheck(this, lu);
        if (!(e.maxSize && e.maxSize > 0)) throw new TypeError("`maxSize` must be a number greater than 0");
        if (typeof e.maxAge == "number" && e.maxAge === 0) throw new TypeError("`maxAge` must be a number greater than 0");
        this.maxSize = e.maxSize, this.maxAge = e.maxAge || 1 / 0, this.onEviction = e.onEviction, this.cache = new Map(), this.oldCache = new Map(), this._size = 0;
      }
      return _createClass(lu, [{
        key: "_emitEvictions",
        value: function _emitEvictions(e) {
          if (typeof this.onEviction == "function") {
            var _iterator2 = _createForOfIteratorHelper(e),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var _step2$value = _slicedToArray(_step2.value, 2),
                  t = _step2$value[0],
                  r = _step2$value[1];
                this.onEviction(t, r.value);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
        }
      }, {
        key: "_deleteIfExpired",
        value: function _deleteIfExpired(e, t) {
          return typeof t.expiry == "number" && t.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(e, t.value), this["delete"](e)) : !1;
        }
      }, {
        key: "_getOrDeleteIfExpired",
        value: function _getOrDeleteIfExpired(e, t) {
          if (this._deleteIfExpired(e, t) === !1) return t.value;
        }
      }, {
        key: "_getItemValue",
        value: function _getItemValue(e, t) {
          return t.expiry ? this._getOrDeleteIfExpired(e, t) : t.value;
        }
      }, {
        key: "_peek",
        value: function _peek(e, t) {
          var r = t.get(e);
          return this._getItemValue(e, r);
        }
      }, {
        key: "_set",
        value: function _set(e, t) {
          this.cache.set(e, t), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = new Map());
        }
      }, {
        key: "_moveToRecent",
        value: function _moveToRecent(e, t) {
          this.oldCache["delete"](e), this._set(e, t);
        }
      }, {
        key: "_entriesAscending",
        value: /*#__PURE__*/_regeneratorRuntime().mark(function _entriesAscending() {
          var _iterator3, _step3, e, _e2, t, r, _iterator4, _step4, _e3, _e4, _t2, _r2;
          return _regeneratorRuntime().wrap(function _entriesAscending$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _iterator3 = _createForOfIteratorHelper(this.oldCache);
                _context.prev = 1;
                _iterator3.s();
              case 3:
                if ((_step3 = _iterator3.n()).done) {
                  _context.next = 14;
                  break;
                }
                e = _step3.value;
                _e2 = _slicedToArray(e, 2), t = _e2[0], r = _e2[1];
                _context.t0 = this.cache.has(t);
                if (_context.t0) {
                  _context.next = 12;
                  break;
                }
                _context.t1 = this._deleteIfExpired(t, r) === !1;
                if (!_context.t1) {
                  _context.next = 12;
                  break;
                }
                _context.next = 12;
                return e;
              case 12:
                _context.next = 3;
                break;
              case 14:
                _context.next = 19;
                break;
              case 16:
                _context.prev = 16;
                _context.t2 = _context["catch"](1);
                _iterator3.e(_context.t2);
              case 19:
                _context.prev = 19;
                _iterator3.f();
                return _context.finish(19);
              case 22:
                _iterator4 = _createForOfIteratorHelper(this.cache);
                _context.prev = 23;
                _iterator4.s();
              case 25:
                if ((_step4 = _iterator4.n()).done) {
                  _context.next = 34;
                  break;
                }
                _e3 = _step4.value;
                _e4 = _slicedToArray(_e3, 2), _t2 = _e4[0], _r2 = _e4[1];
                _context.t3 = this._deleteIfExpired(_t2, _r2) === !1;
                if (!_context.t3) {
                  _context.next = 32;
                  break;
                }
                _context.next = 32;
                return _e3;
              case 32:
                _context.next = 25;
                break;
              case 34:
                _context.next = 39;
                break;
              case 36:
                _context.prev = 36;
                _context.t4 = _context["catch"](23);
                _iterator4.e(_context.t4);
              case 39:
                _context.prev = 39;
                _iterator4.f();
                return _context.finish(39);
              case 42:
              case "end":
                return _context.stop();
            }
          }, _entriesAscending, this, [[1, 16, 19, 22], [23, 36, 39, 42]]);
        })
      }, {
        key: "get",
        value: function get(e) {
          if (this.cache.has(e)) {
            var t = this.cache.get(e);
            return this._getItemValue(e, t);
          }
          if (this.oldCache.has(e)) {
            var _t3 = this.oldCache.get(e);
            if (this._deleteIfExpired(e, _t3) === !1) return this._moveToRecent(e, _t3), _t3.value;
          }
        }
      }, {
        key: "set",
        value: function set(e, t) {
          var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
            _ref$maxAge = _ref.maxAge,
            r = _ref$maxAge === void 0 ? this.maxAge === 1 / 0 ? void 0 : Date.now() + this.maxAge : _ref$maxAge;
          this.cache.has(e) ? this.cache.set(e, {
            value: t,
            maxAge: r
          }) : this._set(e, {
            value: t,
            expiry: r
          });
        }
      }, {
        key: "has",
        value: function has(e) {
          return this.cache.has(e) ? !this._deleteIfExpired(e, this.cache.get(e)) : this.oldCache.has(e) ? !this._deleteIfExpired(e, this.oldCache.get(e)) : !1;
        }
      }, {
        key: "peek",
        value: function peek(e) {
          if (this.cache.has(e)) return this._peek(e, this.cache);
          if (this.oldCache.has(e)) return this._peek(e, this.oldCache);
        }
      }, {
        key: "delete",
        value: function _delete(e) {
          var t = this.cache["delete"](e);
          return t && this._size--, this.oldCache["delete"](e) || t;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.cache.clear(), this.oldCache.clear(), this._size = 0;
        }
      }, {
        key: "resize",
        value: function resize(e) {
          if (!(e && e > 0)) throw new TypeError("`maxSize` must be a number greater than 0");
          var t = _toConsumableArray(this._entriesAscending()),
            r = t.length - e;
          r < 0 ? (this.cache = new Map(t), this.oldCache = new Map(), this._size = t.length) : (r > 0 && this._emitEvictions(t.slice(0, r)), this.oldCache = new Map(t.slice(r)), this.cache = new Map(), this._size = 0), this.maxSize = e;
        }
      }, {
        key: "keys",
        value: /*#__PURE__*/_regeneratorRuntime().mark(function keys() {
          var _iterator5, _step5, _step5$value, e;
          return _regeneratorRuntime().wrap(function keys$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _iterator5 = _createForOfIteratorHelper(this);
                _context2.prev = 1;
                _iterator5.s();
              case 3:
                if ((_step5 = _iterator5.n()).done) {
                  _context2.next = 9;
                  break;
                }
                _step5$value = _slicedToArray(_step5.value, 1), e = _step5$value[0];
                _context2.next = 7;
                return e;
              case 7:
                _context2.next = 3;
                break;
              case 9:
                _context2.next = 14;
                break;
              case 11:
                _context2.prev = 11;
                _context2.t0 = _context2["catch"](1);
                _iterator5.e(_context2.t0);
              case 14:
                _context2.prev = 14;
                _iterator5.f();
                return _context2.finish(14);
              case 17:
              case "end":
                return _context2.stop();
            }
          }, keys, this, [[1, 11, 14, 17]]);
        })
      }, {
        key: "values",
        value: /*#__PURE__*/_regeneratorRuntime().mark(function values() {
          var _iterator6, _step6, _step6$value, e;
          return _regeneratorRuntime().wrap(function values$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                _iterator6 = _createForOfIteratorHelper(this);
                _context3.prev = 1;
                _iterator6.s();
              case 3:
                if ((_step6 = _iterator6.n()).done) {
                  _context3.next = 9;
                  break;
                }
                _step6$value = _slicedToArray(_step6.value, 2), e = _step6$value[1];
                _context3.next = 7;
                return e;
              case 7:
                _context3.next = 3;
                break;
              case 9:
                _context3.next = 14;
                break;
              case 11:
                _context3.prev = 11;
                _context3.t0 = _context3["catch"](1);
                _iterator6.e(_context3.t0);
              case 14:
                _context3.prev = 14;
                _iterator6.f();
                return _context3.finish(14);
              case 17:
              case "end":
                return _context3.stop();
            }
          }, values, this, [[1, 11, 14, 17]]);
        })
      }, {
        key: Symbol.iterator,
        value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
          var _iterator7, _step7, e, _e5, t, r, _iterator8, _step8, _e6, _e7, _t4, _r3;
          return _regeneratorRuntime().wrap(function value$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                _iterator7 = _createForOfIteratorHelper(this.cache);
                _context4.prev = 1;
                _iterator7.s();
              case 3:
                if ((_step7 = _iterator7.n()).done) {
                  _context4.next = 12;
                  break;
                }
                e = _step7.value;
                _e5 = _slicedToArray(e, 2), t = _e5[0], r = _e5[1];
                _context4.t0 = this._deleteIfExpired(t, r) === !1;
                if (!_context4.t0) {
                  _context4.next = 10;
                  break;
                }
                _context4.next = 10;
                return [t, r.value];
              case 10:
                _context4.next = 3;
                break;
              case 12:
                _context4.next = 17;
                break;
              case 14:
                _context4.prev = 14;
                _context4.t1 = _context4["catch"](1);
                _iterator7.e(_context4.t1);
              case 17:
                _context4.prev = 17;
                _iterator7.f();
                return _context4.finish(17);
              case 20:
                _iterator8 = _createForOfIteratorHelper(this.oldCache);
                _context4.prev = 21;
                _iterator8.s();
              case 23:
                if ((_step8 = _iterator8.n()).done) {
                  _context4.next = 34;
                  break;
                }
                _e6 = _step8.value;
                _e7 = _slicedToArray(_e6, 2), _t4 = _e7[0], _r3 = _e7[1];
                _context4.t2 = this.cache.has(_t4);
                if (_context4.t2) {
                  _context4.next = 32;
                  break;
                }
                _context4.t3 = this._deleteIfExpired(_t4, _r3) === !1;
                if (!_context4.t3) {
                  _context4.next = 32;
                  break;
                }
                _context4.next = 32;
                return [_t4, _r3.value];
              case 32:
                _context4.next = 23;
                break;
              case 34:
                _context4.next = 39;
                break;
              case 36:
                _context4.prev = 36;
                _context4.t4 = _context4["catch"](21);
                _iterator8.e(_context4.t4);
              case 39:
                _context4.prev = 39;
                _iterator8.f();
                return _context4.finish(39);
              case 42:
              case "end":
                return _context4.stop();
            }
          }, value, this, [[1, 14, 17, 20], [21, 36, 39, 42]]);
        })
      }, {
        key: "entriesDescending",
        value: /*#__PURE__*/_regeneratorRuntime().mark(function entriesDescending() {
          var e, t, r, _r4, n, a, _t5, _r6, _r5, _n2, _a2;
          return _regeneratorRuntime().wrap(function entriesDescending$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                e = _toConsumableArray(this.cache);
                t = e.length - 1;
              case 2:
                if (!(t >= 0)) {
                  _context5.next = 11;
                  break;
                }
                r = e[t], _r4 = _slicedToArray(r, 2), n = _r4[0], a = _r4[1];
                _context5.t0 = this._deleteIfExpired(n, a) === !1;
                if (!_context5.t0) {
                  _context5.next = 8;
                  break;
                }
                _context5.next = 8;
                return [n, a.value];
              case 8:
                --t;
                _context5.next = 2;
                break;
              case 11:
                e = _toConsumableArray(this.oldCache);
                _t5 = e.length - 1;
              case 13:
                if (!(_t5 >= 0)) {
                  _context5.next = 24;
                  break;
                }
                _r6 = e[_t5], _r5 = _slicedToArray(_r6, 2), _n2 = _r5[0], _a2 = _r5[1];
                _context5.t1 = this.cache.has(_n2);
                if (_context5.t1) {
                  _context5.next = 21;
                  break;
                }
                _context5.t2 = this._deleteIfExpired(_n2, _a2) === !1;
                if (!_context5.t2) {
                  _context5.next = 21;
                  break;
                }
                _context5.next = 21;
                return [_n2, _a2.value];
              case 21:
                --_t5;
                _context5.next = 13;
                break;
              case 24:
              case "end":
                return _context5.stop();
            }
          }, entriesDescending, this);
        })
      }, {
        key: "entriesAscending",
        value: /*#__PURE__*/_regeneratorRuntime().mark(function entriesAscending() {
          var _iterator9, _step9, _step9$value, e, t;
          return _regeneratorRuntime().wrap(function entriesAscending$(_context6) {
            while (1) switch (_context6.prev = _context6.next) {
              case 0:
                _iterator9 = _createForOfIteratorHelper(this._entriesAscending());
                _context6.prev = 1;
                _iterator9.s();
              case 3:
                if ((_step9 = _iterator9.n()).done) {
                  _context6.next = 9;
                  break;
                }
                _step9$value = _slicedToArray(_step9.value, 2), e = _step9$value[0], t = _step9$value[1];
                _context6.next = 7;
                return [e, t.value];
              case 7:
                _context6.next = 3;
                break;
              case 9:
                _context6.next = 14;
                break;
              case 11:
                _context6.prev = 11;
                _context6.t0 = _context6["catch"](1);
                _iterator9.e(_context6.t0);
              case 14:
                _context6.prev = 14;
                _iterator9.f();
                return _context6.finish(14);
              case 17:
              case "end":
                return _context6.stop();
            }
          }, entriesAscending, this, [[1, 11, 14, 17]]);
        })
      }, {
        key: "size",
        get: function get() {
          if (!this._size) return this.oldCache.size;
          var e = 0;
          var _iterator10 = _createForOfIteratorHelper(this.oldCache.keys()),
            _step10;
          try {
            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
              var t = _step10.value;
              this.cache.has(t) || e++;
            }
          } catch (err) {
            _iterator10.e(err);
          } finally {
            _iterator10.f();
          }
          return Math.min(this._size + e, this.maxSize);
        }
      }]);
    }();
    uu.exports = lu;
  });
  var fu,
    cu = C(function () {
      l();
      fu = function fu(i) {
        return i && i._hash;
      };
    });
  function ui(i) {
    return fu(i, {
      ignoreUnknown: !0
    });
  }
  var pu = C(function () {
    l();
    cu();
  });
  function Xe(i) {
    if (i = "".concat(i), i === "0") return "0";
    if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(i)) return i.replace(/^[+-]?/, function (t) {
      return t === "-" ? "" : "-";
    });
    var e = ["var", "calc", "min", "max", "clamp"];
    for (var _i2 = 0, _e8 = e; _i2 < _e8.length; _i2++) {
      var t = _e8[_i2];
      if (i.includes("".concat(t, "("))) return "calc(".concat(i, " * -1)");
    }
  }
  var fi = C(function () {
    l();
  });
  var du,
    hu = C(function () {
      l();
      du = ["preflight", "container", "accessibility", "pointerEvents", "visibility", "position", "inset", "isolation", "zIndex", "order", "gridColumn", "gridColumnStart", "gridColumnEnd", "gridRow", "gridRowStart", "gridRowEnd", "float", "clear", "margin", "boxSizing", "lineClamp", "display", "aspectRatio", "size", "height", "maxHeight", "minHeight", "width", "minWidth", "maxWidth", "flex", "flexShrink", "flexGrow", "flexBasis", "tableLayout", "captionSide", "borderCollapse", "borderSpacing", "transformOrigin", "translate", "rotate", "skew", "scale", "transform", "animation", "cursor", "touchAction", "userSelect", "resize", "scrollSnapType", "scrollSnapAlign", "scrollSnapStop", "scrollMargin", "scrollPadding", "listStylePosition", "listStyleType", "listStyleImage", "appearance", "columns", "breakBefore", "breakInside", "breakAfter", "gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateColumns", "gridTemplateRows", "flexDirection", "flexWrap", "placeContent", "placeItems", "alignContent", "alignItems", "justifyContent", "justifyItems", "gap", "space", "divideWidth", "divideStyle", "divideColor", "divideOpacity", "placeSelf", "alignSelf", "justifySelf", "overflow", "overscrollBehavior", "scrollBehavior", "textOverflow", "hyphens", "whitespace", "textWrap", "wordBreak", "borderRadius", "borderWidth", "borderStyle", "borderColor", "borderOpacity", "backgroundColor", "backgroundOpacity", "backgroundImage", "gradientColorStops", "boxDecorationBreak", "backgroundSize", "backgroundAttachment", "backgroundClip", "backgroundPosition", "backgroundRepeat", "backgroundOrigin", "fill", "stroke", "strokeWidth", "objectFit", "objectPosition", "padding", "textAlign", "textIndent", "verticalAlign", "fontFamily", "fontSize", "fontWeight", "textTransform", "fontStyle", "fontVariantNumeric", "lineHeight", "letterSpacing", "textColor", "textOpacity", "textDecoration", "textDecorationColor", "textDecorationStyle", "textDecorationThickness", "textUnderlineOffset", "fontSmoothing", "placeholderColor", "placeholderOpacity", "caretColor", "accentColor", "opacity", "backgroundBlendMode", "mixBlendMode", "boxShadow", "boxShadowColor", "outlineStyle", "outlineWidth", "outlineOffset", "outlineColor", "ringWidth", "ringColor", "ringOpacity", "ringOffsetWidth", "ringOffsetColor", "blur", "brightness", "contrast", "dropShadow", "grayscale", "hueRotate", "invert", "saturate", "sepia", "filter", "backdropBlur", "backdropBrightness", "backdropContrast", "backdropGrayscale", "backdropHueRotate", "backdropInvert", "backdropOpacity", "backdropSaturate", "backdropSepia", "backdropFilter", "transitionProperty", "transitionDelay", "transitionDuration", "transitionTimingFunction", "willChange", "contain", "content", "forcedColorAdjust"];
    });
  function mu(i, e) {
    return i === void 0 ? e : Array.isArray(i) ? i : _toConsumableArray(new Set(e.filter(function (r) {
      return i !== !1 && i[r] !== !1;
    }).concat(Object.keys(i).filter(function (r) {
      return i[r] !== !1;
    }))));
  }
  var gu = C(function () {
    l();
  });
  var yu = {};
  Ae(yu, {
    "default": function _default() {
      return _e;
    }
  });
  var _e,
    ci = C(function () {
      l();
      _e = new Proxy({}, {
        get: function get() {
          return String;
        }
      });
    });
  function Jn(i, e, t) {
    typeof h != "undefined" && h.env.JEST_WORKER_ID || t && wu.has(t) || (t && wu.add(t), console.warn(""), e.forEach(function (r) {
      return console.warn(i, "-", r);
    }));
  }
  function Xn(i) {
    return _e.dim(i);
  }
  var wu,
    F,
    Oe = C(function () {
      l();
      ci();
      wu = new Set();
      F = {
        info: function info(i, e) {
          Jn.apply(void 0, [_e.bold(_e.cyan("info"))].concat(_toConsumableArray(Array.isArray(i) ? [i] : [e, i])));
        },
        warn: function warn(i, e) {
          ["content-problems"].includes(i) || Jn.apply(void 0, [_e.bold(_e.yellow("warn"))].concat(_toConsumableArray(Array.isArray(i) ? [i] : [e, i])));
        },
        risk: function risk(i, e) {
          Jn.apply(void 0, [_e.bold(_e.magenta("risk"))].concat(_toConsumableArray(Array.isArray(i) ? [i] : [e, i])));
        }
      };
    });
  var bu = {};
  Ae(bu, {
    "default": function _default() {
      return Kn;
    }
  });
  function ar(_ref2) {
    var i = _ref2.version,
      e = _ref2.from,
      t = _ref2.to;
    F.warn("".concat(e, "-color-renamed"), ["As of Tailwind CSS ".concat(i, ", `").concat(e, "` has been renamed to `").concat(t, "`."), "Update your configuration file to silence this warning."]);
  }
  var Kn,
    Zn = C(function () {
      l();
      Oe();
      Kn = {
        inherit: "inherit",
        current: "currentColor",
        transparent: "transparent",
        black: "#000",
        white: "#fff",
        slate: {
          50: "#f8fafc",
          100: "#f1f5f9",
          200: "#e2e8f0",
          300: "#cbd5e1",
          400: "#94a3b8",
          500: "#64748b",
          600: "#475569",
          700: "#334155",
          800: "#1e293b",
          900: "#0f172a",
          950: "#020617"
        },
        gray: {
          50: "#f9fafb",
          100: "#f3f4f6",
          200: "#e5e7eb",
          300: "#d1d5db",
          400: "#9ca3af",
          500: "#6b7280",
          600: "#4b5563",
          700: "#374151",
          800: "#1f2937",
          900: "#111827",
          950: "#030712"
        },
        zinc: {
          50: "#fafafa",
          100: "#f4f4f5",
          200: "#e4e4e7",
          300: "#d4d4d8",
          400: "#a1a1aa",
          500: "#71717a",
          600: "#52525b",
          700: "#3f3f46",
          800: "#27272a",
          900: "#18181b",
          950: "#09090b"
        },
        neutral: {
          50: "#fafafa",
          100: "#f5f5f5",
          200: "#e5e5e5",
          300: "#d4d4d4",
          400: "#a3a3a3",
          500: "#737373",
          600: "#525252",
          700: "#404040",
          800: "#262626",
          900: "#171717",
          950: "#0a0a0a"
        },
        stone: {
          50: "#fafaf9",
          100: "#f5f5f4",
          200: "#e7e5e4",
          300: "#d6d3d1",
          400: "#a8a29e",
          500: "#78716c",
          600: "#57534e",
          700: "#44403c",
          800: "#292524",
          900: "#1c1917",
          950: "#0c0a09"
        },
        red: {
          50: "#fef2f2",
          100: "#fee2e2",
          200: "#fecaca",
          300: "#fca5a5",
          400: "#f87171",
          500: "#ef4444",
          600: "#dc2626",
          700: "#b91c1c",
          800: "#991b1b",
          900: "#7f1d1d",
          950: "#450a0a"
        },
        orange: {
          50: "#fff7ed",
          100: "#ffedd5",
          200: "#fed7aa",
          300: "#fdba74",
          400: "#fb923c",
          500: "#f97316",
          600: "#ea580c",
          700: "#c2410c",
          800: "#9a3412",
          900: "#7c2d12",
          950: "#431407"
        },
        amber: {
          50: "#fffbeb",
          100: "#fef3c7",
          200: "#fde68a",
          300: "#fcd34d",
          400: "#fbbf24",
          500: "#f59e0b",
          600: "#d97706",
          700: "#b45309",
          800: "#92400e",
          900: "#78350f",
          950: "#451a03"
        },
        yellow: {
          50: "#fefce8",
          100: "#fef9c3",
          200: "#fef08a",
          300: "#fde047",
          400: "#facc15",
          500: "#eab308",
          600: "#ca8a04",
          700: "#a16207",
          800: "#854d0e",
          900: "#713f12",
          950: "#422006"
        },
        lime: {
          50: "#f7fee7",
          100: "#ecfccb",
          200: "#d9f99d",
          300: "#bef264",
          400: "#a3e635",
          500: "#84cc16",
          600: "#65a30d",
          700: "#4d7c0f",
          800: "#3f6212",
          900: "#365314",
          950: "#1a2e05"
        },
        green: {
          50: "#f0fdf4",
          100: "#dcfce7",
          200: "#bbf7d0",
          300: "#86efac",
          400: "#4ade80",
          500: "#22c55e",
          600: "#16a34a",
          700: "#15803d",
          800: "#166534",
          900: "#14532d",
          950: "#052e16"
        },
        emerald: {
          50: "#ecfdf5",
          100: "#d1fae5",
          200: "#a7f3d0",
          300: "#6ee7b7",
          400: "#34d399",
          500: "#10b981",
          600: "#059669",
          700: "#047857",
          800: "#065f46",
          900: "#064e3b",
          950: "#022c22"
        },
        teal: {
          50: "#f0fdfa",
          100: "#ccfbf1",
          200: "#99f6e4",
          300: "#5eead4",
          400: "#2dd4bf",
          500: "#14b8a6",
          600: "#0d9488",
          700: "#0f766e",
          800: "#115e59",
          900: "#134e4a",
          950: "#042f2e"
        },
        cyan: {
          50: "#ecfeff",
          100: "#cffafe",
          200: "#a5f3fc",
          300: "#67e8f9",
          400: "#22d3ee",
          500: "#06b6d4",
          600: "#0891b2",
          700: "#0e7490",
          800: "#155e75",
          900: "#164e63",
          950: "#083344"
        },
        sky: {
          50: "#f0f9ff",
          100: "#e0f2fe",
          200: "#bae6fd",
          300: "#7dd3fc",
          400: "#38bdf8",
          500: "#0ea5e9",
          600: "#0284c7",
          700: "#0369a1",
          800: "#075985",
          900: "#0c4a6e",
          950: "#082f49"
        },
        blue: {
          50: "#eff6ff",
          100: "#dbeafe",
          200: "#bfdbfe",
          300: "#93c5fd",
          400: "#60a5fa",
          500: "#3b82f6",
          600: "#2563eb",
          700: "#1d4ed8",
          800: "#1e40af",
          900: "#1e3a8a",
          950: "#172554"
        },
        indigo: {
          50: "#eef2ff",
          100: "#e0e7ff",
          200: "#c7d2fe",
          300: "#a5b4fc",
          400: "#818cf8",
          500: "#6366f1",
          600: "#4f46e5",
          700: "#4338ca",
          800: "#3730a3",
          900: "#312e81",
          950: "#1e1b4b"
        },
        violet: {
          50: "#f5f3ff",
          100: "#ede9fe",
          200: "#ddd6fe",
          300: "#c4b5fd",
          400: "#a78bfa",
          500: "#8b5cf6",
          600: "#7c3aed",
          700: "#6d28d9",
          800: "#5b21b6",
          900: "#4c1d95",
          950: "#2e1065"
        },
        purple: {
          50: "#faf5ff",
          100: "#f3e8ff",
          200: "#e9d5ff",
          300: "#d8b4fe",
          400: "#c084fc",
          500: "#a855f7",
          600: "#9333ea",
          700: "#7e22ce",
          800: "#6b21a8",
          900: "#581c87",
          950: "#3b0764"
        },
        fuchsia: {
          50: "#fdf4ff",
          100: "#fae8ff",
          200: "#f5d0fe",
          300: "#f0abfc",
          400: "#e879f9",
          500: "#d946ef",
          600: "#c026d3",
          700: "#a21caf",
          800: "#86198f",
          900: "#701a75",
          950: "#4a044e"
        },
        pink: {
          50: "#fdf2f8",
          100: "#fce7f3",
          200: "#fbcfe8",
          300: "#f9a8d4",
          400: "#f472b6",
          500: "#ec4899",
          600: "#db2777",
          700: "#be185d",
          800: "#9d174d",
          900: "#831843",
          950: "#500724"
        },
        rose: {
          50: "#fff1f2",
          100: "#ffe4e6",
          200: "#fecdd3",
          300: "#fda4af",
          400: "#fb7185",
          500: "#f43f5e",
          600: "#e11d48",
          700: "#be123c",
          800: "#9f1239",
          900: "#881337",
          950: "#4c0519"
        },
        get lightBlue() {
          return ar({
            version: "v2.2",
            from: "lightBlue",
            to: "sky"
          }), this.sky;
        },
        get warmGray() {
          return ar({
            version: "v3.0",
            from: "warmGray",
            to: "stone"
          }), this.stone;
        },
        get trueGray() {
          return ar({
            version: "v3.0",
            from: "trueGray",
            to: "neutral"
          }), this.neutral;
        },
        get coolGray() {
          return ar({
            version: "v3.0",
            from: "coolGray",
            to: "gray"
          }), this.gray;
        },
        get blueGray() {
          return ar({
            version: "v3.0",
            from: "blueGray",
            to: "slate"
          }), this.slate;
        }
      };
    });
  function es(i) {
    for (var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      e[_key - 1] = arguments[_key];
    }
    for (var _i3 = 0, _e9 = e; _i3 < _e9.length; _i3++) {
      var t = _e9[_i3];
      for (var r in t) {
        var _i$hasOwnProperty;
        (i === null || i === void 0 || (_i$hasOwnProperty = i.hasOwnProperty) === null || _i$hasOwnProperty === void 0 ? void 0 : _i$hasOwnProperty.call(i, r)) || (i[r] = t[r]);
      }
      var _iterator11 = _createForOfIteratorHelper(Object.getOwnPropertySymbols(t)),
        _step11;
      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var _i$hasOwnProperty2;
          var _r7 = _step11.value;
          (i === null || i === void 0 || (_i$hasOwnProperty2 = i.hasOwnProperty) === null || _i$hasOwnProperty2 === void 0 ? void 0 : _i$hasOwnProperty2.call(i, _r7)) || (i[_r7] = t[_r7]);
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }
    }
    return i;
  }
  var vu = C(function () {
    l();
  });
  function Ke(i) {
    if (Array.isArray(i)) return i;
    var e = i.split("[").length - 1,
      t = i.split("]").length - 1;
    if (e !== t) throw new Error("Path is invalid. Has unbalanced brackets: ".concat(i));
    return i.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
  }
  var pi = C(function () {
    l();
  });
  function K(i, e) {
    var _ref3, _i$future$e, _i$future, _ref4, _i$experimental$e, _i$experimental;
    return di.future.includes(e) ? i.future === "all" || ((_ref3 = (_i$future$e = i === null || i === void 0 || (_i$future = i.future) === null || _i$future === void 0 ? void 0 : _i$future[e]) !== null && _i$future$e !== void 0 ? _i$future$e : xu[e]) !== null && _ref3 !== void 0 ? _ref3 : !1) : di.experimental.includes(e) ? i.experimental === "all" || ((_ref4 = (_i$experimental$e = i === null || i === void 0 || (_i$experimental = i.experimental) === null || _i$experimental === void 0 ? void 0 : _i$experimental[e]) !== null && _i$experimental$e !== void 0 ? _i$experimental$e : xu[e]) !== null && _ref4 !== void 0 ? _ref4 : !1) : !1;
  }
  function ku(i) {
    var _i$experimental2;
    return i.experimental === "all" ? di.experimental : Object.keys((_i$experimental2 = i === null || i === void 0 ? void 0 : i.experimental) !== null && _i$experimental2 !== void 0 ? _i$experimental2 : {}).filter(function (e) {
      return di.experimental.includes(e) && i.experimental[e];
    });
  }
  function Su(i) {
    if (h.env.JEST_WORKER_ID === void 0 && ku(i).length > 0) {
      var e = ku(i).map(function (t) {
        return _e.yellow(t);
      }).join(", ");
      F.warn("experimental-flags-enabled", ["You have enabled experimental features: ".concat(e), "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."]);
    }
  }
  var xu,
    di,
    ze = C(function () {
      l();
      ci();
      Oe();
      xu = {
        optimizeUniversalDefaults: !1,
        generalizedModifiers: !0,
        disableColorOpacityUtilitiesByDefault: !1,
        relativeContentPathsByDefault: !1
      }, di = {
        future: ["hoverOnlyWhenSupported", "respectDefaultRingColorOpacity", "disableColorOpacityUtilitiesByDefault", "relativeContentPathsByDefault"],
        experimental: ["optimizeUniversalDefaults", "generalizedModifiers"]
      };
    });
  function Cu(i) {
    var _i$prefix;
    (function () {
      if (i.purge || !i.content || !Array.isArray(i.content) && !(_typeof(i.content) == "object" && i.content !== null)) return !1;
      if (Array.isArray(i.content)) return i.content.every(function (t) {
        return typeof t == "string" ? !0 : !(typeof (t === null || t === void 0 ? void 0 : t.raw) != "string" || t !== null && t !== void 0 && t.extension && typeof (t === null || t === void 0 ? void 0 : t.extension) != "string");
      });
      if (_typeof(i.content) == "object" && i.content !== null) {
        if (Object.keys(i.content).some(function (t) {
          return !["files", "relative", "extract", "transform"].includes(t);
        })) return !1;
        if (Array.isArray(i.content.files)) {
          if (!i.content.files.every(function (t) {
            return typeof t == "string" ? !0 : !(typeof (t === null || t === void 0 ? void 0 : t.raw) != "string" || t !== null && t !== void 0 && t.extension && typeof (t === null || t === void 0 ? void 0 : t.extension) != "string");
          })) return !1;
          if (_typeof(i.content.extract) == "object") {
            for (var _i4 = 0, _Object$values = Object.values(i.content.extract); _i4 < _Object$values.length; _i4++) {
              var t = _Object$values[_i4];
              if (typeof t != "function") return !1;
            }
          } else if (!(i.content.extract === void 0 || typeof i.content.extract == "function")) return !1;
          if (_typeof(i.content.transform) == "object") {
            for (var _i5 = 0, _Object$values2 = Object.values(i.content.transform); _i5 < _Object$values2.length; _i5++) {
              var _t6 = _Object$values2[_i5];
              if (typeof _t6 != "function") return !1;
            }
          } else if (!(i.content.transform === void 0 || typeof i.content.transform == "function")) return !1;
          if (typeof i.content.relative != "boolean" && typeof i.content.relative != "undefined") return !1;
        }
        return !0;
      }
      return !1;
    })() || F.warn("purge-deprecation", ["The `purge`/`content` options have changed in Tailwind CSS v3.0.", "Update your configuration file to eliminate this warning.", "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"]), i.safelist = function (_r$options) {
      var t = i.content,
        r = i.purge,
        n = i.safelist;
      return Array.isArray(n) ? n : Array.isArray(t === null || t === void 0 ? void 0 : t.safelist) ? t.safelist : Array.isArray(r === null || r === void 0 ? void 0 : r.safelist) ? r.safelist : Array.isArray(r === null || r === void 0 || (_r$options = r.options) === null || _r$options === void 0 ? void 0 : _r$options.safelist) ? r.options.safelist : [];
    }(), i.blocklist = function () {
      var t = i.blocklist;
      if (Array.isArray(t)) {
        if (t.every(function (r) {
          return typeof r == "string";
        })) return t;
        F.warn("blocklist-invalid", ["The `blocklist` option must be an array of strings.", "https://tailwindcss.com/docs/content-configuration#discarding-classes"]);
      }
      return [];
    }(), typeof i.prefix == "function" ? (F.warn("prefix-function", ["As of Tailwind CSS v3.0, `prefix` cannot be a function.", "Update `prefix` in your configuration to be a string to eliminate this warning.", "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"]), i.prefix = "") : i.prefix = (_i$prefix = i.prefix) !== null && _i$prefix !== void 0 ? _i$prefix : "", i.content = {
      relative: function () {
        var t = i.content;
        return t !== null && t !== void 0 && t.relative ? t.relative : K(i, "relativeContentPathsByDefault");
      }(),
      files: function () {
        var t = i.content,
          r = i.purge;
        return Array.isArray(r) ? r : Array.isArray(r === null || r === void 0 ? void 0 : r.content) ? r.content : Array.isArray(t) ? t : Array.isArray(t === null || t === void 0 ? void 0 : t.content) ? t.content : Array.isArray(t === null || t === void 0 ? void 0 : t.files) ? t.files : [];
      }(),
      extract: function () {
        var t = function (_i$purge, _i$content, _i$purge2, _i$content2, _i$purge3, _i$content3) {
            return (_i$purge = i.purge) !== null && _i$purge !== void 0 && _i$purge.extract ? i.purge.extract : (_i$content = i.content) !== null && _i$content !== void 0 && _i$content.extract ? i.content.extract : (_i$purge2 = i.purge) !== null && _i$purge2 !== void 0 && (_i$purge2 = _i$purge2.extract) !== null && _i$purge2 !== void 0 && _i$purge2.DEFAULT ? i.purge.extract.DEFAULT : (_i$content2 = i.content) !== null && _i$content2 !== void 0 && (_i$content2 = _i$content2.extract) !== null && _i$content2 !== void 0 && _i$content2.DEFAULT ? i.content.extract.DEFAULT : (_i$purge3 = i.purge) !== null && _i$purge3 !== void 0 && (_i$purge3 = _i$purge3.options) !== null && _i$purge3 !== void 0 && _i$purge3.extractors ? i.purge.options.extractors : (_i$content3 = i.content) !== null && _i$content3 !== void 0 && (_i$content3 = _i$content3.options) !== null && _i$content3 !== void 0 && _i$content3.extractors ? i.content.options.extractors : {};
          }(),
          r = {},
          n = function (_i$purge4, _i$content4) {
            if ((_i$purge4 = i.purge) !== null && _i$purge4 !== void 0 && (_i$purge4 = _i$purge4.options) !== null && _i$purge4 !== void 0 && _i$purge4.defaultExtractor) return i.purge.options.defaultExtractor;
            if ((_i$content4 = i.content) !== null && _i$content4 !== void 0 && (_i$content4 = _i$content4.options) !== null && _i$content4 !== void 0 && _i$content4.defaultExtractor) return i.content.options.defaultExtractor;
          }();
        if (n !== void 0 && (r.DEFAULT = n), typeof t == "function") r.DEFAULT = t;else if (Array.isArray(t)) {
          var _iterator12 = _createForOfIteratorHelper(t !== null && t !== void 0 ? t : []),
            _step12;
          try {
            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
              var _step12$value = _step12.value,
                a = _step12$value.extensions,
                s = _step12$value.extractor;
              var _iterator13 = _createForOfIteratorHelper(a),
                _step13;
              try {
                for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
                  var o = _step13.value;
                  r[o] = s;
                }
              } catch (err) {
                _iterator13.e(err);
              } finally {
                _iterator13.f();
              }
            }
          } catch (err) {
            _iterator12.e(err);
          } finally {
            _iterator12.f();
          }
        } else _typeof(t) == "object" && t !== null && Object.assign(r, t);
        return r;
      }(),
      transform: function () {
        var t = function (_i$purge5, _i$content5, _i$purge6, _i$content6) {
            return (_i$purge5 = i.purge) !== null && _i$purge5 !== void 0 && _i$purge5.transform ? i.purge.transform : (_i$content5 = i.content) !== null && _i$content5 !== void 0 && _i$content5.transform ? i.content.transform : (_i$purge6 = i.purge) !== null && _i$purge6 !== void 0 && (_i$purge6 = _i$purge6.transform) !== null && _i$purge6 !== void 0 && _i$purge6.DEFAULT ? i.purge.transform.DEFAULT : (_i$content6 = i.content) !== null && _i$content6 !== void 0 && (_i$content6 = _i$content6.transform) !== null && _i$content6 !== void 0 && _i$content6.DEFAULT ? i.content.transform.DEFAULT : {};
          }(),
          r = {};
        return typeof t == "function" && (r.DEFAULT = t), _typeof(t) == "object" && t !== null && Object.assign(r, t), r;
      }()
    };
    var _iterator14 = _createForOfIteratorHelper(i.content.files),
      _step14;
    try {
      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
        var t = _step14.value;
        if (typeof t == "string" && /{([^,]*?)}/g.test(t)) {
          F.warn("invalid-glob-braces", ["The glob pattern ".concat(Xn(t), " in your Tailwind CSS configuration is invalid."), "Update it to ".concat(Xn(t.replace(/{([^,]*?)}/g, "$1")), " to silence this warning.")]);
          break;
        }
      }
    } catch (err) {
      _iterator14.e(err);
    } finally {
      _iterator14.f();
    }
    return i;
  }
  var Au = C(function () {
    l();
    ze();
    Oe();
  });
  function ie(i) {
    if (Object.prototype.toString.call(i) !== "[object Object]") return !1;
    var e = Object.getPrototypeOf(i);
    return e === null || Object.getPrototypeOf(e) === null;
  }
  var St = C(function () {
    l();
  });
  function Ze(i) {
    return Array.isArray(i) ? i.map(function (e) {
      return Ze(e);
    }) : _typeof(i) == "object" && i !== null ? Object.fromEntries(Object.entries(i).map(function (_ref5) {
      var _ref6 = _slicedToArray(_ref5, 2),
        e = _ref6[0],
        t = _ref6[1];
      return [e, Ze(t)];
    })) : i;
  }
  var hi = C(function () {
    l();
  });
  function gt(i) {
    return i.replace(/\\,/g, "\\2c ");
  }
  var mi = C(function () {
    l();
  });
  var ts,
    _u = C(function () {
      l();
      ts = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50]
      };
    });
  function or(i) {
    var _i$match, _r$, _r$$toString;
    var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref7$loose = _ref7.loose,
      e = _ref7$loose === void 0 ? !1 : _ref7$loose;
    if (typeof i != "string") return null;
    if (i = i.trim(), i === "transparent") return {
      mode: "rgb",
      color: ["0", "0", "0"],
      alpha: "0"
    };
    if (i in ts) return {
      mode: "rgb",
      color: ts[i].map(function (a) {
        return a.toString();
      })
    };
    var t = i.replace(_b, function (a, s, o, u, c) {
      return ["#", s, s, o, o, u, u, c ? c + c : ""].join("");
    }).match(Ab);
    if (t !== null) return {
      mode: "rgb",
      color: [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)].map(function (a) {
        return a.toString();
      }),
      alpha: t[4] ? (parseInt(t[4], 16) / 255).toString() : void 0
    };
    var r = (_i$match = i.match(Ob)) !== null && _i$match !== void 0 ? _i$match : i.match(Eb);
    if (r === null) return null;
    var n = [r[2], r[3], r[4]].filter(Boolean).map(function (a) {
      return a.toString();
    });
    return n.length === 2 && n[0].startsWith("var(") ? {
      mode: r[1],
      color: [n[0]],
      alpha: n[1]
    } : !e && n.length !== 3 || n.length < 3 && !n.some(function (a) {
      return /^var\(.*?\)$/.test(a);
    }) ? null : {
      mode: r[1],
      color: n,
      alpha: (_r$ = r[5]) === null || _r$ === void 0 || (_r$$toString = _r$.toString) === null || _r$$toString === void 0 ? void 0 : _r$$toString.call(_r$)
    };
  }
  function rs(_ref8) {
    var i = _ref8.mode,
      e = _ref8.color,
      t = _ref8.alpha;
    var r = t !== void 0;
    return i === "rgba" || i === "hsla" ? "".concat(i, "(").concat(e.join(", ")).concat(r ? ", ".concat(t) : "", ")") : "".concat(i, "(").concat(e.join(" ")).concat(r ? " / ".concat(t) : "", ")");
  }
  var Ab,
    _b,
    et,
    gi,
    Ou,
    tt,
    Ob,
    Eb,
    is = C(function () {
      l();
      _u();
      Ab = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i, _b = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i, et = /(?:\d+|\d*\.\d+)%?/, gi = /(?:\s*,\s*|\s+)/, Ou = /\s*[,/]\s*/, tt = /var\(--(?:[^ )]*?)(?:,(?:[^ )]*?|var\(--[^ )]*?\)))?\)/, Ob = new RegExp("^(rgba?)\\(\\s*(".concat(et.source, "|").concat(tt.source, ")(?:").concat(gi.source, "(").concat(et.source, "|").concat(tt.source, "))?(?:").concat(gi.source, "(").concat(et.source, "|").concat(tt.source, "))?(?:").concat(Ou.source, "(").concat(et.source, "|").concat(tt.source, "))?\\s*\\)$")), Eb = new RegExp("^(hsla?)\\(\\s*((?:".concat(et.source, ")(?:deg|rad|grad|turn)?|").concat(tt.source, ")(?:").concat(gi.source, "(").concat(et.source, "|").concat(tt.source, "))?(?:").concat(gi.source, "(").concat(et.source, "|").concat(tt.source, "))?(?:").concat(Ou.source, "(").concat(et.source, "|").concat(tt.source, "))?\\s*\\)$"));
    });
  function Ie(i, e, t) {
    if (typeof i == "function") return i({
      opacityValue: e
    });
    var r = or(i, {
      loose: !0
    });
    return r === null ? t : rs(_objectSpread(_objectSpread({}, r), {}, {
      alpha: e
    }));
  }
  function se(_ref9) {
    var i = _ref9.color,
      e = _ref9.property,
      t = _ref9.variable;
    var r = [].concat(e);
    if (typeof i == "function") return _objectSpread(_defineProperty({}, t, "1"), Object.fromEntries(r.map(function (a) {
      return [a, i({
        opacityVariable: t,
        opacityValue: "var(".concat(t, ")")
      })];
    })));
    var n = or(i);
    return n === null ? Object.fromEntries(r.map(function (a) {
      return [a, i];
    })) : n.alpha !== void 0 ? Object.fromEntries(r.map(function (a) {
      return [a, i];
    })) : _objectSpread(_defineProperty({}, t, "1"), Object.fromEntries(r.map(function (a) {
      return [a, rs(_objectSpread(_objectSpread({}, n), {}, {
        alpha: "var(".concat(t, ")")
      }))];
    })));
  }
  var lr = C(function () {
    l();
    is();
  });
  function ae(i, e) {
    var t = [],
      r = [],
      n = 0,
      a = !1;
    for (var s = 0; s < i.length; s++) {
      var o = i[s];
      t.length === 0 && o === e[0] && !a && (e.length === 1 || i.slice(s, s + e.length) === e) && (r.push(i.slice(n, s)), n = s + e.length), a ? a = !1 : o === "\\" && (a = !0), o === "(" || o === "[" || o === "{" ? t.push(o) : (o === ")" && t[t.length - 1] === "(" || o === "]" && t[t.length - 1] === "[" || o === "}" && t[t.length - 1] === "{") && t.pop();
    }
    return r.push(i.slice(n)), r;
  }
  var Ct = C(function () {
    l();
  });
  function yi(i) {
    return ae(i, ",").map(function (t) {
      var r = t.trim(),
        n = {
          raw: r
        },
        a = r.split(Pb),
        s = new Set();
      var _iterator15 = _createForOfIteratorHelper(a),
        _step15;
      try {
        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
          var o = _step15.value;
          Eu.lastIndex = 0, !s.has("KEYWORD") && Tb.has(o) ? (n.keyword = o, s.add("KEYWORD")) : Eu.test(o) ? s.has("X") ? s.has("Y") ? s.has("BLUR") ? s.has("SPREAD") || (n.spread = o, s.add("SPREAD")) : (n.blur = o, s.add("BLUR")) : (n.y = o, s.add("Y")) : (n.x = o, s.add("X")) : n.color ? (n.unknown || (n.unknown = []), n.unknown.push(o)) : n.color = o;
        }
      } catch (err) {
        _iterator15.e(err);
      } finally {
        _iterator15.f();
      }
      return n.valid = n.x !== void 0 && n.y !== void 0, n;
    });
  }
  function Tu(i) {
    return i.map(function (e) {
      return e.valid ? [e.keyword, e.x, e.y, e.blur, e.spread, e.color].filter(Boolean).join(" ") : e.raw;
    }).join(", ");
  }
  var Tb,
    Pb,
    Eu,
    ns = C(function () {
      l();
      Ct();
      Tb = new Set(["inset", "inherit", "initial", "revert", "unset"]), Pb = /\ +(?![^(]*\))/g, Eu = /^-?(\d+|\.\d+)(.*?)$/g;
    });
  function ss(i) {
    return Db.some(function (e) {
      return new RegExp("^".concat(e, "\\(.*\\)")).test(i);
    });
  }
  function N(i) {
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
    var r = e && Ib.has(e.property);
    return i.startsWith("--") && !r ? "var(".concat(i, ")") : i.includes("url(") ? i.split(/(url\(.*?\))/g).filter(Boolean).map(function (n) {
      return /^url\(.*?\)$/.test(n) ? n : N(n, e, !1);
    }).join("") : (i = i.replace(/([^\\])_+/g, function (n, a) {
      return a + " ".repeat(n.length - 1);
    }).replace(/^_/g, " ").replace(/\\_/g, "_"), t && (i = i.trim()), i = qb(i), i);
  }
  function qb(i) {
    var e = ["theme"],
      t = ["min-content", "max-content", "fit-content", "safe-area-inset-top", "safe-area-inset-right", "safe-area-inset-bottom", "safe-area-inset-left", "titlebar-area-x", "titlebar-area-y", "titlebar-area-width", "titlebar-area-height", "keyboard-inset-top", "keyboard-inset-right", "keyboard-inset-bottom", "keyboard-inset-left", "keyboard-inset-width", "keyboard-inset-height", "radial-gradient", "linear-gradient", "conic-gradient", "repeating-radial-gradient", "repeating-linear-gradient", "repeating-conic-gradient"];
    return i.replace(/(calc|min|max|clamp)\(.+\)/g, function (r) {
      var n = "";
      function a() {
        var s = n.trimEnd();
        return s[s.length - 1];
      }
      var _loop2 = function _loop2(_s2) {
        var o = function o(f) {
            return f.split("").every(function (d, p) {
              return r[_s2 + p] === d;
            });
          },
          u = function u(f) {
            var d = 1 / 0;
            var _iterator16 = _createForOfIteratorHelper(f),
              _step16;
            try {
              for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                var m = _step16.value;
                var b = r.indexOf(m, _s2);
                b !== -1 && b < d && (d = b);
              }
            } catch (err) {
              _iterator16.e(err);
            } finally {
              _iterator16.f();
            }
            var p = r.slice(_s2, d);
            return _s2 += p.length - 1, p;
          },
          c = r[_s2];
        if (o("var")) n += u([")", ","]);else if (t.some(function (f) {
          return o(f);
        })) {
          var f = t.find(function (d) {
            return o(d);
          });
          n += f, _s2 += f.length - 1;
        } else e.some(function (f) {
          return o(f);
        }) ? n += u([")"]) : o("[") ? n += u(["]"]) : ["+", "-", "*", "/"].includes(c) && !["(", "+", "-", "*", "/", ","].includes(a()) ? n += " ".concat(c, " ") : n += c;
        s = _s2;
      };
      for (var s = 0; s < r.length; s++) {
        _loop2(s);
      }
      return n.replace(/\s+/g, " ");
    });
  }
  function as(i) {
    return i.startsWith("url(");
  }
  function os(i) {
    return !isNaN(Number(i)) || ss(i);
  }
  function ur(i) {
    return i.endsWith("%") && os(i.slice(0, -1)) || ss(i);
  }
  function fr(i) {
    return i === "0" || new RegExp("^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?".concat(Mb, "$")).test(i) || ss(i);
  }
  function Pu(i) {
    return Bb.has(i);
  }
  function Du(i) {
    var e = yi(N(i));
    var _iterator17 = _createForOfIteratorHelper(e),
      _step17;
    try {
      for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
        var t = _step17.value;
        if (!t.valid) return !1;
      }
    } catch (err) {
      _iterator17.e(err);
    } finally {
      _iterator17.f();
    }
    return !0;
  }
  function Iu(i) {
    var e = 0;
    return ae(i, "_").every(function (r) {
      return r = N(r), r.startsWith("var(") ? !0 : or(r, {
        loose: !0
      }) !== null ? (e++, !0) : !1;
    }) ? e > 0 : !1;
  }
  function qu(i) {
    var e = 0;
    return ae(i, ",").every(function (r) {
      return r = N(r), r.startsWith("var(") ? !0 : as(r) || Nb(r) || ["element(", "image(", "cross-fade(", "image-set("].some(function (n) {
        return r.startsWith(n);
      }) ? (e++, !0) : !1;
    }) ? e > 0 : !1;
  }
  function Nb(i) {
    i = N(i);
    var _iterator18 = _createForOfIteratorHelper(Fb),
      _step18;
    try {
      for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
        var e = _step18.value;
        if (i.startsWith("".concat(e, "("))) return !0;
      }
    } catch (err) {
      _iterator18.e(err);
    } finally {
      _iterator18.f();
    }
    return !1;
  }
  function Ru(i) {
    var e = 0;
    return ae(i, "_").every(function (r) {
      return r = N(r), r.startsWith("var(") ? !0 : Lb.has(r) || fr(r) || ur(r) ? (e++, !0) : !1;
    }) ? e > 0 : !1;
  }
  function Mu(i) {
    var e = 0;
    return ae(i, ",").every(function (r) {
      return r = N(r), r.startsWith("var(") ? !0 : r.includes(" ") && !/(['"])([^"']+)\1/g.test(r) || /^\d/g.test(r) ? !1 : (e++, !0);
    }) ? e > 0 : !1;
  }
  function Bu(i) {
    return $b.has(i);
  }
  function Fu(i) {
    return jb.has(i);
  }
  function Nu(i) {
    return zb.has(i);
  }
  var Db,
    Ib,
    Rb,
    Mb,
    Bb,
    Fb,
    Lb,
    $b,
    jb,
    zb,
    cr = C(function () {
      l();
      is();
      ns();
      Ct();
      Db = ["min", "max", "clamp", "calc"];
      Ib = new Set(["scroll-timeline-name", "timeline-scope", "view-timeline-name", "font-palette", "scroll-timeline", "animation-timeline", "view-timeline"]);
      Rb = ["cm", "mm", "Q", "in", "pc", "pt", "px", "em", "ex", "ch", "rem", "lh", "rlh", "vw", "vh", "vmin", "vmax", "vb", "vi", "svw", "svh", "lvw", "lvh", "dvw", "dvh", "cqw", "cqh", "cqi", "cqb", "cqmin", "cqmax"], Mb = "(?:".concat(Rb.join("|"), ")");
      Bb = new Set(["thin", "medium", "thick"]);
      Fb = new Set(["conic-gradient", "linear-gradient", "radial-gradient", "repeating-conic-gradient", "repeating-linear-gradient", "repeating-radial-gradient"]);
      Lb = new Set(["center", "top", "right", "bottom", "left"]);
      $b = new Set(["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]);
      jb = new Set(["xx-small", "x-small", "small", "medium", "large", "x-large", "xx-large", "xxx-large"]);
      zb = new Set(["larger", "smaller"]);
    });
  function Lu(i) {
    var e = ["cover", "contain"];
    return ae(i, ",").every(function (t) {
      var r = ae(t, "_").filter(Boolean);
      return r.length === 1 && e.includes(r[0]) ? !0 : r.length !== 1 && r.length !== 2 ? !1 : r.every(function (n) {
        return fr(n) || ur(n) || n === "auto";
      });
    });
  }
  var $u = C(function () {
    l();
    cr();
    Ct();
  });
  function ju(i, e) {
    i.walkClasses(function (t) {
      t.value = e(t.value), t.raws && t.raws.value && (t.raws.value = gt(t.raws.value));
    });
  }
  function zu(i, e) {
    if (!rt(i)) return;
    var t = i.slice(1, -1);
    if (!!e(t)) return N(t);
  }
  function Vb(i) {
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var t = arguments.length > 2 ? arguments[2] : undefined;
    var r = e[i];
    if (r !== void 0) return Xe(r);
    if (rt(i)) {
      var n = zu(i, t);
      return n === void 0 ? void 0 : Xe(n);
    }
  }
  function wi(i) {
    var _e$values;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _ref10 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref10$validate = _ref10.validate,
      t = _ref10$validate === void 0 ? function () {
        return !0;
      } : _ref10$validate;
    var r = (_e$values = e.values) === null || _e$values === void 0 ? void 0 : _e$values[i];
    return r !== void 0 ? r : e.supportsNegativeValues && i.startsWith("-") ? Vb(i.slice(1), e.values, t) : zu(i, t);
  }
  function rt(i) {
    return i.startsWith("[") && i.endsWith("]");
  }
  function Vu(i) {
    var e = i.lastIndexOf("/"),
      t = i.lastIndexOf("[", e),
      r = i.indexOf("]", e);
    return i[e - 1] === "]" || i[e + 1] === "[" || t !== -1 && r !== -1 && t < e && e < r && (e = i.lastIndexOf("/", t)), e === -1 || e === i.length - 1 ? [i, void 0] : rt(i) && !i.includes("]/[") ? [i, void 0] : [i.slice(0, e), i.slice(e + 1)];
  }
  function At(i) {
    if (typeof i == "string" && i.includes("<alpha-value>")) {
      var e = i;
      return function (_ref11) {
        var _ref11$opacityValue = _ref11.opacityValue,
          t = _ref11$opacityValue === void 0 ? 1 : _ref11$opacityValue;
        return e.replace(/<alpha-value>/g, t);
      };
    }
    return i;
  }
  function Uu(i) {
    return N(i.slice(1, -1));
  }
  function Ub(i) {
    var _e$values2, _e$values3;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _ref12 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref12$tailwindConfig = _ref12.tailwindConfig,
      t = _ref12$tailwindConfig === void 0 ? {} : _ref12$tailwindConfig;
    if (((_e$values2 = e.values) === null || _e$values2 === void 0 ? void 0 : _e$values2[i]) !== void 0) return At((_e$values3 = e.values) === null || _e$values3 === void 0 ? void 0 : _e$values3[i]);
    var _Vu = Vu(i),
      _Vu2 = _slicedToArray(_Vu, 2),
      r = _Vu2[0],
      n = _Vu2[1];
    if (n !== void 0) {
      var _e$values$r, _e$values4, _t$theme;
      var a = (_e$values$r = (_e$values4 = e.values) === null || _e$values4 === void 0 ? void 0 : _e$values4[r]) !== null && _e$values$r !== void 0 ? _e$values$r : rt(r) ? r.slice(1, -1) : void 0;
      return a === void 0 ? void 0 : (a = At(a), rt(n) ? Ie(a, Uu(n)) : ((_t$theme = t.theme) === null || _t$theme === void 0 || (_t$theme = _t$theme.opacity) === null || _t$theme === void 0 ? void 0 : _t$theme[n]) === void 0 ? void 0 : Ie(a, t.theme.opacity[n]));
    }
    return wi(i, e, {
      validate: Iu
    });
  }
  function Wb(i) {
    var _e$values5;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return (_e$values5 = e.values) === null || _e$values5 === void 0 ? void 0 : _e$values5[i];
  }
  function me(i) {
    return function (e, t) {
      return wi(e, t, {
        validate: i
      });
    };
  }
  function Gb(i, e) {
    var t = i.indexOf(e);
    return t === -1 ? [void 0, i] : [i.slice(0, t), i.slice(t + 1)];
  }
  function us(i, e, t, r) {
    if (t.values && e in t.values) {
      var _iterator19 = _createForOfIteratorHelper(i !== null && i !== void 0 ? i : []),
        _step19;
      try {
        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
          var a = _step19.value.type;
          var s = ls[a](e, t, {
            tailwindConfig: r
          });
          if (s !== void 0) return [s, a, null];
        }
      } catch (err) {
        _iterator19.e(err);
      } finally {
        _iterator19.f();
      }
    }
    if (rt(e)) {
      var _a3 = e.slice(1, -1),
        _Gb = Gb(_a3, ":"),
        _Gb2 = _slicedToArray(_Gb, 2),
        _s3 = _Gb2[0],
        o = _Gb2[1];
      if (!/^[\w-_]+$/g.test(_s3)) o = _a3;else if (_s3 !== void 0 && !Wu.includes(_s3)) return [];
      if (o.length > 0 && Wu.includes(_s3)) return [wi("[".concat(o, "]"), t), _s3, null];
    }
    var n = fs(i, e, t, r);
    var _iterator20 = _createForOfIteratorHelper(n),
      _step20;
    try {
      for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
        var _a4 = _step20.value;
        return _a4;
      }
    } catch (err) {
      _iterator20.e(err);
    } finally {
      _iterator20.f();
    }
    return [];
  }
  function fs(i, e, t, r) {
    var n, _Vu3, _Vu4, a, s, _t$modifiers$s, _t$modifiers, u, _iterator21, _step21, _s4, _u2, c;
    return _regeneratorRuntime().wrap(function fs$(_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          n = K(r, "generalizedModifiers"), _Vu3 = Vu(e), _Vu4 = _slicedToArray(_Vu3, 2), a = _Vu4[0], s = _Vu4[1];
          if (n && t.modifiers != null && (t.modifiers === "any" || _typeof(t.modifiers) == "object" && (s && rt(s) || s in t.modifiers)) || (a = e, s = void 0), s !== void 0 && a === "" && (a = "DEFAULT"), s !== void 0 && _typeof(t.modifiers) == "object") {
            u = (_t$modifiers$s = (_t$modifiers = t.modifiers) === null || _t$modifiers === void 0 ? void 0 : _t$modifiers[s]) !== null && _t$modifiers$s !== void 0 ? _t$modifiers$s : null;
            u !== null ? s = u : rt(s) && (s = Uu(s));
          }
          _iterator21 = _createForOfIteratorHelper(i !== null && i !== void 0 ? i : []);
          _context7.prev = 3;
          _iterator21.s();
        case 5:
          if ((_step21 = _iterator21.n()).done) {
            _context7.next = 14;
            break;
          }
          _u2 = _step21.value.type;
          c = ls[_u2](a, t, {
            tailwindConfig: r
          });
          _context7.t0 = c !== void 0;
          if (!_context7.t0) {
            _context7.next = 12;
            break;
          }
          _context7.next = 12;
          return [c, _u2, (_s4 = s) !== null && _s4 !== void 0 ? _s4 : null];
        case 12:
          _context7.next = 5;
          break;
        case 14:
          _context7.next = 19;
          break;
        case 16:
          _context7.prev = 16;
          _context7.t1 = _context7["catch"](3);
          _iterator21.e(_context7.t1);
        case 19:
          _context7.prev = 19;
          _iterator21.f();
          return _context7.finish(19);
        case 22:
        case "end":
          return _context7.stop();
      }
    }, _marked, null, [[3, 16, 19, 22]]);
  }
  var ls,
    Wu,
    pr = C(function () {
      l();
      mi();
      lr();
      cr();
      fi();
      $u();
      ze();
      ls = {
        any: wi,
        color: Ub,
        url: me(as),
        image: me(qu),
        length: me(fr),
        percentage: me(ur),
        position: me(Ru),
        lookup: Wb,
        "generic-name": me(Bu),
        "family-name": me(Mu),
        number: me(os),
        "line-width": me(Pu),
        "absolute-size": me(Fu),
        "relative-size": me(Nu),
        shadow: me(Du),
        size: me(Lu)
      }, Wu = Object.keys(ls);
    });
  function L(i) {
    return typeof i == "function" ? i({}) : i;
  }
  var cs = C(function () {
    l();
  });
  function _t(i) {
    return typeof i == "function";
  }
  function dr(i) {
    for (var _len2 = arguments.length, e = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      e[_key2 - 1] = arguments[_key2];
    }
    var t = e.pop();
    for (var _i6 = 0, _e10 = e; _i6 < _e10.length; _i6++) {
      var r = _e10[_i6];
      for (var n in r) {
        var a = t(i[n], r[n]);
        a === void 0 ? ie(i[n]) && ie(r[n]) ? i[n] = dr({}, i[n], r[n], t) : i[n] = r[n] : i[n] = a;
      }
    }
    return i;
  }
  function Hb(i) {
    for (var _len3 = arguments.length, e = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      e[_key3 - 1] = arguments[_key3];
    }
    return _t(i) ? i.apply(void 0, e) : i;
  }
  function Yb(i) {
    return i.reduce(function (e, _ref13) {
      var t = _ref13.extend;
      return dr(e, t, function (r, n) {
        return r === void 0 ? [n] : Array.isArray(r) ? [n].concat(_toConsumableArray(r)) : [n, r];
      });
    }, {});
  }
  function Qb(i) {
    return _objectSpread(_objectSpread({}, i.reduce(function (e, t) {
      return es(e, t);
    }, {})), {}, {
      extend: Yb(i)
    });
  }
  function Gu(i, e) {
    if (Array.isArray(i) && ie(i[0])) return i.concat(e);
    if (Array.isArray(e) && ie(e[0]) && ie(i)) return [i].concat(_toConsumableArray(e));
    if (Array.isArray(e)) return e;
  }
  function Jb(_ref14) {
    var i = _ref14.extend,
      e = _objectWithoutProperties(_ref14, _excluded);
    return dr(e, i, function (t, r) {
      return !_t(t) && !r.some(_t) ? dr.apply(void 0, [{}, t].concat(_toConsumableArray(r), [Gu])) : function (n, a) {
        return dr.apply(void 0, [{}].concat(_toConsumableArray([t].concat(_toConsumableArray(r)).map(function (s) {
          return Hb(s, n, a);
        })), [Gu]));
      };
    });
  }
  function Xb(i) {
    var e, t, r, _r8, n, a, s;
    return _regeneratorRuntime().wrap(function Xb$(_context8) {
      while (1) switch (_context8.prev = _context8.next) {
        case 0:
          e = Ke(i);
          _context8.t0 = e.length === 0;
          if (_context8.t0) {
            _context8.next = 6;
            break;
          }
          _context8.next = 5;
          return e;
        case 5:
          _context8.t0 = Array.isArray(i);
        case 6:
          if (!_context8.t0) {
            _context8.next = 8;
            break;
          }
          return _context8.abrupt("return");
        case 8:
          t = /^(.*?)\s*\/\s*([^/]+)$/, r = i.match(t);
          if (!(r !== null)) {
            _context8.next = 14;
            break;
          }
          _r8 = _slicedToArray(r, 3), n = _r8[1], a = _r8[2], s = Ke(n);
          s.alpha = a;
          _context8.next = 14;
          return s;
        case 14:
        case "end":
          return _context8.stop();
      }
    }, _marked2);
  }
  function Kb(i) {
    var e = function e(t, r) {
      var _iterator22 = _createForOfIteratorHelper(Xb(t)),
        _step22;
      try {
        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
          var n = _step22.value;
          var a = 0,
            s = i;
          for (; s != null && a < n.length;) s = s[n[a++]], s = _t(s) && (n.alpha === void 0 || a <= n.length - 1) ? s(e, ps) : s;
          if (s !== void 0) {
            if (n.alpha !== void 0) {
              var o = At(s);
              return Ie(o, n.alpha, L(o));
            }
            return ie(s) ? Ze(s) : s;
          }
        }
      } catch (err) {
        _iterator22.e(err);
      } finally {
        _iterator22.f();
      }
      return r;
    };
    return Object.assign(e, _objectSpread({
      theme: e
    }, ps)), Object.keys(i).reduce(function (t, r) {
      return t[r] = _t(i[r]) ? i[r](e, ps) : i[r], t;
    }, {});
  }
  function Hu(i) {
    var e = [];
    return i.forEach(function (t) {
      var _t$plugins;
      e = [].concat(_toConsumableArray(e), [t]);
      var r = (_t$plugins = t === null || t === void 0 ? void 0 : t.plugins) !== null && _t$plugins !== void 0 ? _t$plugins : [];
      r.length !== 0 && r.forEach(function (n) {
        var _n$config, _n3;
        n.__isOptionsFunction && (n = n()), e = [].concat(_toConsumableArray(e), _toConsumableArray(Hu([(_n$config = (_n3 = n) === null || _n3 === void 0 ? void 0 : _n3.config) !== null && _n$config !== void 0 ? _n$config : {}])));
      });
    }), e;
  }
  function Zb(i) {
    return _toConsumableArray(i).reduceRight(function (t, r) {
      return _t(r) ? r({
        corePlugins: t
      }) : mu(r, t);
    }, du);
  }
  function e0(i) {
    return _toConsumableArray(i).reduceRight(function (t, r) {
      return [].concat(_toConsumableArray(t), _toConsumableArray(r));
    }, []);
  }
  function ds(i) {
    var e = [].concat(_toConsumableArray(Hu(i)), [{
      prefix: "",
      important: !1,
      separator: ":"
    }]);
    return Cu(es.apply(void 0, [{
      theme: Kb(Jb(Qb(e.map(function (t) {
        var _t$theme2;
        return (_t$theme2 = t === null || t === void 0 ? void 0 : t.theme) !== null && _t$theme2 !== void 0 ? _t$theme2 : {};
      })))),
      corePlugins: Zb(e.map(function (t) {
        return t.corePlugins;
      })),
      plugins: e0(i.map(function (t) {
        var _t$plugins2;
        return (_t$plugins2 = t === null || t === void 0 ? void 0 : t.plugins) !== null && _t$plugins2 !== void 0 ? _t$plugins2 : [];
      }))
    }].concat(_toConsumableArray(e))));
  }
  var ps,
    Yu = C(function () {
      l();
      fi();
      hu();
      gu();
      Zn();
      vu();
      pi();
      Au();
      St();
      hi();
      pr();
      lr();
      cs();
      ps = {
        colors: Kn,
        negative: function negative(i) {
          return Object.keys(i).filter(function (e) {
            return i[e] !== "0";
          }).reduce(function (e, t) {
            var r = Xe(i[t]);
            return r !== void 0 && (e["-".concat(t)] = r), e;
          }, {});
        },
        breakpoints: function breakpoints(i) {
          return Object.keys(i).filter(function (e) {
            return typeof i[e] == "string";
          }).reduce(function (e, t) {
            return _objectSpread(_objectSpread({}, e), {}, _defineProperty({}, "screen-".concat(t), i[t]));
          }, {});
        }
      };
    });
  var bi = v(function (qE, Qu) {
    l();
    Qu.exports = {
      content: [],
      presets: [],
      darkMode: "media",
      theme: {
        accentColor: function accentColor(_ref15) {
          var i = _ref15.theme;
          return _objectSpread(_objectSpread({}, i("colors")), {}, {
            auto: "auto"
          });
        },
        animation: {
          none: "none",
          spin: "spin 1s linear infinite",
          ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
          pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
          bounce: "bounce 1s infinite"
        },
        aria: {
          busy: 'busy="true"',
          checked: 'checked="true"',
          disabled: 'disabled="true"',
          expanded: 'expanded="true"',
          hidden: 'hidden="true"',
          pressed: 'pressed="true"',
          readonly: 'readonly="true"',
          required: 'required="true"',
          selected: 'selected="true"'
        },
        aspectRatio: {
          auto: "auto",
          square: "1 / 1",
          video: "16 / 9"
        },
        backdropBlur: function backdropBlur(_ref16) {
          var i = _ref16.theme;
          return i("blur");
        },
        backdropBrightness: function backdropBrightness(_ref17) {
          var i = _ref17.theme;
          return i("brightness");
        },
        backdropContrast: function backdropContrast(_ref18) {
          var i = _ref18.theme;
          return i("contrast");
        },
        backdropGrayscale: function backdropGrayscale(_ref19) {
          var i = _ref19.theme;
          return i("grayscale");
        },
        backdropHueRotate: function backdropHueRotate(_ref20) {
          var i = _ref20.theme;
          return i("hueRotate");
        },
        backdropInvert: function backdropInvert(_ref21) {
          var i = _ref21.theme;
          return i("invert");
        },
        backdropOpacity: function backdropOpacity(_ref22) {
          var i = _ref22.theme;
          return i("opacity");
        },
        backdropSaturate: function backdropSaturate(_ref23) {
          var i = _ref23.theme;
          return i("saturate");
        },
        backdropSepia: function backdropSepia(_ref24) {
          var i = _ref24.theme;
          return i("sepia");
        },
        backgroundColor: function backgroundColor(_ref25) {
          var i = _ref25.theme;
          return i("colors");
        },
        backgroundImage: {
          none: "none",
          "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
          "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
          "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
          "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
          "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
          "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
          "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
          "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
        },
        backgroundOpacity: function backgroundOpacity(_ref26) {
          var i = _ref26.theme;
          return i("opacity");
        },
        backgroundPosition: {
          bottom: "bottom",
          center: "center",
          left: "left",
          "left-bottom": "left bottom",
          "left-top": "left top",
          right: "right",
          "right-bottom": "right bottom",
          "right-top": "right top",
          top: "top"
        },
        backgroundSize: {
          auto: "auto",
          cover: "cover",
          contain: "contain"
        },
        blur: {
          0: "0",
          none: "0",
          sm: "4px",
          DEFAULT: "8px",
          md: "12px",
          lg: "16px",
          xl: "24px",
          "2xl": "40px",
          "3xl": "64px"
        },
        borderColor: function borderColor(_ref27) {
          var i = _ref27.theme;
          return _objectSpread(_objectSpread({}, i("colors")), {}, {
            DEFAULT: i("colors.gray.200", "currentColor")
          });
        },
        borderOpacity: function borderOpacity(_ref28) {
          var i = _ref28.theme;
          return i("opacity");
        },
        borderRadius: {
          none: "0px",
          sm: "0.125rem",
          DEFAULT: "0.25rem",
          md: "0.375rem",
          lg: "0.5rem",
          xl: "0.75rem",
          "2xl": "1rem",
          "3xl": "1.5rem",
          full: "9999px"
        },
        borderSpacing: function borderSpacing(_ref29) {
          var i = _ref29.theme;
          return _objectSpread({}, i("spacing"));
        },
        borderWidth: {
          DEFAULT: "1px",
          0: "0px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        boxShadow: {
          sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
          DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
          md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
          lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
          xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
          "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
          inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
          none: "none"
        },
        boxShadowColor: function boxShadowColor(_ref30) {
          var i = _ref30.theme;
          return i("colors");
        },
        brightness: {
          0: "0",
          50: ".5",
          75: ".75",
          90: ".9",
          95: ".95",
          100: "1",
          105: "1.05",
          110: "1.1",
          125: "1.25",
          150: "1.5",
          200: "2"
        },
        caretColor: function caretColor(_ref31) {
          var i = _ref31.theme;
          return i("colors");
        },
        colors: function colors(_ref32) {
          var i = _ref32.colors;
          return {
            inherit: i.inherit,
            current: i.current,
            transparent: i.transparent,
            black: i.black,
            white: i.white,
            slate: i.slate,
            gray: i.gray,
            zinc: i.zinc,
            neutral: i.neutral,
            stone: i.stone,
            red: i.red,
            orange: i.orange,
            amber: i.amber,
            yellow: i.yellow,
            lime: i.lime,
            green: i.green,
            emerald: i.emerald,
            teal: i.teal,
            cyan: i.cyan,
            sky: i.sky,
            blue: i.blue,
            indigo: i.indigo,
            violet: i.violet,
            purple: i.purple,
            fuchsia: i.fuchsia,
            pink: i.pink,
            rose: i.rose
          };
        },
        columns: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12",
          "3xs": "16rem",
          "2xs": "18rem",
          xs: "20rem",
          sm: "24rem",
          md: "28rem",
          lg: "32rem",
          xl: "36rem",
          "2xl": "42rem",
          "3xl": "48rem",
          "4xl": "56rem",
          "5xl": "64rem",
          "6xl": "72rem",
          "7xl": "80rem"
        },
        container: {},
        content: {
          none: "none"
        },
        contrast: {
          0: "0",
          50: ".5",
          75: ".75",
          100: "1",
          125: "1.25",
          150: "1.5",
          200: "2"
        },
        cursor: {
          auto: "auto",
          "default": "default",
          pointer: "pointer",
          wait: "wait",
          text: "text",
          move: "move",
          help: "help",
          "not-allowed": "not-allowed",
          none: "none",
          "context-menu": "context-menu",
          progress: "progress",
          cell: "cell",
          crosshair: "crosshair",
          "vertical-text": "vertical-text",
          alias: "alias",
          copy: "copy",
          "no-drop": "no-drop",
          grab: "grab",
          grabbing: "grabbing",
          "all-scroll": "all-scroll",
          "col-resize": "col-resize",
          "row-resize": "row-resize",
          "n-resize": "n-resize",
          "e-resize": "e-resize",
          "s-resize": "s-resize",
          "w-resize": "w-resize",
          "ne-resize": "ne-resize",
          "nw-resize": "nw-resize",
          "se-resize": "se-resize",
          "sw-resize": "sw-resize",
          "ew-resize": "ew-resize",
          "ns-resize": "ns-resize",
          "nesw-resize": "nesw-resize",
          "nwse-resize": "nwse-resize",
          "zoom-in": "zoom-in",
          "zoom-out": "zoom-out"
        },
        divideColor: function divideColor(_ref33) {
          var i = _ref33.theme;
          return i("borderColor");
        },
        divideOpacity: function divideOpacity(_ref34) {
          var i = _ref34.theme;
          return i("borderOpacity");
        },
        divideWidth: function divideWidth(_ref35) {
          var i = _ref35.theme;
          return i("borderWidth");
        },
        dropShadow: {
          sm: "0 1px 1px rgb(0 0 0 / 0.05)",
          DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
          md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
          lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
          xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
          "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
          none: "0 0 #0000"
        },
        fill: function fill(_ref36) {
          var i = _ref36.theme;
          return _objectSpread({
            none: "none"
          }, i("colors"));
        },
        flex: {
          1: "1 1 0%",
          auto: "1 1 auto",
          initial: "0 1 auto",
          none: "none"
        },
        flexBasis: function flexBasis(_ref37) {
          var i = _ref37.theme;
          return _objectSpread(_objectSpread({
            auto: "auto"
          }, i("spacing")), {}, {
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%"
          });
        },
        flexGrow: {
          0: "0",
          DEFAULT: "1"
        },
        flexShrink: {
          0: "0",
          DEFAULT: "1"
        },
        fontFamily: {
          sans: ["ui-sans-serif", "system-ui", "sans-serif", '"Apple Color Emoji"', '"Segoe UI Emoji"', '"Segoe UI Symbol"', '"Noto Color Emoji"'],
          serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"],
          mono: ["ui-monospace", "SFMono-Regular", "Menlo", "Monaco", "Consolas", '"Liberation Mono"', '"Courier New"', "monospace"]
        },
        fontSize: {
          xs: ["0.75rem", {
            lineHeight: "1rem"
          }],
          sm: ["0.875rem", {
            lineHeight: "1.25rem"
          }],
          base: ["1rem", {
            lineHeight: "1.5rem"
          }],
          lg: ["1.125rem", {
            lineHeight: "1.75rem"
          }],
          xl: ["1.25rem", {
            lineHeight: "1.75rem"
          }],
          "2xl": ["1.5rem", {
            lineHeight: "2rem"
          }],
          "3xl": ["1.875rem", {
            lineHeight: "2.25rem"
          }],
          "4xl": ["2.25rem", {
            lineHeight: "2.5rem"
          }],
          "5xl": ["3rem", {
            lineHeight: "1"
          }],
          "6xl": ["3.75rem", {
            lineHeight: "1"
          }],
          "7xl": ["4.5rem", {
            lineHeight: "1"
          }],
          "8xl": ["6rem", {
            lineHeight: "1"
          }],
          "9xl": ["8rem", {
            lineHeight: "1"
          }]
        },
        fontWeight: {
          thin: "100",
          extralight: "200",
          light: "300",
          normal: "400",
          medium: "500",
          semibold: "600",
          bold: "700",
          extrabold: "800",
          black: "900"
        },
        gap: function gap(_ref38) {
          var i = _ref38.theme;
          return i("spacing");
        },
        gradientColorStops: function gradientColorStops(_ref39) {
          var i = _ref39.theme;
          return i("colors");
        },
        gradientColorStopPositions: {
          "0%": "0%",
          "5%": "5%",
          "10%": "10%",
          "15%": "15%",
          "20%": "20%",
          "25%": "25%",
          "30%": "30%",
          "35%": "35%",
          "40%": "40%",
          "45%": "45%",
          "50%": "50%",
          "55%": "55%",
          "60%": "60%",
          "65%": "65%",
          "70%": "70%",
          "75%": "75%",
          "80%": "80%",
          "85%": "85%",
          "90%": "90%",
          "95%": "95%",
          "100%": "100%"
        },
        grayscale: {
          0: "0",
          DEFAULT: "100%"
        },
        gridAutoColumns: {
          auto: "auto",
          min: "min-content",
          max: "max-content",
          fr: "minmax(0, 1fr)"
        },
        gridAutoRows: {
          auto: "auto",
          min: "min-content",
          max: "max-content",
          fr: "minmax(0, 1fr)"
        },
        gridColumn: {
          auto: "auto",
          "span-1": "span 1 / span 1",
          "span-2": "span 2 / span 2",
          "span-3": "span 3 / span 3",
          "span-4": "span 4 / span 4",
          "span-5": "span 5 / span 5",
          "span-6": "span 6 / span 6",
          "span-7": "span 7 / span 7",
          "span-8": "span 8 / span 8",
          "span-9": "span 9 / span 9",
          "span-10": "span 10 / span 10",
          "span-11": "span 11 / span 11",
          "span-12": "span 12 / span 12",
          "span-full": "1 / -1"
        },
        gridColumnEnd: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12",
          13: "13"
        },
        gridColumnStart: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12",
          13: "13"
        },
        gridRow: {
          auto: "auto",
          "span-1": "span 1 / span 1",
          "span-2": "span 2 / span 2",
          "span-3": "span 3 / span 3",
          "span-4": "span 4 / span 4",
          "span-5": "span 5 / span 5",
          "span-6": "span 6 / span 6",
          "span-7": "span 7 / span 7",
          "span-8": "span 8 / span 8",
          "span-9": "span 9 / span 9",
          "span-10": "span 10 / span 10",
          "span-11": "span 11 / span 11",
          "span-12": "span 12 / span 12",
          "span-full": "1 / -1"
        },
        gridRowEnd: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12",
          13: "13"
        },
        gridRowStart: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12",
          13: "13"
        },
        gridTemplateColumns: {
          none: "none",
          subgrid: "subgrid",
          1: "repeat(1, minmax(0, 1fr))",
          2: "repeat(2, minmax(0, 1fr))",
          3: "repeat(3, minmax(0, 1fr))",
          4: "repeat(4, minmax(0, 1fr))",
          5: "repeat(5, minmax(0, 1fr))",
          6: "repeat(6, minmax(0, 1fr))",
          7: "repeat(7, minmax(0, 1fr))",
          8: "repeat(8, minmax(0, 1fr))",
          9: "repeat(9, minmax(0, 1fr))",
          10: "repeat(10, minmax(0, 1fr))",
          11: "repeat(11, minmax(0, 1fr))",
          12: "repeat(12, minmax(0, 1fr))"
        },
        gridTemplateRows: {
          none: "none",
          subgrid: "subgrid",
          1: "repeat(1, minmax(0, 1fr))",
          2: "repeat(2, minmax(0, 1fr))",
          3: "repeat(3, minmax(0, 1fr))",
          4: "repeat(4, minmax(0, 1fr))",
          5: "repeat(5, minmax(0, 1fr))",
          6: "repeat(6, minmax(0, 1fr))",
          7: "repeat(7, minmax(0, 1fr))",
          8: "repeat(8, minmax(0, 1fr))",
          9: "repeat(9, minmax(0, 1fr))",
          10: "repeat(10, minmax(0, 1fr))",
          11: "repeat(11, minmax(0, 1fr))",
          12: "repeat(12, minmax(0, 1fr))"
        },
        height: function height(_ref40) {
          var i = _ref40.theme;
          return _objectSpread(_objectSpread({
            auto: "auto"
          }, i("spacing")), {}, {
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          });
        },
        hueRotate: {
          0: "0deg",
          15: "15deg",
          30: "30deg",
          60: "60deg",
          90: "90deg",
          180: "180deg"
        },
        inset: function inset(_ref41) {
          var i = _ref41.theme;
          return _objectSpread(_objectSpread({
            auto: "auto"
          }, i("spacing")), {}, {
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            full: "100%"
          });
        },
        invert: {
          0: "0",
          DEFAULT: "100%"
        },
        keyframes: {
          spin: {
            to: {
              transform: "rotate(360deg)"
            }
          },
          ping: {
            "75%, 100%": {
              transform: "scale(2)",
              opacity: "0"
            }
          },
          pulse: {
            "50%": {
              opacity: ".5"
            }
          },
          bounce: {
            "0%, 100%": {
              transform: "translateY(-25%)",
              animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
            },
            "50%": {
              transform: "none",
              animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
            }
          }
        },
        letterSpacing: {
          tighter: "-0.05em",
          tight: "-0.025em",
          normal: "0em",
          wide: "0.025em",
          wider: "0.05em",
          widest: "0.1em"
        },
        lineHeight: {
          none: "1",
          tight: "1.25",
          snug: "1.375",
          normal: "1.5",
          relaxed: "1.625",
          loose: "2",
          3: ".75rem",
          4: "1rem",
          5: "1.25rem",
          6: "1.5rem",
          7: "1.75rem",
          8: "2rem",
          9: "2.25rem",
          10: "2.5rem"
        },
        listStyleType: {
          none: "none",
          disc: "disc",
          decimal: "decimal"
        },
        listStyleImage: {
          none: "none"
        },
        margin: function margin(_ref42) {
          var i = _ref42.theme;
          return _objectSpread({
            auto: "auto"
          }, i("spacing"));
        },
        lineClamp: {
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6"
        },
        maxHeight: function maxHeight(_ref43) {
          var i = _ref43.theme;
          return _objectSpread(_objectSpread({}, i("spacing")), {}, {
            none: "none",
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          });
        },
        maxWidth: function maxWidth(_ref44) {
          var i = _ref44.theme,
            e = _ref44.breakpoints;
          return _objectSpread(_objectSpread({}, i("spacing")), {}, {
            none: "none",
            xs: "20rem",
            sm: "24rem",
            md: "28rem",
            lg: "32rem",
            xl: "36rem",
            "2xl": "42rem",
            "3xl": "48rem",
            "4xl": "56rem",
            "5xl": "64rem",
            "6xl": "72rem",
            "7xl": "80rem",
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            prose: "65ch"
          }, e(i("screens")));
        },
        minHeight: function minHeight(_ref45) {
          var i = _ref45.theme;
          return _objectSpread(_objectSpread({}, i("spacing")), {}, {
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          });
        },
        minWidth: function minWidth(_ref46) {
          var i = _ref46.theme;
          return _objectSpread(_objectSpread({}, i("spacing")), {}, {
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          });
        },
        objectPosition: {
          bottom: "bottom",
          center: "center",
          left: "left",
          "left-bottom": "left bottom",
          "left-top": "left top",
          right: "right",
          "right-bottom": "right bottom",
          "right-top": "right top",
          top: "top"
        },
        opacity: {
          0: "0",
          5: "0.05",
          10: "0.1",
          15: "0.15",
          20: "0.2",
          25: "0.25",
          30: "0.3",
          35: "0.35",
          40: "0.4",
          45: "0.45",
          50: "0.5",
          55: "0.55",
          60: "0.6",
          65: "0.65",
          70: "0.7",
          75: "0.75",
          80: "0.8",
          85: "0.85",
          90: "0.9",
          95: "0.95",
          100: "1"
        },
        order: {
          first: "-9999",
          last: "9999",
          none: "0",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12"
        },
        outlineColor: function outlineColor(_ref47) {
          var i = _ref47.theme;
          return i("colors");
        },
        outlineOffset: {
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        outlineWidth: {
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        padding: function padding(_ref48) {
          var i = _ref48.theme;
          return i("spacing");
        },
        placeholderColor: function placeholderColor(_ref49) {
          var i = _ref49.theme;
          return i("colors");
        },
        placeholderOpacity: function placeholderOpacity(_ref50) {
          var i = _ref50.theme;
          return i("opacity");
        },
        ringColor: function ringColor(_ref51) {
          var i = _ref51.theme;
          return _objectSpread({
            DEFAULT: i("colors.blue.500", "#3b82f6")
          }, i("colors"));
        },
        ringOffsetColor: function ringOffsetColor(_ref52) {
          var i = _ref52.theme;
          return i("colors");
        },
        ringOffsetWidth: {
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        ringOpacity: function ringOpacity(_ref53) {
          var i = _ref53.theme;
          return _objectSpread({
            DEFAULT: "0.5"
          }, i("opacity"));
        },
        ringWidth: {
          DEFAULT: "3px",
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        rotate: {
          0: "0deg",
          1: "1deg",
          2: "2deg",
          3: "3deg",
          6: "6deg",
          12: "12deg",
          45: "45deg",
          90: "90deg",
          180: "180deg"
        },
        saturate: {
          0: "0",
          50: ".5",
          100: "1",
          150: "1.5",
          200: "2"
        },
        scale: {
          0: "0",
          50: ".5",
          75: ".75",
          90: ".9",
          95: ".95",
          100: "1",
          105: "1.05",
          110: "1.1",
          125: "1.25",
          150: "1.5"
        },
        screens: {
          sm: "640px",
          md: "768px",
          lg: "1024px",
          xl: "1280px",
          "2xl": "1536px"
        },
        scrollMargin: function scrollMargin(_ref54) {
          var i = _ref54.theme;
          return _objectSpread({}, i("spacing"));
        },
        scrollPadding: function scrollPadding(_ref55) {
          var i = _ref55.theme;
          return i("spacing");
        },
        sepia: {
          0: "0",
          DEFAULT: "100%"
        },
        skew: {
          0: "0deg",
          1: "1deg",
          2: "2deg",
          3: "3deg",
          6: "6deg",
          12: "12deg"
        },
        space: function space(_ref56) {
          var i = _ref56.theme;
          return _objectSpread({}, i("spacing"));
        },
        spacing: {
          px: "1px",
          0: "0px",
          .5: "0.125rem",
          1: "0.25rem",
          1.5: "0.375rem",
          2: "0.5rem",
          2.5: "0.625rem",
          3: "0.75rem",
          3.5: "0.875rem",
          4: "1rem",
          5: "1.25rem",
          6: "1.5rem",
          7: "1.75rem",
          8: "2rem",
          9: "2.25rem",
          10: "2.5rem",
          11: "2.75rem",
          12: "3rem",
          14: "3.5rem",
          16: "4rem",
          20: "5rem",
          24: "6rem",
          28: "7rem",
          32: "8rem",
          36: "9rem",
          40: "10rem",
          44: "11rem",
          48: "12rem",
          52: "13rem",
          56: "14rem",
          60: "15rem",
          64: "16rem",
          72: "18rem",
          80: "20rem",
          96: "24rem"
        },
        stroke: function stroke(_ref57) {
          var i = _ref57.theme;
          return _objectSpread({
            none: "none"
          }, i("colors"));
        },
        strokeWidth: {
          0: "0",
          1: "1",
          2: "2"
        },
        supports: {},
        data: {},
        textColor: function textColor(_ref58) {
          var i = _ref58.theme;
          return i("colors");
        },
        textDecorationColor: function textDecorationColor(_ref59) {
          var i = _ref59.theme;
          return i("colors");
        },
        textDecorationThickness: {
          auto: "auto",
          "from-font": "from-font",
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        textIndent: function textIndent(_ref60) {
          var i = _ref60.theme;
          return _objectSpread({}, i("spacing"));
        },
        textOpacity: function textOpacity(_ref61) {
          var i = _ref61.theme;
          return i("opacity");
        },
        textUnderlineOffset: {
          auto: "auto",
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        transformOrigin: {
          center: "center",
          top: "top",
          "top-right": "top right",
          right: "right",
          "bottom-right": "bottom right",
          bottom: "bottom",
          "bottom-left": "bottom left",
          left: "left",
          "top-left": "top left"
        },
        transitionDelay: {
          0: "0s",
          75: "75ms",
          100: "100ms",
          150: "150ms",
          200: "200ms",
          300: "300ms",
          500: "500ms",
          700: "700ms",
          1e3: "1000ms"
        },
        transitionDuration: {
          DEFAULT: "150ms",
          0: "0s",
          75: "75ms",
          100: "100ms",
          150: "150ms",
          200: "200ms",
          300: "300ms",
          500: "500ms",
          700: "700ms",
          1e3: "1000ms"
        },
        transitionProperty: {
          none: "none",
          all: "all",
          DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
          colors: "color, background-color, border-color, text-decoration-color, fill, stroke",
          opacity: "opacity",
          shadow: "box-shadow",
          transform: "transform"
        },
        transitionTimingFunction: {
          DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
          linear: "linear",
          "in": "cubic-bezier(0.4, 0, 1, 1)",
          out: "cubic-bezier(0, 0, 0.2, 1)",
          "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
        },
        translate: function translate(_ref62) {
          var i = _ref62.theme;
          return _objectSpread(_objectSpread({}, i("spacing")), {}, {
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            full: "100%"
          });
        },
        size: function size(_ref63) {
          var i = _ref63.theme;
          return _objectSpread(_objectSpread({
            auto: "auto"
          }, i("spacing")), {}, {
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          });
        },
        width: function width(_ref64) {
          var i = _ref64.theme;
          return _objectSpread(_objectSpread({
            auto: "auto"
          }, i("spacing")), {}, {
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            screen: "100vw",
            svw: "100svw",
            lvw: "100lvw",
            dvw: "100dvw",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          });
        },
        willChange: {
          auto: "auto",
          scroll: "scroll-position",
          contents: "contents",
          transform: "transform"
        },
        zIndex: {
          auto: "auto",
          0: "0",
          10: "10",
          20: "20",
          30: "30",
          40: "40",
          50: "50"
        }
      },
      plugins: []
    };
  });
  function vi(i) {
    var _i$presets;
    var e = ((_i$presets = i === null || i === void 0 ? void 0 : i.presets) !== null && _i$presets !== void 0 ? _i$presets : [Ju["default"]]).slice().reverse().flatMap(function (n) {
        return vi(n instanceof Function ? n() : n);
      }),
      t = {
        respectDefaultRingColorOpacity: {
          theme: {
            ringColor: function ringColor(_ref65) {
              var n = _ref65.theme;
              return _objectSpread({
                DEFAULT: "#3b82f67f"
              }, n("colors"));
            }
          }
        },
        disableColorOpacityUtilitiesByDefault: {
          corePlugins: {
            backgroundOpacity: !1,
            borderOpacity: !1,
            divideOpacity: !1,
            placeholderOpacity: !1,
            ringOpacity: !1,
            textOpacity: !1
          }
        }
      },
      r = Object.keys(t).filter(function (n) {
        return K(i, n);
      }).map(function (n) {
        return t[n];
      });
    return [i].concat(_toConsumableArray(r), _toConsumableArray(e));
  }
  var Ju,
    Xu = C(function () {
      l();
      Ju = X(bi());
      ze();
    });
  var Ku = {};
  Ae(Ku, {
    "default": function _default() {
      return hr;
    }
  });
  function hr() {
    for (var _len4 = arguments.length, i = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      i[_key4] = arguments[_key4];
    }
    var _vi = vi(i[0]),
      _vi2 = _toArray(_vi),
      e = _vi2.slice(1);
    return ds([].concat(i, _toConsumableArray(e)));
  }
  var hs = C(function () {
    l();
    Yu();
    Xu();
  });
  var Zu = {};
  Ae(Zu, {
    "default": function _default() {
      return Z;
    }
  });
  var Z,
    yt = C(function () {
      l();
      Z = {
        resolve: function resolve(i) {
          return i;
        },
        extname: function extname(i) {
          return "." + i.split(".").pop();
        }
      };
    });
  function xi(i) {
    return _typeof(i) == "object" && i !== null;
  }
  function r0(i) {
    return Object.keys(i).length === 0;
  }
  function ef(i) {
    return typeof i == "string" || i instanceof String;
  }
  function ms(i) {
    return xi(i) && i.config === void 0 && !r0(i) ? null : xi(i) && i.config !== void 0 && ef(i.config) ? Z.resolve(i.config) : xi(i) && i.config !== void 0 && xi(i.config) ? null : ef(i) ? Z.resolve(i) : i0();
  }
  function i0() {
    var _iterator23 = _createForOfIteratorHelper(t0),
      _step23;
    try {
      for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
        var i = _step23.value;
        try {
          var e = Z.resolve(i);
          return te.accessSync(e), e;
        } catch (e) {}
      }
    } catch (err) {
      _iterator23.e(err);
    } finally {
      _iterator23.f();
    }
    return null;
  }
  var t0,
    tf = C(function () {
      l();
      je();
      yt();
      t0 = ["./tailwind.config.js", "./tailwind.config.cjs", "./tailwind.config.mjs", "./tailwind.config.ts"];
    });
  var rf = {};
  Ae(rf, {
    "default": function _default() {
      return gs;
    }
  });
  var gs,
    ys = C(function () {
      l();
      gs = {
        parse: function parse(i) {
          return {
            href: i
          };
        }
      };
    });
  var ws = v(function () {
    l();
  });
  var ki = v(function (VE, af) {
    l();
    "use strict";
    var nf = (ci(), yu),
      sf = ws(),
      Ot = /*#__PURE__*/function (_Error) {
        function Ot(e, t, r, n, a, s) {
          var _this;
          _classCallCheck(this, Ot);
          _this = _callSuper(this, Ot, [e]);
          _this.name = "CssSyntaxError", _this.reason = e, a && (_this.file = a), n && (_this.source = n), s && (_this.plugin = s), typeof t != "undefined" && typeof r != "undefined" && (typeof t == "number" ? (_this.line = t, _this.column = r) : (_this.line = t.line, _this.column = t.column, _this.endLine = r.line, _this.endColumn = r.column)), _this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(_this, Ot);
          return _this;
        }
        _inherits(Ot, _Error);
        return _createClass(Ot, [{
          key: "setMessage",
          value: function setMessage() {
            this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line != "undefined" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
          }
        }, {
          key: "showSourceCode",
          value: function showSourceCode(e) {
            var _this2 = this;
            if (!this.source) return "";
            var t = this.source;
            e == null && (e = nf.isColorSupported), sf && e && (t = sf(t));
            var r = t.split(/\r?\n/),
              n = Math.max(this.line - 3, 0),
              a = Math.min(this.line + 2, r.length),
              s = String(a).length,
              o,
              u;
            if (e) {
              var _nf$createColors = nf.createColors(!0),
                c = _nf$createColors.bold,
                f = _nf$createColors.red,
                d = _nf$createColors.gray;
              o = function o(p) {
                return c(f(p));
              }, u = function u(p) {
                return d(p);
              };
            } else o = u = function u(c) {
              return c;
            };
            return r.slice(n, a).map(function (c, f) {
              var d = n + 1 + f,
                p = " " + (" " + d).slice(-s) + " | ";
              if (d === _this2.line) {
                var m = u(p.replace(/\d/g, " ")) + c.slice(0, _this2.column - 1).replace(/[^\t]/g, " ");
                return o(">") + u(p) + c + "\n " + m + o("^");
              }
              return " " + u(p) + c;
            }).join("\n");
          }
        }, {
          key: "toString",
          value: function toString() {
            var e = this.showSourceCode();
            return e && (e = "\n\n" + e + "\n"), this.name + ": " + this.message + e;
          }
        }]);
      }( /*#__PURE__*/_wrapNativeSuper(Error));
    af.exports = Ot;
    Ot["default"] = Ot;
  });
  var Si = v(function (UE, bs) {
    l();
    "use strict";
    bs.exports.isClean = Symbol("isClean");
    bs.exports.my = Symbol("my");
  });
  var vs = v(function (WE, lf) {
    l();
    "use strict";
    var of = {
      colon: ": ",
      indent: "    ",
      beforeDecl: "\n",
      beforeRule: "\n",
      beforeOpen: " ",
      beforeClose: "\n",
      beforeComment: "\n",
      after: "\n",
      emptyBody: "",
      commentLeft: " ",
      commentRight: " ",
      semicolon: !1
    };
    function n0(i) {
      return i[0].toUpperCase() + i.slice(1);
    }
    var Ci = /*#__PURE__*/function () {
      function Ci(e) {
        _classCallCheck(this, Ci);
        this.builder = e;
      }
      return _createClass(Ci, [{
        key: "stringify",
        value: function stringify(e, t) {
          if (!this[e.type]) throw new Error("Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier.");
          this[e.type](e, t);
        }
      }, {
        key: "document",
        value: function document(e) {
          this.body(e);
        }
      }, {
        key: "root",
        value: function root(e) {
          this.body(e), e.raws.after && this.builder(e.raws.after);
        }
      }, {
        key: "comment",
        value: function comment(e) {
          var t = this.raw(e, "left", "commentLeft"),
            r = this.raw(e, "right", "commentRight");
          this.builder("/*" + t + e.text + r + "*/", e);
        }
      }, {
        key: "decl",
        value: function decl(e, t) {
          var r = this.raw(e, "between", "colon"),
            n = e.prop + r + this.rawValue(e, "value");
          e.important && (n += e.raws.important || " !important"), t && (n += ";"), this.builder(n, e);
        }
      }, {
        key: "rule",
        value: function rule(e) {
          this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
        }
      }, {
        key: "atrule",
        value: function atrule(e, t) {
          var r = "@" + e.name,
            n = e.params ? this.rawValue(e, "params") : "";
          if (typeof e.raws.afterName != "undefined" ? r += e.raws.afterName : n && (r += " "), e.nodes) this.block(e, r + n);else {
            var a = (e.raws.between || "") + (t ? ";" : "");
            this.builder(r + n + a, e);
          }
        }
      }, {
        key: "body",
        value: function body(e) {
          var t = e.nodes.length - 1;
          for (; t > 0 && e.nodes[t].type === "comment";) t -= 1;
          var r = this.raw(e, "semicolon");
          for (var n = 0; n < e.nodes.length; n++) {
            var a = e.nodes[n],
              s = this.raw(a, "before");
            s && this.builder(s), this.stringify(a, t !== n || r);
          }
        }
      }, {
        key: "block",
        value: function block(e, t) {
          var r = this.raw(e, "between", "beforeOpen");
          this.builder(t + r + "{", e, "start");
          var n;
          e.nodes && e.nodes.length ? (this.body(e), n = this.raw(e, "after")) : n = this.raw(e, "after", "emptyBody"), n && this.builder(n), this.builder("}", e, "end");
        }
      }, {
        key: "raw",
        value: function raw(e, t, r) {
          var n;
          if (r || (r = t), t && (n = e.raws[t], typeof n != "undefined")) return n;
          var a = e.parent;
          if (r === "before" && (!a || a.type === "root" && a.first === e || a && a.type === "document")) return "";
          if (!a) return of[r];
          var s = e.root();
          if (s.rawCache || (s.rawCache = {}), typeof s.rawCache[r] != "undefined") return s.rawCache[r];
          if (r === "before" || r === "after") return this.beforeAfter(e, r);
          {
            var o = "raw" + n0(r);
            this[o] ? n = this[o](s, e) : s.walk(function (u) {
              if (n = u.raws[t], typeof n != "undefined") return !1;
            });
          }
          return typeof n == "undefined" && (n = of[r]), s.rawCache[r] = n, n;
        }
      }, {
        key: "rawSemicolon",
        value: function rawSemicolon(e) {
          var t;
          return e.walk(function (r) {
            if (r.nodes && r.nodes.length && r.last.type === "decl" && (t = r.raws.semicolon, typeof t != "undefined")) return !1;
          }), t;
        }
      }, {
        key: "rawEmptyBody",
        value: function rawEmptyBody(e) {
          var t;
          return e.walk(function (r) {
            if (r.nodes && r.nodes.length === 0 && (t = r.raws.after, typeof t != "undefined")) return !1;
          }), t;
        }
      }, {
        key: "rawIndent",
        value: function rawIndent(e) {
          if (e.raws.indent) return e.raws.indent;
          var t;
          return e.walk(function (r) {
            var n = r.parent;
            if (n && n !== e && n.parent && n.parent === e && typeof r.raws.before != "undefined") {
              var a = r.raws.before.split("\n");
              return t = a[a.length - 1], t = t.replace(/\S/g, ""), !1;
            }
          }), t;
        }
      }, {
        key: "rawBeforeComment",
        value: function rawBeforeComment(e, t) {
          var r;
          return e.walkComments(function (n) {
            if (typeof n.raws.before != "undefined") return r = n.raws.before, r.includes("\n") && (r = r.replace(/[^\n]+$/, "")), !1;
          }), typeof r == "undefined" ? r = this.raw(t, null, "beforeDecl") : r && (r = r.replace(/\S/g, "")), r;
        }
      }, {
        key: "rawBeforeDecl",
        value: function rawBeforeDecl(e, t) {
          var r;
          return e.walkDecls(function (n) {
            if (typeof n.raws.before != "undefined") return r = n.raws.before, r.includes("\n") && (r = r.replace(/[^\n]+$/, "")), !1;
          }), typeof r == "undefined" ? r = this.raw(t, null, "beforeRule") : r && (r = r.replace(/\S/g, "")), r;
        }
      }, {
        key: "rawBeforeRule",
        value: function rawBeforeRule(e) {
          var t;
          return e.walk(function (r) {
            if (r.nodes && (r.parent !== e || e.first !== r) && typeof r.raws.before != "undefined") return t = r.raws.before, t.includes("\n") && (t = t.replace(/[^\n]+$/, "")), !1;
          }), t && (t = t.replace(/\S/g, "")), t;
        }
      }, {
        key: "rawBeforeClose",
        value: function rawBeforeClose(e) {
          var t;
          return e.walk(function (r) {
            if (r.nodes && r.nodes.length > 0 && typeof r.raws.after != "undefined") return t = r.raws.after, t.includes("\n") && (t = t.replace(/[^\n]+$/, "")), !1;
          }), t && (t = t.replace(/\S/g, "")), t;
        }
      }, {
        key: "rawBeforeOpen",
        value: function rawBeforeOpen(e) {
          var t;
          return e.walk(function (r) {
            if (r.type !== "decl" && (t = r.raws.between, typeof t != "undefined")) return !1;
          }), t;
        }
      }, {
        key: "rawColon",
        value: function rawColon(e) {
          var t;
          return e.walkDecls(function (r) {
            if (typeof r.raws.between != "undefined") return t = r.raws.between.replace(/[^\s:]/g, ""), !1;
          }), t;
        }
      }, {
        key: "beforeAfter",
        value: function beforeAfter(e, t) {
          var r;
          e.type === "decl" ? r = this.raw(e, null, "beforeDecl") : e.type === "comment" ? r = this.raw(e, null, "beforeComment") : t === "before" ? r = this.raw(e, null, "beforeRule") : r = this.raw(e, null, "beforeClose");
          var n = e.parent,
            a = 0;
          for (; n && n.type !== "root";) a += 1, n = n.parent;
          if (r.includes("\n")) {
            var s = this.raw(e, null, "indent");
            if (s.length) for (var o = 0; o < a; o++) r += s;
          }
          return r;
        }
      }, {
        key: "rawValue",
        value: function rawValue(e, t) {
          var r = e[t],
            n = e.raws[t];
          return n && n.value === r ? n.raw : r;
        }
      }]);
    }();
    lf.exports = Ci;
    Ci["default"] = Ci;
  });
  var mr = v(function (GE, uf) {
    l();
    "use strict";
    var s0 = vs();
    function xs(i, e) {
      new s0(e).stringify(i);
    }
    uf.exports = xs;
    xs["default"] = xs;
  });
  var gr = v(function (HE, ff) {
    l();
    "use strict";
    var _Si = Si(),
      Ai = _Si.isClean,
      a0 = _Si.my,
      o0 = ki(),
      l0 = vs(),
      u0 = mr();
    function ks(i, e) {
      var t = new i.constructor();
      for (var r in i) {
        if (!Object.prototype.hasOwnProperty.call(i, r) || r === "proxyCache") continue;
        var n = i[r],
          a = _typeof(n);
        r === "parent" && a === "object" ? e && (t[r] = e) : r === "source" ? t[r] = n : Array.isArray(n) ? t[r] = n.map(function (s) {
          return ks(s, t);
        }) : (a === "object" && n !== null && (n = ks(n)), t[r] = n);
      }
      return t;
    }
    var _i = /*#__PURE__*/function () {
      function _i() {
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        _classCallCheck(this, _i);
        this.raws = {}, this[Ai] = !1, this[a0] = !0;
        for (var t in e) if (t === "nodes") {
          this.nodes = [];
          var _iterator24 = _createForOfIteratorHelper(e[t]),
            _step24;
          try {
            for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
              var r = _step24.value;
              typeof r.clone == "function" ? this.append(r.clone()) : this.append(r);
            }
          } catch (err) {
            _iterator24.e(err);
          } finally {
            _iterator24.f();
          }
        } else this[t] = e[t];
      }
      return _createClass(_i, [{
        key: "error",
        value: function error(e) {
          var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          if (this.source) {
            var _this$rangeBy = this.rangeBy(t),
              r = _this$rangeBy.start,
              n = _this$rangeBy.end;
            return this.source.input.error(e, {
              line: r.line,
              column: r.column
            }, {
              line: n.line,
              column: n.column
            }, t);
          }
          return new o0(e);
        }
      }, {
        key: "warn",
        value: function warn(e, t, r) {
          var n = {
            node: this
          };
          for (var a in r) n[a] = r[a];
          return e.warn(t, n);
        }
      }, {
        key: "remove",
        value: function remove() {
          return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
        }
      }, {
        key: "toString",
        value: function toString() {
          var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : u0;
          e.stringify && (e = e.stringify);
          var t = "";
          return e(this, function (r) {
            t += r;
          }), t;
        }
      }, {
        key: "assign",
        value: function assign() {
          var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          for (var t in e) this[t] = e[t];
          return this;
        }
      }, {
        key: "clone",
        value: function clone() {
          var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var t = ks(this);
          for (var r in e) t[r] = e[r];
          return t;
        }
      }, {
        key: "cloneBefore",
        value: function cloneBefore() {
          var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var t = this.clone(e);
          return this.parent.insertBefore(this, t), t;
        }
      }, {
        key: "cloneAfter",
        value: function cloneAfter() {
          var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var t = this.clone(e);
          return this.parent.insertAfter(this, t), t;
        }
      }, {
        key: "replaceWith",
        value: function replaceWith() {
          if (this.parent) {
            var t = this,
              r = !1;
            for (var _len5 = arguments.length, e = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
              e[_key5] = arguments[_key5];
            }
            for (var _i7 = 0, _e11 = e; _i7 < _e11.length; _i7++) {
              var n = _e11[_i7];
              n === this ? r = !0 : r ? (this.parent.insertAfter(t, n), t = n) : this.parent.insertBefore(t, n);
            }
            r || this.remove();
          }
          return this;
        }
      }, {
        key: "next",
        value: function next() {
          if (!this.parent) return;
          var e = this.parent.index(this);
          return this.parent.nodes[e + 1];
        }
      }, {
        key: "prev",
        value: function prev() {
          if (!this.parent) return;
          var e = this.parent.index(this);
          return this.parent.nodes[e - 1];
        }
      }, {
        key: "before",
        value: function before(e) {
          return this.parent.insertBefore(this, e), this;
        }
      }, {
        key: "after",
        value: function after(e) {
          return this.parent.insertAfter(this, e), this;
        }
      }, {
        key: "root",
        value: function root() {
          var e = this;
          for (; e.parent && e.parent.type !== "document";) e = e.parent;
          return e;
        }
      }, {
        key: "raw",
        value: function raw(e, t) {
          return new l0().raw(this, e, t);
        }
      }, {
        key: "cleanRaws",
        value: function cleanRaws(e) {
          delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
        }
      }, {
        key: "toJSON",
        value: function toJSON(e, t) {
          var r = {},
            n = t == null;
          t = t || new Map();
          var a = 0;
          for (var s in this) {
            if (!Object.prototype.hasOwnProperty.call(this, s) || s === "parent" || s === "proxyCache") continue;
            var o = this[s];
            if (Array.isArray(o)) r[s] = o.map(function (u) {
              return _typeof(u) == "object" && u.toJSON ? u.toJSON(null, t) : u;
            });else if (_typeof(o) == "object" && o.toJSON) r[s] = o.toJSON(null, t);else if (s === "source") {
              var u = t.get(o.input);
              u == null && (u = a, t.set(o.input, a), a++), r[s] = {
                inputId: u,
                start: o.start,
                end: o.end
              };
            } else r[s] = o;
          }
          return n && (r.inputs = _toConsumableArray(t.keys()).map(function (s) {
            return s.toJSON();
          })), r;
        }
      }, {
        key: "positionInside",
        value: function positionInside(e) {
          var t = this.toString(),
            r = this.source.start.column,
            n = this.source.start.line;
          for (var a = 0; a < e; a++) t[a] === "\n" ? (r = 1, n += 1) : r += 1;
          return {
            line: n,
            column: r
          };
        }
      }, {
        key: "positionBy",
        value: function positionBy(e) {
          var t = this.source.start;
          if (e.index) t = this.positionInside(e.index);else if (e.word) {
            var r = this.toString().indexOf(e.word);
            r !== -1 && (t = this.positionInside(r));
          }
          return t;
        }
      }, {
        key: "rangeBy",
        value: function rangeBy(e) {
          var t = {
              line: this.source.start.line,
              column: this.source.start.column
            },
            r = this.source.end ? {
              line: this.source.end.line,
              column: this.source.end.column + 1
            } : {
              line: t.line,
              column: t.column + 1
            };
          if (e.word) {
            var n = this.toString().indexOf(e.word);
            n !== -1 && (t = this.positionInside(n), r = this.positionInside(n + e.word.length));
          } else e.start ? t = {
            line: e.start.line,
            column: e.start.column
          } : e.index && (t = this.positionInside(e.index)), e.end ? r = {
            line: e.end.line,
            column: e.end.column
          } : e.endIndex ? r = this.positionInside(e.endIndex) : e.index && (r = this.positionInside(e.index + 1));
          return (r.line < t.line || r.line === t.line && r.column <= t.column) && (r = {
            line: t.line,
            column: t.column + 1
          }), {
            start: t,
            end: r
          };
        }
      }, {
        key: "getProxyProcessor",
        value: function getProxyProcessor() {
          return {
            set: function set(e, t, r) {
              return e[t] === r || (e[t] = r, (t === "prop" || t === "value" || t === "name" || t === "params" || t === "important" || t === "text") && e.markDirty()), !0;
            },
            get: function get(e, t) {
              return t === "proxyOf" ? e : t === "root" ? function () {
                return e.root().toProxy();
              } : e[t];
            }
          };
        }
      }, {
        key: "toProxy",
        value: function toProxy() {
          return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
        }
      }, {
        key: "addToError",
        value: function addToError(e) {
          if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
            var t = this.source;
            e.stack = e.stack.replace(/\n\s{4}at /, "$&".concat(t.input.from, ":").concat(t.start.line, ":").concat(t.start.column, "$&"));
          }
          return e;
        }
      }, {
        key: "markDirty",
        value: function markDirty() {
          if (this[Ai]) {
            this[Ai] = !1;
            var e = this;
            for (; e = e.parent;) e[Ai] = !1;
          }
        }
      }, {
        key: "proxyOf",
        get: function get() {
          return this;
        }
      }]);
    }();
    ff.exports = _i;
    _i["default"] = _i;
  });
  var yr = v(function (YE, cf) {
    l();
    "use strict";
    var f0 = gr(),
      Oi = /*#__PURE__*/function (_f2) {
        function Oi(e) {
          var _this3;
          _classCallCheck(this, Oi);
          e && typeof e.value != "undefined" && typeof e.value != "string" && (e = _objectSpread(_objectSpread({}, e), {}, {
            value: String(e.value)
          }));
          _this3 = _callSuper(this, Oi, [e]);
          _this3.type = "decl";
          return _this3;
        }
        _inherits(Oi, _f2);
        return _createClass(Oi, [{
          key: "variable",
          get: function get() {
            return this.prop.startsWith("--") || this.prop[0] === "$";
          }
        }]);
      }(f0);
    cf.exports = Oi;
    Oi["default"] = Oi;
  });
  var Ss = v(function (QE, pf) {
    l();
    pf.exports = function (i, e) {
      return {
        generate: function generate() {
          var t = "";
          return i(e, function (r) {
            t += r;
          }), [t];
        }
      };
    };
  });
  var wr = v(function (JE, df) {
    l();
    "use strict";
    var c0 = gr(),
      Ei = /*#__PURE__*/function (_c2) {
        function Ei(e) {
          var _this4;
          _classCallCheck(this, Ei);
          _this4 = _callSuper(this, Ei, [e]);
          _this4.type = "comment";
          return _this4;
        }
        _inherits(Ei, _c2);
        return _createClass(Ei);
      }(c0);
    df.exports = Ei;
    Ei["default"] = Ei;
  });
  var it = v(function (XE, kf) {
    l();
    "use strict";
    var _Si2 = Si(),
      hf = _Si2.isClean,
      mf = _Si2.my,
      gf = yr(),
      yf = wr(),
      p0 = gr(),
      wf,
      Cs,
      As,
      bf;
    function vf(i) {
      return i.map(function (e) {
        return e.nodes && (e.nodes = vf(e.nodes)), delete e.source, e;
      });
    }
    function xf(i) {
      if (i[hf] = !1, i.proxyOf.nodes) {
        var _iterator25 = _createForOfIteratorHelper(i.proxyOf.nodes),
          _step25;
        try {
          for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
            var e = _step25.value;
            xf(e);
          }
        } catch (err) {
          _iterator25.e(err);
        } finally {
          _iterator25.f();
        }
      }
    }
    var we = /*#__PURE__*/function (_p2) {
      function we() {
        _classCallCheck(this, we);
        return _callSuper(this, we, arguments);
      }
      _inherits(we, _p2);
      return _createClass(we, [{
        key: "push",
        value: function push(e) {
          return e.parent = this, this.proxyOf.nodes.push(e), this;
        }
      }, {
        key: "each",
        value: function each(e) {
          if (!this.proxyOf.nodes) return;
          var t = this.getIterator(),
            r,
            n;
          for (; this.indexes[t] < this.proxyOf.nodes.length && (r = this.indexes[t], n = e(this.proxyOf.nodes[r], r), n !== !1);) this.indexes[t] += 1;
          return delete this.indexes[t], n;
        }
      }, {
        key: "walk",
        value: function walk(e) {
          return this.each(function (t, r) {
            var n;
            try {
              n = e(t, r);
            } catch (a) {
              throw t.addToError(a);
            }
            return n !== !1 && t.walk && (n = t.walk(e)), n;
          });
        }
      }, {
        key: "walkDecls",
        value: function walkDecls(e, t) {
          return t ? e instanceof RegExp ? this.walk(function (r, n) {
            if (r.type === "decl" && e.test(r.prop)) return t(r, n);
          }) : this.walk(function (r, n) {
            if (r.type === "decl" && r.prop === e) return t(r, n);
          }) : (t = e, this.walk(function (r, n) {
            if (r.type === "decl") return t(r, n);
          }));
        }
      }, {
        key: "walkRules",
        value: function walkRules(e, t) {
          return t ? e instanceof RegExp ? this.walk(function (r, n) {
            if (r.type === "rule" && e.test(r.selector)) return t(r, n);
          }) : this.walk(function (r, n) {
            if (r.type === "rule" && r.selector === e) return t(r, n);
          }) : (t = e, this.walk(function (r, n) {
            if (r.type === "rule") return t(r, n);
          }));
        }
      }, {
        key: "walkAtRules",
        value: function walkAtRules(e, t) {
          return t ? e instanceof RegExp ? this.walk(function (r, n) {
            if (r.type === "atrule" && e.test(r.name)) return t(r, n);
          }) : this.walk(function (r, n) {
            if (r.type === "atrule" && r.name === e) return t(r, n);
          }) : (t = e, this.walk(function (r, n) {
            if (r.type === "atrule") return t(r, n);
          }));
        }
      }, {
        key: "walkComments",
        value: function walkComments(e) {
          return this.walk(function (t, r) {
            if (t.type === "comment") return e(t, r);
          });
        }
      }, {
        key: "append",
        value: function append() {
          for (var _len6 = arguments.length, e = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            e[_key6] = arguments[_key6];
          }
          for (var _i8 = 0, _e12 = e; _i8 < _e12.length; _i8++) {
            var t = _e12[_i8];
            var r = this.normalize(t, this.last);
            var _iterator26 = _createForOfIteratorHelper(r),
              _step26;
            try {
              for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
                var n = _step26.value;
                this.proxyOf.nodes.push(n);
              }
            } catch (err) {
              _iterator26.e(err);
            } finally {
              _iterator26.f();
            }
          }
          return this.markDirty(), this;
        }
      }, {
        key: "prepend",
        value: function prepend() {
          for (var _len7 = arguments.length, e = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
            e[_key7] = arguments[_key7];
          }
          e = e.reverse();
          var _iterator27 = _createForOfIteratorHelper(e),
            _step27;
          try {
            for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
              var t = _step27.value;
              var r = this.normalize(t, this.first, "prepend").reverse();
              var _iterator28 = _createForOfIteratorHelper(r),
                _step28;
              try {
                for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
                  var _n4 = _step28.value;
                  this.proxyOf.nodes.unshift(_n4);
                }
              } catch (err) {
                _iterator28.e(err);
              } finally {
                _iterator28.f();
              }
              for (var n in this.indexes) this.indexes[n] = this.indexes[n] + r.length;
            }
          } catch (err) {
            _iterator27.e(err);
          } finally {
            _iterator27.f();
          }
          return this.markDirty(), this;
        }
      }, {
        key: "cleanRaws",
        value: function cleanRaws(e) {
          if (_get(_getPrototypeOf(we.prototype), "cleanRaws", this).call(this, e), this.nodes) {
            var _iterator29 = _createForOfIteratorHelper(this.nodes),
              _step29;
            try {
              for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
                var t = _step29.value;
                t.cleanRaws(e);
              }
            } catch (err) {
              _iterator29.e(err);
            } finally {
              _iterator29.f();
            }
          }
        }
      }, {
        key: "insertBefore",
        value: function insertBefore(e, t) {
          var r = this.index(e),
            n = r === 0 ? "prepend" : !1,
            a = this.normalize(t, this.proxyOf.nodes[r], n).reverse();
          r = this.index(e);
          var _iterator30 = _createForOfIteratorHelper(a),
            _step30;
          try {
            for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {
              var _o2 = _step30.value;
              this.proxyOf.nodes.splice(r, 0, _o2);
            }
          } catch (err) {
            _iterator30.e(err);
          } finally {
            _iterator30.f();
          }
          var s;
          for (var o in this.indexes) s = this.indexes[o], r <= s && (this.indexes[o] = s + a.length);
          return this.markDirty(), this;
        }
      }, {
        key: "insertAfter",
        value: function insertAfter(e, t) {
          var r = this.index(e),
            n = this.normalize(t, this.proxyOf.nodes[r]).reverse();
          r = this.index(e);
          var _iterator31 = _createForOfIteratorHelper(n),
            _step31;
          try {
            for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {
              var _s5 = _step31.value;
              this.proxyOf.nodes.splice(r + 1, 0, _s5);
            }
          } catch (err) {
            _iterator31.e(err);
          } finally {
            _iterator31.f();
          }
          var a;
          for (var s in this.indexes) a = this.indexes[s], r < a && (this.indexes[s] = a + n.length);
          return this.markDirty(), this;
        }
      }, {
        key: "removeChild",
        value: function removeChild(e) {
          e = this.index(e), this.proxyOf.nodes[e].parent = void 0, this.proxyOf.nodes.splice(e, 1);
          var t;
          for (var r in this.indexes) t = this.indexes[r], t >= e && (this.indexes[r] = t - 1);
          return this.markDirty(), this;
        }
      }, {
        key: "removeAll",
        value: function removeAll() {
          var _iterator32 = _createForOfIteratorHelper(this.proxyOf.nodes),
            _step32;
          try {
            for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {
              var e = _step32.value;
              e.parent = void 0;
            }
          } catch (err) {
            _iterator32.e(err);
          } finally {
            _iterator32.f();
          }
          return this.proxyOf.nodes = [], this.markDirty(), this;
        }
      }, {
        key: "replaceValues",
        value: function replaceValues(e, t, r) {
          return r || (r = t, t = {}), this.walkDecls(function (n) {
            t.props && !t.props.includes(n.prop) || t.fast && !n.value.includes(t.fast) || (n.value = n.value.replace(e, r));
          }), this.markDirty(), this;
        }
      }, {
        key: "every",
        value: function every(e) {
          return this.nodes.every(e);
        }
      }, {
        key: "some",
        value: function some(e) {
          return this.nodes.some(e);
        }
      }, {
        key: "index",
        value: function index(e) {
          return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
        }
      }, {
        key: "first",
        get: function get() {
          if (!!this.proxyOf.nodes) return this.proxyOf.nodes[0];
        }
      }, {
        key: "last",
        get: function get() {
          if (!!this.proxyOf.nodes) return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
        }
      }, {
        key: "normalize",
        value: function normalize(e, t) {
          var _this5 = this;
          if (typeof e == "string") e = vf(wf(e).nodes);else if (Array.isArray(e)) {
            e = e.slice(0);
            var _iterator33 = _createForOfIteratorHelper(e),
              _step33;
            try {
              for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {
                var n = _step33.value;
                n.parent && n.parent.removeChild(n, "ignore");
              }
            } catch (err) {
              _iterator33.e(err);
            } finally {
              _iterator33.f();
            }
          } else if (e.type === "root" && this.type !== "document") {
            e = e.nodes.slice(0);
            var _iterator34 = _createForOfIteratorHelper(e),
              _step34;
            try {
              for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {
                var _n5 = _step34.value;
                _n5.parent && _n5.parent.removeChild(_n5, "ignore");
              }
            } catch (err) {
              _iterator34.e(err);
            } finally {
              _iterator34.f();
            }
          } else if (e.type) e = [e];else if (e.prop) {
            if (typeof e.value == "undefined") throw new Error("Value field is missed in node creation");
            typeof e.value != "string" && (e.value = String(e.value)), e = [new gf(e)];
          } else if (e.selector) e = [new Cs(e)];else if (e.name) e = [new As(e)];else if (e.text) e = [new yf(e)];else throw new Error("Unknown node type in node creation");
          return e.map(function (n) {
            return n[mf] || we.rebuild(n), n = n.proxyOf, n.parent && n.parent.removeChild(n), n[hf] && xf(n), typeof n.raws.before == "undefined" && t && typeof t.raws.before != "undefined" && (n.raws.before = t.raws.before.replace(/\S/g, "")), n.parent = _this5.proxyOf, n;
          });
        }
      }, {
        key: "getProxyProcessor",
        value: function getProxyProcessor() {
          return {
            set: function set(e, t, r) {
              return e[t] === r || (e[t] = r, (t === "name" || t === "params" || t === "selector") && e.markDirty()), !0;
            },
            get: function get(e, t) {
              return t === "proxyOf" ? e : e[t] ? t === "each" || typeof t == "string" && t.startsWith("walk") ? function () {
                for (var _len8 = arguments.length, r = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
                  r[_key8] = arguments[_key8];
                }
                return e[t].apply(e, _toConsumableArray(r.map(function (n) {
                  return typeof n == "function" ? function (a, s) {
                    return n(a.toProxy(), s);
                  } : n;
                })));
              } : t === "every" || t === "some" ? function (r) {
                return e[t](function (n) {
                  for (var _len9 = arguments.length, a = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
                    a[_key9 - 1] = arguments[_key9];
                  }
                  return r.apply(void 0, [n.toProxy()].concat(a));
                });
              } : t === "root" ? function () {
                return e.root().toProxy();
              } : t === "nodes" ? e.nodes.map(function (r) {
                return r.toProxy();
              }) : t === "first" || t === "last" ? e[t].toProxy() : e[t] : e[t];
            }
          };
        }
      }, {
        key: "getIterator",
        value: function getIterator() {
          this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
          var e = this.lastEach;
          return this.indexes[e] = 0, e;
        }
      }]);
    }(p0);
    we.registerParse = function (i) {
      wf = i;
    };
    we.registerRule = function (i) {
      Cs = i;
    };
    we.registerAtRule = function (i) {
      As = i;
    };
    we.registerRoot = function (i) {
      bf = i;
    };
    kf.exports = we;
    we["default"] = we;
    we.rebuild = function (i) {
      i.type === "atrule" ? Object.setPrototypeOf(i, As.prototype) : i.type === "rule" ? Object.setPrototypeOf(i, Cs.prototype) : i.type === "decl" ? Object.setPrototypeOf(i, gf.prototype) : i.type === "comment" ? Object.setPrototypeOf(i, yf.prototype) : i.type === "root" && Object.setPrototypeOf(i, bf.prototype), i[mf] = !0, i.nodes && i.nodes.forEach(function (e) {
        we.rebuild(e);
      });
    };
  });
  var Ti = v(function (KE, Af) {
    l();
    "use strict";
    var d0 = it(),
      Sf,
      Cf,
      Et = /*#__PURE__*/function (_d2) {
        function Et(e) {
          var _this6;
          _classCallCheck(this, Et);
          _this6 = _callSuper(this, Et, [_objectSpread({
            type: "document"
          }, e)]);
          _this6.nodes || (_this6.nodes = []);
          return _this6;
        }
        _inherits(Et, _d2);
        return _createClass(Et, [{
          key: "toResult",
          value: function toResult() {
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            return new Sf(new Cf(), this, e).stringify();
          }
        }]);
      }(d0);
    Et.registerLazyResult = function (i) {
      Sf = i;
    };
    Et.registerProcessor = function (i) {
      Cf = i;
    };
    Af.exports = Et;
    Et["default"] = Et;
  });
  var _s = v(function (ZE, Of) {
    l();
    "use strict";
    var _f = {};
    Of.exports = function (e) {
      _f[e] || (_f[e] = !0, typeof console != "undefined" && console.warn && console.warn(e));
    };
  });
  var Os = v(function (eT, Ef) {
    l();
    "use strict";
    var Pi = /*#__PURE__*/function () {
      function Pi(e) {
        var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        _classCallCheck(this, Pi);
        if (this.type = "warning", this.text = e, t.node && t.node.source) {
          var r = t.node.rangeBy(t);
          this.line = r.start.line, this.column = r.start.column, this.endLine = r.end.line, this.endColumn = r.end.column;
        }
        for (var _r9 in t) this[_r9] = t[_r9];
      }
      return _createClass(Pi, [{
        key: "toString",
        value: function toString() {
          return this.node ? this.node.error(this.text, {
            plugin: this.plugin,
            index: this.index,
            word: this.word
          }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
        }
      }]);
    }();
    Ef.exports = Pi;
    Pi["default"] = Pi;
  });
  var Ii = v(function (tT, Tf) {
    l();
    "use strict";
    var h0 = Os(),
      Di = /*#__PURE__*/function () {
        function Di(e, t, r) {
          _classCallCheck(this, Di);
          this.processor = e, this.messages = [], this.root = t, this.opts = r, this.css = void 0, this.map = void 0;
        }
        return _createClass(Di, [{
          key: "toString",
          value: function toString() {
            return this.css;
          }
        }, {
          key: "warn",
          value: function warn(e) {
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            t.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (t.plugin = this.lastPlugin.postcssPlugin);
            var r = new h0(e, t);
            return this.messages.push(r), r;
          }
        }, {
          key: "warnings",
          value: function warnings() {
            return this.messages.filter(function (e) {
              return e.type === "warning";
            });
          }
        }, {
          key: "content",
          get: function get() {
            return this.css;
          }
        }]);
      }();
    Tf.exports = Di;
    Di["default"] = Di;
  });
  var Rf = v(function (rT, qf) {
    l();
    "use strict";
    var Es = "'".charCodeAt(0),
      Pf = '"'.charCodeAt(0),
      qi = "\\".charCodeAt(0),
      Df = "/".charCodeAt(0),
      Ri = "\n".charCodeAt(0),
      br = " ".charCodeAt(0),
      Mi = "\f".charCodeAt(0),
      Bi = "	".charCodeAt(0),
      Fi = "\r".charCodeAt(0),
      m0 = "[".charCodeAt(0),
      g0 = "]".charCodeAt(0),
      y0 = "(".charCodeAt(0),
      w0 = ")".charCodeAt(0),
      b0 = "{".charCodeAt(0),
      v0 = "}".charCodeAt(0),
      x0 = ";".charCodeAt(0),
      k0 = "*".charCodeAt(0),
      S0 = ":".charCodeAt(0),
      C0 = "@".charCodeAt(0),
      Ni = /[\t\n\f\r "#'()/;[\\\]{}]/g,
      Li = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g,
      A0 = /.[\n"'(/\\]/,
      If = /[\da-f]/i;
    qf.exports = function (e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var r = e.css.valueOf(),
        n = t.ignoreErrors,
        a,
        s,
        o,
        u,
        c,
        f,
        d,
        p,
        m,
        b,
        x = r.length,
        y = 0,
        w = [],
        k = [];
      function S() {
        return y;
      }
      function _(R) {
        throw e.error("Unclosed " + R, y);
      }
      function E() {
        return k.length === 0 && y >= x;
      }
      function I(R) {
        if (k.length) return k.pop();
        if (y >= x) return;
        var J = R ? R.ignoreUnclosed : !1;
        switch (a = r.charCodeAt(y), a) {
          case Ri:
          case br:
          case Bi:
          case Fi:
          case Mi:
            {
              s = y;
              do s += 1, a = r.charCodeAt(s); while (a === br || a === Ri || a === Bi || a === Fi || a === Mi);
              b = ["space", r.slice(y, s)], y = s - 1;
              break;
            }
          case m0:
          case g0:
          case b0:
          case v0:
          case S0:
          case x0:
          case w0:
            {
              var ue = String.fromCharCode(a);
              b = [ue, ue, y];
              break;
            }
          case y0:
            {
              if (p = w.length ? w.pop()[1] : "", m = r.charCodeAt(y + 1), p === "url" && m !== Es && m !== Pf && m !== br && m !== Ri && m !== Bi && m !== Mi && m !== Fi) {
                s = y;
                do {
                  if (f = !1, s = r.indexOf(")", s + 1), s === -1) if (n || J) {
                    s = y;
                    break;
                  } else _("bracket");
                  for (d = s; r.charCodeAt(d - 1) === qi;) d -= 1, f = !f;
                } while (f);
                b = ["brackets", r.slice(y, s + 1), y, s], y = s;
              } else s = r.indexOf(")", y + 1), u = r.slice(y, s + 1), s === -1 || A0.test(u) ? b = ["(", "(", y] : (b = ["brackets", u, y, s], y = s);
              break;
            }
          case Es:
          case Pf:
            {
              o = a === Es ? "'" : '"', s = y;
              do {
                if (f = !1, s = r.indexOf(o, s + 1), s === -1) if (n || J) {
                  s = y + 1;
                  break;
                } else _("string");
                for (d = s; r.charCodeAt(d - 1) === qi;) d -= 1, f = !f;
              } while (f);
              b = ["string", r.slice(y, s + 1), y, s], y = s;
              break;
            }
          case C0:
            {
              Ni.lastIndex = y + 1, Ni.test(r), Ni.lastIndex === 0 ? s = r.length - 1 : s = Ni.lastIndex - 2, b = ["at-word", r.slice(y, s + 1), y, s], y = s;
              break;
            }
          case qi:
            {
              for (s = y, c = !0; r.charCodeAt(s + 1) === qi;) s += 1, c = !c;
              if (a = r.charCodeAt(s + 1), c && a !== Df && a !== br && a !== Ri && a !== Bi && a !== Fi && a !== Mi && (s += 1, If.test(r.charAt(s)))) {
                for (; If.test(r.charAt(s + 1));) s += 1;
                r.charCodeAt(s + 1) === br && (s += 1);
              }
              b = ["word", r.slice(y, s + 1), y, s], y = s;
              break;
            }
          default:
            {
              a === Df && r.charCodeAt(y + 1) === k0 ? (s = r.indexOf("*/", y + 2) + 1, s === 0 && (n || J ? s = r.length : _("comment")), b = ["comment", r.slice(y, s + 1), y, s], y = s) : (Li.lastIndex = y + 1, Li.test(r), Li.lastIndex === 0 ? s = r.length - 1 : s = Li.lastIndex - 2, b = ["word", r.slice(y, s + 1), y, s], w.push(b), y = s);
              break;
            }
        }
        return y++, b;
      }
      function q(R) {
        k.push(R);
      }
      return {
        back: q,
        nextToken: I,
        endOfFile: E,
        position: S
      };
    };
  });
  var $i = v(function (iT, Bf) {
    l();
    "use strict";
    var Mf = it(),
      vr = /*#__PURE__*/function (_Mf) {
        function vr(e) {
          var _this7;
          _classCallCheck(this, vr);
          _this7 = _callSuper(this, vr, [e]);
          _this7.type = "atrule";
          return _this7;
        }
        _inherits(vr, _Mf);
        return _createClass(vr, [{
          key: "append",
          value: function append() {
            var _get2;
            for (var _len10 = arguments.length, e = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
              e[_key10] = arguments[_key10];
            }
            return this.proxyOf.nodes || (this.nodes = []), (_get2 = _get(_getPrototypeOf(vr.prototype), "append", this)).call.apply(_get2, [this].concat(e));
          }
        }, {
          key: "prepend",
          value: function prepend() {
            var _get3;
            for (var _len11 = arguments.length, e = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
              e[_key11] = arguments[_key11];
            }
            return this.proxyOf.nodes || (this.nodes = []), (_get3 = _get(_getPrototypeOf(vr.prototype), "prepend", this)).call.apply(_get3, [this].concat(e));
          }
        }]);
      }(Mf);
    Bf.exports = vr;
    vr["default"] = vr;
    Mf.registerAtRule(vr);
  });
  var Tt = v(function (nT, $f) {
    l();
    "use strict";
    var Ff = it(),
      Nf,
      Lf,
      wt = /*#__PURE__*/function (_Ff) {
        function wt(e) {
          var _this8;
          _classCallCheck(this, wt);
          _this8 = _callSuper(this, wt, [e]);
          _this8.type = "root", _this8.nodes || (_this8.nodes = []);
          return _this8;
        }
        _inherits(wt, _Ff);
        return _createClass(wt, [{
          key: "removeChild",
          value: function removeChild(e, t) {
            var r = this.index(e);
            return !t && r === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[r].raws.before), _get(_getPrototypeOf(wt.prototype), "removeChild", this).call(this, e);
          }
        }, {
          key: "normalize",
          value: function normalize(e, t, r) {
            var n = _get(_getPrototypeOf(wt.prototype), "normalize", this).call(this, e);
            if (t) {
              if (r === "prepend") this.nodes.length > 1 ? t.raws.before = this.nodes[1].raws.before : delete t.raws.before;else if (this.first !== t) {
                var _iterator35 = _createForOfIteratorHelper(n),
                  _step35;
                try {
                  for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {
                    var a = _step35.value;
                    a.raws.before = t.raws.before;
                  }
                } catch (err) {
                  _iterator35.e(err);
                } finally {
                  _iterator35.f();
                }
              }
            }
            return n;
          }
        }, {
          key: "toResult",
          value: function toResult() {
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            return new Nf(new Lf(), this, e).stringify();
          }
        }]);
      }(Ff);
    wt.registerLazyResult = function (i) {
      Nf = i;
    };
    wt.registerProcessor = function (i) {
      Lf = i;
    };
    $f.exports = wt;
    wt["default"] = wt;
    Ff.registerRoot(wt);
  });
  var Ts = v(function (sT, jf) {
    l();
    "use strict";
    var xr = {
      split: function split(i, e, t) {
        var r = [],
          n = "",
          a = !1,
          s = 0,
          o = !1,
          u = "",
          c = !1;
        var _iterator36 = _createForOfIteratorHelper(i),
          _step36;
        try {
          for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {
            var f = _step36.value;
            c ? c = !1 : f === "\\" ? c = !0 : o ? f === u && (o = !1) : f === '"' || f === "'" ? (o = !0, u = f) : f === "(" ? s += 1 : f === ")" ? s > 0 && (s -= 1) : s === 0 && e.includes(f) && (a = !0), a ? (n !== "" && r.push(n.trim()), n = "", a = !1) : n += f;
          }
        } catch (err) {
          _iterator36.e(err);
        } finally {
          _iterator36.f();
        }
        return (t || n !== "") && r.push(n.trim()), r;
      },
      space: function space(i) {
        var e = [" ", "\n", "	"];
        return xr.split(i, e);
      },
      comma: function comma(i) {
        return xr.split(i, [","], !0);
      }
    };
    jf.exports = xr;
    xr["default"] = xr;
  });
  var ji = v(function (aT, Vf) {
    l();
    "use strict";
    var zf = it(),
      _0 = Ts(),
      kr = /*#__PURE__*/function (_zf) {
        function kr(e) {
          var _this9;
          _classCallCheck(this, kr);
          _this9 = _callSuper(this, kr, [e]);
          _this9.type = "rule", _this9.nodes || (_this9.nodes = []);
          return _this9;
        }
        _inherits(kr, _zf);
        return _createClass(kr, [{
          key: "selectors",
          get: function get() {
            return _0.comma(this.selector);
          },
          set: function set(e) {
            var t = this.selector ? this.selector.match(/,\s*/) : null,
              r = t ? t[0] : "," + this.raw("between", "beforeOpen");
            this.selector = e.join(r);
          }
        }]);
      }(zf);
    Vf.exports = kr;
    kr["default"] = kr;
    zf.registerRule(kr);
  });
  var Yf = v(function (oT, Hf) {
    l();
    "use strict";
    var O0 = yr(),
      E0 = Rf(),
      T0 = wr(),
      P0 = $i(),
      D0 = Tt(),
      Uf = ji(),
      Wf = {
        empty: !0,
        space: !0
      };
    function I0(i) {
      for (var e = i.length - 1; e >= 0; e--) {
        var t = i[e],
          r = t[3] || t[2];
        if (r) return r;
      }
    }
    var Gf = /*#__PURE__*/function () {
      function Gf(e) {
        _classCallCheck(this, Gf);
        this.input = e, this.root = new D0(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.customProperty = !1, this.createTokenizer(), this.root.source = {
          input: e,
          start: {
            offset: 0,
            line: 1,
            column: 1
          }
        };
      }
      return _createClass(Gf, [{
        key: "createTokenizer",
        value: function createTokenizer() {
          this.tokenizer = E0(this.input);
        }
      }, {
        key: "parse",
        value: function parse() {
          var e;
          for (; !this.tokenizer.endOfFile();) switch (e = this.tokenizer.nextToken(), e[0]) {
            case "space":
              this.spaces += e[1];
              break;
            case ";":
              this.freeSemicolon(e);
              break;
            case "}":
              this.end(e);
              break;
            case "comment":
              this.comment(e);
              break;
            case "at-word":
              this.atrule(e);
              break;
            case "{":
              this.emptyRule(e);
              break;
            default:
              this.other(e);
              break;
          }
          this.endFile();
        }
      }, {
        key: "comment",
        value: function comment(e) {
          var t = new T0();
          this.init(t, e[2]), t.source.end = this.getPosition(e[3] || e[2]);
          var r = e[1].slice(2, -2);
          if (/^\s*$/.test(r)) t.text = "", t.raws.left = r, t.raws.right = "";else {
            var n = r.match(/^(\s*)([^]*\S)(\s*)$/);
            t.text = n[2], t.raws.left = n[1], t.raws.right = n[3];
          }
        }
      }, {
        key: "emptyRule",
        value: function emptyRule(e) {
          var t = new Uf();
          this.init(t, e[2]), t.selector = "", t.raws.between = "", this.current = t;
        }
      }, {
        key: "other",
        value: function other(e) {
          var t = !1,
            r = null,
            n = !1,
            a = null,
            s = [],
            o = e[1].startsWith("--"),
            u = [],
            c = e;
          for (; c;) {
            if (r = c[0], u.push(c), r === "(" || r === "[") a || (a = c), s.push(r === "(" ? ")" : "]");else if (o && n && r === "{") a || (a = c), s.push("}");else if (s.length === 0) {
              if (r === ";") {
                if (n) {
                  this.decl(u, o);
                  return;
                } else break;
              } else if (r === "{") {
                this.rule(u);
                return;
              } else if (r === "}") {
                this.tokenizer.back(u.pop()), t = !0;
                break;
              } else r === ":" && (n = !0);
            } else r === s[s.length - 1] && (s.pop(), s.length === 0 && (a = null));
            c = this.tokenizer.nextToken();
          }
          if (this.tokenizer.endOfFile() && (t = !0), s.length > 0 && this.unclosedBracket(a), t && n) {
            if (!o) for (; u.length && (c = u[u.length - 1][0], !(c !== "space" && c !== "comment"));) this.tokenizer.back(u.pop());
            this.decl(u, o);
          } else this.unknownWord(u);
        }
      }, {
        key: "rule",
        value: function rule(e) {
          e.pop();
          var t = new Uf();
          this.init(t, e[0][2]), t.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(t, "selector", e), this.current = t;
        }
      }, {
        key: "decl",
        value: function decl(e, t) {
          var r = new O0();
          this.init(r, e[0][2]);
          var n = e[e.length - 1];
          for (n[0] === ";" && (this.semicolon = !0, e.pop()), r.source.end = this.getPosition(n[3] || n[2] || I0(e)); e[0][0] !== "word";) e.length === 1 && this.unknownWord(e), r.raws.before += e.shift()[1];
          for (r.source.start = this.getPosition(e[0][2]), r.prop = ""; e.length;) {
            var c = e[0][0];
            if (c === ":" || c === "space" || c === "comment") break;
            r.prop += e.shift()[1];
          }
          r.raws.between = "";
          var a;
          for (; e.length;) if (a = e.shift(), a[0] === ":") {
            r.raws.between += a[1];
            break;
          } else a[0] === "word" && /\w/.test(a[1]) && this.unknownWord([a]), r.raws.between += a[1];
          (r.prop[0] === "_" || r.prop[0] === "*") && (r.raws.before += r.prop[0], r.prop = r.prop.slice(1));
          var s = [],
            o;
          for (; e.length && (o = e[0][0], !(o !== "space" && o !== "comment"));) s.push(e.shift());
          this.precheckMissedSemicolon(e);
          for (var _c3 = e.length - 1; _c3 >= 0; _c3--) {
            if (a = e[_c3], a[1].toLowerCase() === "!important") {
              r.important = !0;
              var f = this.stringFrom(e, _c3);
              f = this.spacesFromEnd(e) + f, f !== " !important" && (r.raws.important = f);
              break;
            } else if (a[1].toLowerCase() === "important") {
              var _f3 = e.slice(0),
                d = "";
              for (var p = _c3; p > 0; p--) {
                var m = _f3[p][0];
                if (d.trim().indexOf("!") === 0 && m !== "space") break;
                d = _f3.pop()[1] + d;
              }
              d.trim().indexOf("!") === 0 && (r.important = !0, r.raws.important = d, e = _f3);
            }
            if (a[0] !== "space" && a[0] !== "comment") break;
          }
          e.some(function (c) {
            return c[0] !== "space" && c[0] !== "comment";
          }) && (r.raws.between += s.map(function (c) {
            return c[1];
          }).join(""), s = []), this.raw(r, "value", s.concat(e), t), r.value.includes(":") && !t && this.checkMissedSemicolon(e);
        }
      }, {
        key: "atrule",
        value: function atrule(e) {
          var t = new P0();
          t.name = e[1].slice(1), t.name === "" && this.unnamedAtrule(t, e), this.init(t, e[2]);
          var r,
            n,
            a,
            s = !1,
            o = !1,
            u = [],
            c = [];
          for (; !this.tokenizer.endOfFile();) {
            if (e = this.tokenizer.nextToken(), r = e[0], r === "(" || r === "[" ? c.push(r === "(" ? ")" : "]") : r === "{" && c.length > 0 ? c.push("}") : r === c[c.length - 1] && c.pop(), c.length === 0) {
              if (r === ";") {
                t.source.end = this.getPosition(e[2]), this.semicolon = !0;
                break;
              } else if (r === "{") {
                o = !0;
                break;
              } else if (r === "}") {
                if (u.length > 0) {
                  for (a = u.length - 1, n = u[a]; n && n[0] === "space";) n = u[--a];
                  n && (t.source.end = this.getPosition(n[3] || n[2]));
                }
                this.end(e);
                break;
              } else u.push(e);
            } else u.push(e);
            if (this.tokenizer.endOfFile()) {
              s = !0;
              break;
            }
          }
          t.raws.between = this.spacesAndCommentsFromEnd(u), u.length ? (t.raws.afterName = this.spacesAndCommentsFromStart(u), this.raw(t, "params", u), s && (e = u[u.length - 1], t.source.end = this.getPosition(e[3] || e[2]), this.spaces = t.raws.between, t.raws.between = "")) : (t.raws.afterName = "", t.params = ""), o && (t.nodes = [], this.current = t);
        }
      }, {
        key: "end",
        value: function end(e) {
          this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current = this.current.parent) : this.unexpectedClose(e);
        }
      }, {
        key: "endFile",
        value: function endFile() {
          this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        }
      }, {
        key: "freeSemicolon",
        value: function freeSemicolon(e) {
          if (this.spaces += e[1], this.current.nodes) {
            var t = this.current.nodes[this.current.nodes.length - 1];
            t && t.type === "rule" && !t.raws.ownSemicolon && (t.raws.ownSemicolon = this.spaces, this.spaces = "");
          }
        }
      }, {
        key: "getPosition",
        value: function getPosition(e) {
          var t = this.input.fromOffset(e);
          return {
            offset: e,
            line: t.line,
            column: t.col
          };
        }
      }, {
        key: "init",
        value: function init(e, t) {
          this.current.push(e), e.source = {
            start: this.getPosition(t),
            input: this.input
          }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = !1);
        }
      }, {
        key: "raw",
        value: function raw(e, t, r, n) {
          var a,
            s,
            o = r.length,
            u = "",
            c = !0,
            f,
            d;
          for (var p = 0; p < o; p += 1) a = r[p], s = a[0], s === "space" && p === o - 1 && !n ? c = !1 : s === "comment" ? (d = r[p - 1] ? r[p - 1][0] : "empty", f = r[p + 1] ? r[p + 1][0] : "empty", !Wf[d] && !Wf[f] ? u.slice(-1) === "," ? c = !1 : u += a[1] : c = !1) : u += a[1];
          if (!c) {
            var _p3 = r.reduce(function (m, b) {
              return m + b[1];
            }, "");
            e.raws[t] = {
              value: u,
              raw: _p3
            };
          }
          e[t] = u;
        }
      }, {
        key: "spacesAndCommentsFromEnd",
        value: function spacesAndCommentsFromEnd(e) {
          var t,
            r = "";
          for (; e.length && (t = e[e.length - 1][0], !(t !== "space" && t !== "comment"));) r = e.pop()[1] + r;
          return r;
        }
      }, {
        key: "spacesAndCommentsFromStart",
        value: function spacesAndCommentsFromStart(e) {
          var t,
            r = "";
          for (; e.length && (t = e[0][0], !(t !== "space" && t !== "comment"));) r += e.shift()[1];
          return r;
        }
      }, {
        key: "spacesFromEnd",
        value: function spacesFromEnd(e) {
          var t,
            r = "";
          for (; e.length && (t = e[e.length - 1][0], t === "space");) r = e.pop()[1] + r;
          return r;
        }
      }, {
        key: "stringFrom",
        value: function stringFrom(e, t) {
          var r = "";
          for (var n = t; n < e.length; n++) r += e[n][1];
          return e.splice(t, e.length - t), r;
        }
      }, {
        key: "colon",
        value: function colon(e) {
          var t = 0,
            r,
            n,
            a;
          var _iterator37 = _createForOfIteratorHelper(e.entries()),
            _step37;
          try {
            for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {
              var _step37$value = _slicedToArray(_step37.value, 2),
                s = _step37$value[0],
                o = _step37$value[1];
              if (r = o, n = r[0], n === "(" && (t += 1), n === ")" && (t -= 1), t === 0 && n === ":") if (!a) this.doubleColon(r);else {
                if (a[0] === "word" && a[1] === "progid") continue;
                return s;
              }
              a = r;
            }
          } catch (err) {
            _iterator37.e(err);
          } finally {
            _iterator37.f();
          }
          return !1;
        }
      }, {
        key: "unclosedBracket",
        value: function unclosedBracket(e) {
          throw this.input.error("Unclosed bracket", {
            offset: e[2]
          }, {
            offset: e[2] + 1
          });
        }
      }, {
        key: "unknownWord",
        value: function unknownWord(e) {
          throw this.input.error("Unknown word", {
            offset: e[0][2]
          }, {
            offset: e[0][2] + e[0][1].length
          });
        }
      }, {
        key: "unexpectedClose",
        value: function unexpectedClose(e) {
          throw this.input.error("Unexpected }", {
            offset: e[2]
          }, {
            offset: e[2] + 1
          });
        }
      }, {
        key: "unclosedBlock",
        value: function unclosedBlock() {
          var e = this.current.source.start;
          throw this.input.error("Unclosed block", e.line, e.column);
        }
      }, {
        key: "doubleColon",
        value: function doubleColon(e) {
          throw this.input.error("Double colon", {
            offset: e[2]
          }, {
            offset: e[2] + e[1].length
          });
        }
      }, {
        key: "unnamedAtrule",
        value: function unnamedAtrule(e, t) {
          throw this.input.error("At-rule without name", {
            offset: t[2]
          }, {
            offset: t[2] + t[1].length
          });
        }
      }, {
        key: "precheckMissedSemicolon",
        value: function precheckMissedSemicolon() {}
      }, {
        key: "checkMissedSemicolon",
        value: function checkMissedSemicolon(e) {
          var t = this.colon(e);
          if (t === !1) return;
          var r = 0,
            n;
          for (var a = t - 1; a >= 0 && (n = e[a], !(n[0] !== "space" && (r += 1, r === 2))); a--);
          throw this.input.error("Missed semicolon", n[0] === "word" ? n[3] + 1 : n[2]);
        }
      }]);
    }();
    Hf.exports = Gf;
  });
  var Qf = v(function () {
    l();
  });
  var Xf = v(function (fT, Jf) {
    l();
    var q0 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict",
      R0 = function R0(i) {
        var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 21;
        return function () {
          var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : e;
          var r = "",
            n = t;
          for (; n--;) r += i[Math.random() * i.length | 0];
          return r;
        };
      },
      M0 = function M0() {
        var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 21;
        var e = "",
          t = i;
        for (; t--;) e += q0[Math.random() * 64 | 0];
        return e;
      };
    Jf.exports = {
      nanoid: M0,
      customAlphabet: R0
    };
  });
  var Ps = v(function (cT, Kf) {
    l();
    Kf.exports = {};
  });
  var Vi = v(function (pT, rc) {
    l();
    "use strict";
    var _Qf = Qf(),
      B0 = _Qf.SourceMapConsumer,
      F0 = _Qf.SourceMapGenerator,
      _ref66 = (ys(), rf),
      Zf = _ref66.fileURLToPath,
      zi = _ref66.pathToFileURL,
      _ref67 = (yt(), Zu),
      Ds = _ref67.resolve,
      Is = _ref67.isAbsolute,
      _Xf = Xf(),
      N0 = _Xf.nanoid,
      qs = ws(),
      ec = ki(),
      L0 = Ps(),
      Rs = Symbol("fromOffsetCache"),
      $0 = Boolean(B0 && F0),
      tc = Boolean(Ds && Is),
      Sr = /*#__PURE__*/function () {
        function Sr(e) {
          var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          _classCallCheck(this, Sr);
          if (e === null || typeof e == "undefined" || _typeof(e) == "object" && !e.toString) throw new Error("PostCSS received ".concat(e, " instead of CSS string"));
          if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, t.from && (!tc || /^\w+:\/\//.test(t.from) || Is(t.from) ? this.file = t.from : this.file = Ds(t.from)), tc && $0) {
            var r = new L0(this.css, t);
            if (r.text) {
              this.map = r;
              var n = r.consumer().file;
              !this.file && n && (this.file = this.mapResolve(n));
            }
          }
          this.file || (this.id = "<input css " + N0(6) + ">"), this.map && (this.map.file = this.from);
        }
        return _createClass(Sr, [{
          key: "fromOffset",
          value: function fromOffset(e) {
            var t, r;
            if (this[Rs]) r = this[Rs];else {
              var a = this.css.split("\n");
              r = new Array(a.length);
              var s = 0;
              for (var o = 0, u = a.length; o < u; o++) r[o] = s, s += a[o].length + 1;
              this[Rs] = r;
            }
            t = r[r.length - 1];
            var n = 0;
            if (e >= t) n = r.length - 1;else {
              var _a5 = r.length - 2,
                _s6;
              for (; n < _a5;) if (_s6 = n + (_a5 - n >> 1), e < r[_s6]) _a5 = _s6 - 1;else if (e >= r[_s6 + 1]) n = _s6 + 1;else {
                n = _s6;
                break;
              }
            }
            return {
              line: n + 1,
              col: e - r[n] + 1
            };
          }
        }, {
          key: "error",
          value: function error(e, t, r) {
            var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
            var a, s, o;
            if (t && _typeof(t) == "object") {
              var c = t,
                f = r;
              if (typeof c.offset == "number") {
                var d = this.fromOffset(c.offset);
                t = d.line, r = d.col;
              } else t = c.line, r = c.column;
              if (typeof f.offset == "number") {
                var _d3 = this.fromOffset(f.offset);
                s = _d3.line, o = _d3.col;
              } else s = f.line, o = f.column;
            } else if (!r) {
              var _c4 = this.fromOffset(t);
              t = _c4.line, r = _c4.col;
            }
            var u = this.origin(t, r, s, o);
            return u ? a = new ec(e, u.endLine === void 0 ? u.line : {
              line: u.line,
              column: u.column
            }, u.endLine === void 0 ? u.column : {
              line: u.endLine,
              column: u.endColumn
            }, u.source, u.file, n.plugin) : a = new ec(e, s === void 0 ? t : {
              line: t,
              column: r
            }, s === void 0 ? r : {
              line: s,
              column: o
            }, this.css, this.file, n.plugin), a.input = {
              line: t,
              column: r,
              endLine: s,
              endColumn: o,
              source: this.css
            }, this.file && (zi && (a.input.url = zi(this.file).toString()), a.input.file = this.file), a;
          }
        }, {
          key: "origin",
          value: function origin(e, t, r, n) {
            if (!this.map) return !1;
            var a = this.map.consumer(),
              s = a.originalPositionFor({
                line: e,
                column: t
              });
            if (!s.source) return !1;
            var o;
            typeof r == "number" && (o = a.originalPositionFor({
              line: r,
              column: n
            }));
            var u;
            Is(s.source) ? u = zi(s.source) : u = new URL(s.source, this.map.consumer().sourceRoot || zi(this.map.mapFile));
            var c = {
              url: u.toString(),
              line: s.line,
              column: s.column,
              endLine: o && o.line,
              endColumn: o && o.column
            };
            if (u.protocol === "file:") if (Zf) c.file = Zf(u);else throw new Error("file: protocol is not available in this PostCSS build");
            var f = a.sourceContentFor(s.source);
            return f && (c.source = f), c;
          }
        }, {
          key: "mapResolve",
          value: function mapResolve(e) {
            return /^\w+:\/\//.test(e) ? e : Ds(this.map.consumer().sourceRoot || this.map.root || ".", e);
          }
        }, {
          key: "from",
          get: function get() {
            return this.file || this.id;
          }
        }, {
          key: "toJSON",
          value: function toJSON() {
            var e = {};
            for (var _i9 = 0, _arr = ["hasBOM", "css", "file", "id"]; _i9 < _arr.length; _i9++) {
              var t = _arr[_i9];
              this[t] != null && (e[t] = this[t]);
            }
            return this.map && (e.map = _objectSpread({}, this.map), e.map.consumerCache && (e.map.consumerCache = void 0)), e;
          }
        }]);
      }();
    rc.exports = Sr;
    Sr["default"] = Sr;
    qs && qs.registerInput && qs.registerInput(Sr);
  });
  var Wi = v(function (dT, ic) {
    l();
    "use strict";
    var j0 = it(),
      z0 = Yf(),
      V0 = Vi();
    function Ui(i, e) {
      var t = new V0(i, e),
        r = new z0(t);
      try {
        r.parse();
      } catch (n) {
        throw n;
      }
      return r.root;
    }
    ic.exports = Ui;
    Ui["default"] = Ui;
    j0.registerParse(Ui);
  });
  var Fs = v(function (mT, oc) {
    l();
    "use strict";
    var _Si3 = Si(),
      qe = _Si3.isClean,
      U0 = _Si3.my,
      W0 = Ss(),
      G0 = mr(),
      H0 = it(),
      Y0 = Ti(),
      hT = _s(),
      nc = Ii(),
      Q0 = Wi(),
      J0 = Tt(),
      X0 = {
        document: "Document",
        root: "Root",
        atrule: "AtRule",
        rule: "Rule",
        decl: "Declaration",
        comment: "Comment"
      },
      K0 = {
        postcssPlugin: !0,
        prepare: !0,
        Once: !0,
        Document: !0,
        Root: !0,
        Declaration: !0,
        Rule: !0,
        AtRule: !0,
        Comment: !0,
        DeclarationExit: !0,
        RuleExit: !0,
        AtRuleExit: !0,
        CommentExit: !0,
        RootExit: !0,
        DocumentExit: !0,
        OnceExit: !0
      },
      Z0 = {
        postcssPlugin: !0,
        prepare: !0,
        Once: !0
      },
      Pt = 0;
    function Cr(i) {
      return _typeof(i) == "object" && typeof i.then == "function";
    }
    function sc(i) {
      var e = !1,
        t = X0[i.type];
      return i.type === "decl" ? e = i.prop.toLowerCase() : i.type === "atrule" && (e = i.name.toLowerCase()), e && i.append ? [t, t + "-" + e, Pt, t + "Exit", t + "Exit-" + e] : e ? [t, t + "-" + e, t + "Exit", t + "Exit-" + e] : i.append ? [t, Pt, t + "Exit"] : [t, t + "Exit"];
    }
    function ac(i) {
      var e;
      return i.type === "document" ? e = ["Document", Pt, "DocumentExit"] : i.type === "root" ? e = ["Root", Pt, "RootExit"] : e = sc(i), {
        node: i,
        events: e,
        eventIndex: 0,
        visitors: [],
        visitorIndex: 0,
        iterator: 0
      };
    }
    function Ms(i) {
      return i[qe] = !1, i.nodes && i.nodes.forEach(function (e) {
        return Ms(e);
      }), i;
    }
    var Bs = {},
      Ve = /*#__PURE__*/function () {
        function Ve(e, t, r) {
          var _this10 = this;
          _classCallCheck(this, Ve);
          this.stringified = !1, this.processed = !1;
          var n;
          if (_typeof(t) == "object" && t !== null && (t.type === "root" || t.type === "document")) n = Ms(t);else if (t instanceof Ve || t instanceof nc) n = Ms(t.root), t.map && (typeof r.map == "undefined" && (r.map = {}), r.map.inline || (r.map.inline = !1), r.map.prev = t.map);else {
            var a = Q0;
            r.syntax && (a = r.syntax.parse), r.parser && (a = r.parser), a.parse && (a = a.parse);
            try {
              n = a(t, r);
            } catch (s) {
              this.processed = !0, this.error = s;
            }
            n && !n[U0] && H0.rebuild(n);
          }
          this.result = new nc(e, n, r), this.helpers = _objectSpread(_objectSpread({}, Bs), {}, {
            result: this.result,
            postcss: Bs
          }), this.plugins = this.processor.plugins.map(function (a) {
            return _typeof(a) == "object" && a.prepare ? _objectSpread(_objectSpread({}, a), a.prepare(_this10.result)) : a;
          });
        }
        return _createClass(Ve, [{
          key: Symbol.toStringTag,
          get: function get() {
            return "LazyResult";
          }
        }, {
          key: "processor",
          get: function get() {
            return this.result.processor;
          }
        }, {
          key: "opts",
          get: function get() {
            return this.result.opts;
          }
        }, {
          key: "css",
          get: function get() {
            return this.stringify().css;
          }
        }, {
          key: "content",
          get: function get() {
            return this.stringify().content;
          }
        }, {
          key: "map",
          get: function get() {
            return this.stringify().map;
          }
        }, {
          key: "root",
          get: function get() {
            return this.sync().root;
          }
        }, {
          key: "messages",
          get: function get() {
            return this.sync().messages;
          }
        }, {
          key: "warnings",
          value: function warnings() {
            return this.sync().warnings();
          }
        }, {
          key: "toString",
          value: function toString() {
            return this.css;
          }
        }, {
          key: "then",
          value: function then(e, t) {
            return this.async().then(e, t);
          }
        }, {
          key: "catch",
          value: function _catch(e) {
            return this.async()["catch"](e);
          }
        }, {
          key: "finally",
          value: function _finally(e) {
            return this.async().then(e, e);
          }
        }, {
          key: "async",
          value: function async() {
            return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
          }
        }, {
          key: "sync",
          value: function sync() {
            if (this.error) throw this.error;
            if (this.processed) return this.result;
            if (this.processed = !0, this.processing) throw this.getAsyncError();
            var _iterator38 = _createForOfIteratorHelper(this.plugins),
              _step38;
            try {
              for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {
                var _e13 = _step38.value;
                var _t7 = this.runOnRoot(_e13);
                if (Cr(_t7)) throw this.getAsyncError();
              }
            } catch (err) {
              _iterator38.e(err);
            } finally {
              _iterator38.f();
            }
            if (this.prepareVisitors(), this.hasListener) {
              var e = this.result.root;
              for (; !e[qe];) e[qe] = !0, this.walkSync(e);
              if (this.listeners.OnceExit) if (e.type === "document") {
                var _iterator39 = _createForOfIteratorHelper(e.nodes),
                  _step39;
                try {
                  for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {
                    var t = _step39.value;
                    this.visitSync(this.listeners.OnceExit, t);
                  }
                } catch (err) {
                  _iterator39.e(err);
                } finally {
                  _iterator39.f();
                }
              } else this.visitSync(this.listeners.OnceExit, e);
            }
            return this.result;
          }
        }, {
          key: "stringify",
          value: function stringify() {
            if (this.error) throw this.error;
            if (this.stringified) return this.result;
            this.stringified = !0, this.sync();
            var e = this.result.opts,
              t = G0;
            e.syntax && (t = e.syntax.stringify), e.stringifier && (t = e.stringifier), t.stringify && (t = t.stringify);
            var n = new W0(t, this.result.root, this.result.opts).generate();
            return this.result.css = n[0], this.result.map = n[1], this.result;
          }
        }, {
          key: "walkSync",
          value: function walkSync(e) {
            var _this11 = this;
            e[qe] = !0;
            var t = sc(e);
            var _iterator40 = _createForOfIteratorHelper(t),
              _step40;
            try {
              for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {
                var r = _step40.value;
                if (r === Pt) e.nodes && e.each(function (n) {
                  n[qe] || _this11.walkSync(n);
                });else {
                  var n = this.listeners[r];
                  if (n && this.visitSync(n, e.toProxy())) return;
                }
              }
            } catch (err) {
              _iterator40.e(err);
            } finally {
              _iterator40.f();
            }
          }
        }, {
          key: "visitSync",
          value: function visitSync(e, t) {
            var _iterator41 = _createForOfIteratorHelper(e),
              _step41;
            try {
              for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {
                var _step41$value = _slicedToArray(_step41.value, 2),
                  r = _step41$value[0],
                  n = _step41$value[1];
                this.result.lastPlugin = r;
                var a = void 0;
                try {
                  a = n(t, this.helpers);
                } catch (s) {
                  throw this.handleError(s, t.proxyOf);
                }
                if (t.type !== "root" && t.type !== "document" && !t.parent) return !0;
                if (Cr(a)) throw this.getAsyncError();
              }
            } catch (err) {
              _iterator41.e(err);
            } finally {
              _iterator41.f();
            }
          }
        }, {
          key: "runOnRoot",
          value: function runOnRoot(e) {
            var _this12 = this;
            this.result.lastPlugin = e;
            try {
              if (_typeof(e) == "object" && e.Once) {
                if (this.result.root.type === "document") {
                  var t = this.result.root.nodes.map(function (r) {
                    return e.Once(r, _this12.helpers);
                  });
                  return Cr(t[0]) ? Promise.all(t) : t;
                }
                return e.Once(this.result.root, this.helpers);
              } else if (typeof e == "function") return e(this.result.root, this.result);
            } catch (t) {
              throw this.handleError(t);
            }
          }
        }, {
          key: "getAsyncError",
          value: function getAsyncError() {
            throw new Error("Use process(css).then(cb) to work with async plugins");
          }
        }, {
          key: "handleError",
          value: function handleError(e, t) {
            var r = this.result.lastPlugin;
            try {
              t && t.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin ? (e.plugin = r.postcssPlugin, e.setMessage()) : r.postcssVersion;
            } catch (n) {
              console && console.error && console.error(n);
            }
            return e;
          }
        }, {
          key: "runAsync",
          value: function () {
            var _runAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
              var _this13 = this;
              var e, t, r, _e14, _t8, _r10, a, _iterator42, _step42, _loop3;
              return _regeneratorRuntime().wrap(function _callee$(_context10) {
                while (1) switch (_context10.prev = _context10.next) {
                  case 0:
                    this.plugin = 0;
                    e = 0;
                  case 2:
                    if (!(e < this.plugins.length)) {
                      _context10.next = 16;
                      break;
                    }
                    t = this.plugins[e], r = this.runOnRoot(t);
                    if (!Cr(r)) {
                      _context10.next = 13;
                      break;
                    }
                    _context10.prev = 5;
                    _context10.next = 8;
                    return r;
                  case 8:
                    _context10.next = 13;
                    break;
                  case 10:
                    _context10.prev = 10;
                    _context10.t0 = _context10["catch"](5);
                    throw this.handleError(_context10.t0);
                  case 13:
                    e++;
                    _context10.next = 2;
                    break;
                  case 16:
                    if (!(this.prepareVisitors(), this.hasListener)) {
                      _context10.next = 54;
                      break;
                    }
                    _e14 = this.result.root;
                  case 18:
                    if (_e14[qe]) {
                      _context10.next = 37;
                      break;
                    }
                    _e14[qe] = !0;
                    _t8 = [ac(_e14)];
                  case 21:
                    if (!(_t8.length > 0)) {
                      _context10.next = 35;
                      break;
                    }
                    _r10 = this.visitTick(_t8);
                    if (!Cr(_r10)) {
                      _context10.next = 33;
                      break;
                    }
                    _context10.prev = 24;
                    _context10.next = 27;
                    return _r10;
                  case 27:
                    _context10.next = 33;
                    break;
                  case 29:
                    _context10.prev = 29;
                    _context10.t1 = _context10["catch"](24);
                    a = _t8[_t8.length - 1].node;
                    throw this.handleError(_context10.t1, a);
                  case 33:
                    _context10.next = 21;
                    break;
                  case 35:
                    _context10.next = 18;
                    break;
                  case 37:
                    if (!this.listeners.OnceExit) {
                      _context10.next = 54;
                      break;
                    }
                    _iterator42 = _createForOfIteratorHelper(this.listeners.OnceExit);
                    _context10.prev = 39;
                    _loop3 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop3() {
                      var _step42$value, t, r, n;
                      return _regeneratorRuntime().wrap(function _loop3$(_context9) {
                        while (1) switch (_context9.prev = _context9.next) {
                          case 0:
                            _step42$value = _slicedToArray(_step42.value, 2), t = _step42$value[0], r = _step42$value[1];
                            _this13.result.lastPlugin = t;
                            _context9.prev = 2;
                            if (!(_e14.type === "document")) {
                              _context9.next = 9;
                              break;
                            }
                            n = _e14.nodes.map(function (a) {
                              return r(a, _this13.helpers);
                            });
                            _context9.next = 7;
                            return Promise.all(n);
                          case 7:
                            _context9.next = 11;
                            break;
                          case 9:
                            _context9.next = 11;
                            return r(_e14, _this13.helpers);
                          case 11:
                            _context9.next = 16;
                            break;
                          case 13:
                            _context9.prev = 13;
                            _context9.t0 = _context9["catch"](2);
                            throw _this13.handleError(_context9.t0);
                          case 16:
                          case "end":
                            return _context9.stop();
                        }
                      }, _loop3, null, [[2, 13]]);
                    });
                    _iterator42.s();
                  case 42:
                    if ((_step42 = _iterator42.n()).done) {
                      _context10.next = 46;
                      break;
                    }
                    return _context10.delegateYield(_loop3(), "t2", 44);
                  case 44:
                    _context10.next = 42;
                    break;
                  case 46:
                    _context10.next = 51;
                    break;
                  case 48:
                    _context10.prev = 48;
                    _context10.t3 = _context10["catch"](39);
                    _iterator42.e(_context10.t3);
                  case 51:
                    _context10.prev = 51;
                    _iterator42.f();
                    return _context10.finish(51);
                  case 54:
                    return _context10.abrupt("return", (this.processed = !0, this.stringify()));
                  case 55:
                  case "end":
                    return _context10.stop();
                }
              }, _callee, this, [[5, 10], [24, 29], [39, 48, 51, 54]]);
            }));
            function runAsync() {
              return _runAsync.apply(this, arguments);
            }
            return runAsync;
          }()
        }, {
          key: "prepareVisitors",
          value: function prepareVisitors() {
            var _this14 = this;
            this.listeners = {};
            var e = function e(t, r, n) {
              _this14.listeners[r] || (_this14.listeners[r] = []), _this14.listeners[r].push([t, n]);
            };
            var _iterator43 = _createForOfIteratorHelper(this.plugins),
              _step43;
            try {
              for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {
                var t = _step43.value;
                if (_typeof(t) == "object") for (var r in t) {
                  if (!K0[r] && /^[A-Z]/.test(r)) throw new Error("Unknown event ".concat(r, " in ").concat(t.postcssPlugin, ". Try to update PostCSS (").concat(this.processor.version, " now)."));
                  if (!Z0[r]) if (_typeof(t[r]) == "object") for (var n in t[r]) n === "*" ? e(t, r, t[r][n]) : e(t, r + "-" + n.toLowerCase(), t[r][n]);else typeof t[r] == "function" && e(t, r, t[r]);
                }
              }
            } catch (err) {
              _iterator43.e(err);
            } finally {
              _iterator43.f();
            }
            this.hasListener = Object.keys(this.listeners).length > 0;
          }
        }, {
          key: "visitTick",
          value: function visitTick(e) {
            var t = e[e.length - 1],
              r = t.node,
              n = t.visitors;
            if (r.type !== "root" && r.type !== "document" && !r.parent) {
              e.pop();
              return;
            }
            if (n.length > 0 && t.visitorIndex < n.length) {
              var _n$t$visitorIndex = _slicedToArray(n[t.visitorIndex], 2),
                s = _n$t$visitorIndex[0],
                o = _n$t$visitorIndex[1];
              t.visitorIndex += 1, t.visitorIndex === n.length && (t.visitors = [], t.visitorIndex = 0), this.result.lastPlugin = s;
              try {
                return o(r.toProxy(), this.helpers);
              } catch (u) {
                throw this.handleError(u, r);
              }
            }
            if (t.iterator !== 0) {
              var _s7 = t.iterator,
                _o3;
              for (; _o3 = r.nodes[r.indexes[_s7]];) if (r.indexes[_s7] += 1, !_o3[qe]) {
                _o3[qe] = !0, e.push(ac(_o3));
                return;
              }
              t.iterator = 0, delete r.indexes[_s7];
            }
            var a = t.events;
            for (; t.eventIndex < a.length;) {
              var _s8 = a[t.eventIndex];
              if (t.eventIndex += 1, _s8 === Pt) {
                r.nodes && r.nodes.length && (r[qe] = !0, t.iterator = r.getIterator());
                return;
              } else if (this.listeners[_s8]) {
                t.visitors = this.listeners[_s8];
                return;
              }
            }
            e.pop();
          }
        }]);
      }();
    Ve.registerPostcss = function (i) {
      Bs = i;
    };
    oc.exports = Ve;
    Ve["default"] = Ve;
    J0.registerLazyResult(Ve);
    Y0.registerLazyResult(Ve);
  });
  var uc = v(function (yT, lc) {
    l();
    "use strict";
    var ev = Ss(),
      tv = mr(),
      gT = _s(),
      rv = Wi(),
      iv = Ii(),
      Gi = /*#__PURE__*/function () {
        function Gi(e, t, r) {
          _classCallCheck(this, Gi);
          t = t.toString(), this.stringified = !1, this._processor = e, this._css = t, this._opts = r, this._map = void 0;
          var n,
            a = tv;
          this.result = new iv(this._processor, n, this._opts), this.result.css = t;
          var s = this;
          Object.defineProperty(this.result, "root", {
            get: function get() {
              return s.root;
            }
          });
          var o = new ev(a, n, this._opts, t);
          if (o.isMap()) {
            var _o$generate = o.generate(),
              _o$generate2 = _slicedToArray(_o$generate, 2),
              u = _o$generate2[0],
              c = _o$generate2[1];
            u && (this.result.css = u), c && (this.result.map = c);
          }
        }
        return _createClass(Gi, [{
          key: Symbol.toStringTag,
          get: function get() {
            return "NoWorkResult";
          }
        }, {
          key: "processor",
          get: function get() {
            return this.result.processor;
          }
        }, {
          key: "opts",
          get: function get() {
            return this.result.opts;
          }
        }, {
          key: "css",
          get: function get() {
            return this.result.css;
          }
        }, {
          key: "content",
          get: function get() {
            return this.result.css;
          }
        }, {
          key: "map",
          get: function get() {
            return this.result.map;
          }
        }, {
          key: "root",
          get: function get() {
            if (this._root) return this._root;
            var e,
              t = rv;
            try {
              e = t(this._css, this._opts);
            } catch (r) {
              this.error = r;
            }
            if (this.error) throw this.error;
            return this._root = e, e;
          }
        }, {
          key: "messages",
          get: function get() {
            return [];
          }
        }, {
          key: "warnings",
          value: function warnings() {
            return [];
          }
        }, {
          key: "toString",
          value: function toString() {
            return this._css;
          }
        }, {
          key: "then",
          value: function then(e, t) {
            return this.async().then(e, t);
          }
        }, {
          key: "catch",
          value: function _catch(e) {
            return this.async()["catch"](e);
          }
        }, {
          key: "finally",
          value: function _finally(e) {
            return this.async().then(e, e);
          }
        }, {
          key: "async",
          value: function async() {
            return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
          }
        }, {
          key: "sync",
          value: function sync() {
            if (this.error) throw this.error;
            return this.result;
          }
        }]);
      }();
    lc.exports = Gi;
    Gi["default"] = Gi;
  });
  var cc = v(function (wT, fc) {
    l();
    "use strict";
    var nv = uc(),
      sv = Fs(),
      av = Ti(),
      ov = Tt(),
      Dt = /*#__PURE__*/function () {
        function Dt() {
          var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          _classCallCheck(this, Dt);
          this.version = "8.4.24", this.plugins = this.normalize(e);
        }
        return _createClass(Dt, [{
          key: "use",
          value: function use(e) {
            return this.plugins = this.plugins.concat(this.normalize([e])), this;
          }
        }, {
          key: "process",
          value: function process(e) {
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            return this.plugins.length === 0 && typeof t.parser == "undefined" && typeof t.stringifier == "undefined" && typeof t.syntax == "undefined" ? new nv(this, e, t) : new sv(this, e, t);
          }
        }, {
          key: "normalize",
          value: function normalize(e) {
            var t = [];
            var _iterator44 = _createForOfIteratorHelper(e),
              _step44;
            try {
              for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {
                var r = _step44.value;
                if (r.postcss === !0 ? r = r() : r.postcss && (r = r.postcss), _typeof(r) == "object" && Array.isArray(r.plugins)) t = t.concat(r.plugins);else if (_typeof(r) == "object" && r.postcssPlugin) t.push(r);else if (typeof r == "function") t.push(r);else if (!(_typeof(r) == "object" && (r.parse || r.stringify))) throw new Error(r + " is not a PostCSS plugin");
              }
            } catch (err) {
              _iterator44.e(err);
            } finally {
              _iterator44.f();
            }
            return t;
          }
        }]);
      }();
    fc.exports = Dt;
    Dt["default"] = Dt;
    ov.registerProcessor(Dt);
    av.registerProcessor(Dt);
  });
  var dc = v(function (bT, pc) {
    l();
    "use strict";
    var lv = yr(),
      uv = Ps(),
      fv = wr(),
      cv = $i(),
      pv = Vi(),
      dv = Tt(),
      hv = ji();
    function Ar(i, e) {
      if (Array.isArray(i)) return i.map(function (n) {
        return Ar(n);
      });
      var t = i.inputs,
        r = _objectWithoutProperties(i, _excluded2);
      if (t) {
        e = [];
        var _iterator45 = _createForOfIteratorHelper(t),
          _step45;
        try {
          for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {
            var n = _step45.value;
            var a = _objectSpread(_objectSpread({}, n), {}, {
              __proto__: pv.prototype
            });
            a.map && (a.map = _objectSpread(_objectSpread({}, a.map), {}, {
              __proto__: uv.prototype
            })), e.push(a);
          }
        } catch (err) {
          _iterator45.e(err);
        } finally {
          _iterator45.f();
        }
      }
      if (r.nodes && (r.nodes = i.nodes.map(function (n) {
        return Ar(n, e);
      })), r.source) {
        var _r$source = r.source,
          _n6 = _r$source.inputId,
          _a6 = _objectWithoutProperties(_r$source, _excluded3);
        r.source = _a6, _n6 != null && (r.source.input = e[_n6]);
      }
      if (r.type === "root") return new dv(r);
      if (r.type === "decl") return new lv(r);
      if (r.type === "rule") return new hv(r);
      if (r.type === "comment") return new fv(r);
      if (r.type === "atrule") return new cv(r);
      throw new Error("Unknown node type: " + i.type);
    }
    pc.exports = Ar;
    Ar["default"] = Ar;
  });
  var ge = v(function (vT, vc) {
    l();
    "use strict";
    var mv = ki(),
      hc = yr(),
      gv = Fs(),
      yv = it(),
      Ns = cc(),
      wv = mr(),
      bv = dc(),
      mc = Ti(),
      vv = Os(),
      gc = wr(),
      yc = $i(),
      xv = Ii(),
      kv = Vi(),
      Sv = Wi(),
      Cv = Ts(),
      wc = ji(),
      bc = Tt(),
      Av = gr();
    function j() {
      for (var _len12 = arguments.length, i = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        i[_key12] = arguments[_key12];
      }
      return i.length === 1 && Array.isArray(i[0]) && (i = i[0]), new Ns(i);
    }
    j.plugin = function (e, t) {
      var r = !1;
      function n() {
        console && console.warn && !r && (r = !0, console.warn(e + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"), h.env.LANG && h.env.LANG.startsWith("cn") && console.warn(e + ": \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:\nhttps://www.w3ctech.com/topic/2226"));
        var o = t.apply(void 0, arguments);
        return o.postcssPlugin = e, o.postcssVersion = new Ns().version, o;
      }
      var a;
      return Object.defineProperty(n, "postcss", {
        get: function get() {
          return a || (a = n()), a;
        }
      }), n.process = function (s, o, u) {
        return j([n(u)]).process(s, o);
      }, n;
    };
    j.stringify = wv;
    j.parse = Sv;
    j.fromJSON = bv;
    j.list = Cv;
    j.comment = function (i) {
      return new gc(i);
    };
    j.atRule = function (i) {
      return new yc(i);
    };
    j.decl = function (i) {
      return new hc(i);
    };
    j.rule = function (i) {
      return new wc(i);
    };
    j.root = function (i) {
      return new bc(i);
    };
    j.document = function (i) {
      return new mc(i);
    };
    j.CssSyntaxError = mv;
    j.Declaration = hc;
    j.Container = yv;
    j.Processor = Ns;
    j.Document = mc;
    j.Comment = gc;
    j.Warning = vv;
    j.AtRule = yc;
    j.Result = xv;
    j.Input = kv;
    j.Rule = wc;
    j.Root = bc;
    j.Node = Av;
    gv.registerPostcss(j);
    vc.exports = j;
    j["default"] = j;
  });
  var U,
    z,
    xT,
    kT,
    ST,
    CT,
    AT,
    _T,
    OT,
    ET,
    TT,
    PT,
    DT,
    IT,
    qT,
    RT,
    MT,
    BT,
    FT,
    NT,
    LT,
    $T,
    jT,
    zT,
    VT,
    UT,
    nt = C(function () {
      l();
      U = X(ge()), z = U["default"], xT = U["default"].stringify, kT = U["default"].fromJSON, ST = U["default"].plugin, CT = U["default"].parse, AT = U["default"].list, _T = U["default"].document, OT = U["default"].comment, ET = U["default"].atRule, TT = U["default"].rule, PT = U["default"].decl, DT = U["default"].root, IT = U["default"].CssSyntaxError, qT = U["default"].Declaration, RT = U["default"].Container, MT = U["default"].Processor, BT = U["default"].Document, FT = U["default"].Comment, NT = U["default"].Warning, LT = U["default"].AtRule, $T = U["default"].Result, jT = U["default"].Input, zT = U["default"].Rule, VT = U["default"].Root, UT = U["default"].Node;
    });
  var Ls = v(function (GT, xc) {
    l();
    xc.exports = function (i, e, t, r, n) {
      for (e = e.split ? e.split(".") : e, r = 0; r < e.length; r++) i = i ? i[e[r]] : n;
      return i === n ? t : i;
    };
  });
  var Yi = v(function (Hi, kc) {
    l();
    "use strict";
    Hi.__esModule = !0;
    Hi["default"] = Ev;
    function _v(i) {
      for (var e = i.toLowerCase(), t = "", r = !1, n = 0; n < 6 && e[n] !== void 0; n++) {
        var a = e.charCodeAt(n),
          s = a >= 97 && a <= 102 || a >= 48 && a <= 57;
        if (r = a === 32, !s) break;
        t += e[n];
      }
      if (t.length !== 0) {
        var o = parseInt(t, 16),
          u = o >= 55296 && o <= 57343;
        return u || o === 0 || o > 1114111 ? ["\uFFFD", t.length + (r ? 1 : 0)] : [String.fromCodePoint(o), t.length + (r ? 1 : 0)];
      }
    }
    var Ov = /\\/;
    function Ev(i) {
      var e = Ov.test(i);
      if (!e) return i;
      for (var t = "", r = 0; r < i.length; r++) {
        if (i[r] === "\\") {
          var n = _v(i.slice(r + 1, r + 7));
          if (n !== void 0) {
            t += n[0], r += n[1];
            continue;
          }
          if (i[r + 1] === "\\") {
            t += "\\", r++;
            continue;
          }
          i.length === r + 1 && (t += i[r]);
          continue;
        }
        t += i[r];
      }
      return t;
    }
    kc.exports = Hi["default"];
  });
  var Cc = v(function (Qi, Sc) {
    l();
    "use strict";
    Qi.__esModule = !0;
    Qi["default"] = Tv;
    function Tv(i) {
      for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) t[r - 1] = arguments[r];
      for (; t.length > 0;) {
        var n = t.shift();
        if (!i[n]) return;
        i = i[n];
      }
      return i;
    }
    Sc.exports = Qi["default"];
  });
  var _c = v(function (Ji, Ac) {
    l();
    "use strict";
    Ji.__esModule = !0;
    Ji["default"] = Pv;
    function Pv(i) {
      for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) t[r - 1] = arguments[r];
      for (; t.length > 0;) {
        var n = t.shift();
        i[n] || (i[n] = {}), i = i[n];
      }
    }
    Ac.exports = Ji["default"];
  });
  var Ec = v(function (Xi, Oc) {
    l();
    "use strict";
    Xi.__esModule = !0;
    Xi["default"] = Dv;
    function Dv(i) {
      for (var e = "", t = i.indexOf("/*"), r = 0; t >= 0;) {
        e = e + i.slice(r, t);
        var n = i.indexOf("*/", t + 2);
        if (n < 0) return e;
        r = n + 2, t = i.indexOf("/*", r);
      }
      return e = e + i.slice(r), e;
    }
    Oc.exports = Xi["default"];
  });
  var _r = v(function (Re) {
    l();
    "use strict";
    Re.__esModule = !0;
    Re.unesc = Re.stripComments = Re.getProp = Re.ensureObject = void 0;
    var Iv = Ki(Yi());
    Re.unesc = Iv["default"];
    var qv = Ki(Cc());
    Re.getProp = qv["default"];
    var Rv = Ki(_c());
    Re.ensureObject = Rv["default"];
    var Mv = Ki(Ec());
    Re.stripComments = Mv["default"];
    function Ki(i) {
      return i && i.__esModule ? i : {
        "default": i
      };
    }
  });
  var Ue = v(function (Or, Dc) {
    l();
    "use strict";
    Or.__esModule = !0;
    Or["default"] = void 0;
    var Tc = _r();
    function Pc(i, e) {
      for (var t = 0; t < e.length; t++) {
        var r = e[t];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r);
      }
    }
    function Bv(i, e, t) {
      return e && Pc(i.prototype, e), t && Pc(i, t), Object.defineProperty(i, "prototype", {
        writable: !1
      }), i;
    }
    var Fv = function i(e, t) {
        if (_typeof(e) != "object" || e === null) return e;
        var r = new e.constructor();
        for (var n in e) if (!!e.hasOwnProperty(n)) {
          var a = e[n],
            s = _typeof(a);
          n === "parent" && s === "object" ? t && (r[n] = t) : a instanceof Array ? r[n] = a.map(function (o) {
            return i(o, r);
          }) : r[n] = i(a, r);
        }
        return r;
      },
      Nv = function () {
        function i(t) {
          t === void 0 && (t = {}), Object.assign(this, t), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
        }
        var e = i.prototype;
        return e.remove = function () {
          return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
        }, e.replaceWith = function () {
          if (this.parent) {
            for (var r in arguments) this.parent.insertBefore(this, arguments[r]);
            this.remove();
          }
          return this;
        }, e.next = function () {
          return this.parent.at(this.parent.index(this) + 1);
        }, e.prev = function () {
          return this.parent.at(this.parent.index(this) - 1);
        }, e.clone = function (r) {
          r === void 0 && (r = {});
          var n = Fv(this);
          for (var a in r) n[a] = r[a];
          return n;
        }, e.appendToPropertyAndEscape = function (r, n, a) {
          this.raws || (this.raws = {});
          var s = this[r],
            o = this.raws[r];
          this[r] = s + n, o || a !== n ? this.raws[r] = (o || s) + a : delete this.raws[r];
        }, e.setPropertyAndEscape = function (r, n, a) {
          this.raws || (this.raws = {}), this[r] = n, this.raws[r] = a;
        }, e.setPropertyWithoutEscape = function (r, n) {
          this[r] = n, this.raws && delete this.raws[r];
        }, e.isAtPosition = function (r, n) {
          if (this.source && this.source.start && this.source.end) return !(this.source.start.line > r || this.source.end.line < r || this.source.start.line === r && this.source.start.column > n || this.source.end.line === r && this.source.end.column < n);
        }, e.stringifyProperty = function (r) {
          return this.raws && this.raws[r] || this[r];
        }, e.valueToString = function () {
          return String(this.stringifyProperty("value"));
        }, e.toString = function () {
          return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
        }, Bv(i, [{
          key: "rawSpaceBefore",
          get: function get() {
            var r = this.raws && this.raws.spaces && this.raws.spaces.before;
            return r === void 0 && (r = this.spaces && this.spaces.before), r || "";
          },
          set: function set(r) {
            (0, Tc.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = r;
          }
        }, {
          key: "rawSpaceAfter",
          get: function get() {
            var r = this.raws && this.raws.spaces && this.raws.spaces.after;
            return r === void 0 && (r = this.spaces.after), r || "";
          },
          set: function set(r) {
            (0, Tc.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = r;
          }
        }]), i;
      }();
    Or["default"] = Nv;
    Dc.exports = Or["default"];
  });
  var ne = v(function (W) {
    l();
    "use strict";
    W.__esModule = !0;
    W.UNIVERSAL = W.TAG = W.STRING = W.SELECTOR = W.ROOT = W.PSEUDO = W.NESTING = W.ID = W.COMMENT = W.COMBINATOR = W.CLASS = W.ATTRIBUTE = void 0;
    var Lv = "tag";
    W.TAG = Lv;
    var $v = "string";
    W.STRING = $v;
    var jv = "selector";
    W.SELECTOR = jv;
    var zv = "root";
    W.ROOT = zv;
    var Vv = "pseudo";
    W.PSEUDO = Vv;
    var Uv = "nesting";
    W.NESTING = Uv;
    var Wv = "id";
    W.ID = Wv;
    var Gv = "comment";
    W.COMMENT = Gv;
    var Hv = "combinator";
    W.COMBINATOR = Hv;
    var Yv = "class";
    W.CLASS = Yv;
    var Qv = "attribute";
    W.ATTRIBUTE = Qv;
    var Jv = "universal";
    W.UNIVERSAL = Jv;
  });
  var Zi = v(function (Er, Mc) {
    l();
    "use strict";
    Er.__esModule = !0;
    Er["default"] = void 0;
    var Xv = Zv(Ue()),
      We = Kv(ne());
    function Ic(i) {
      if (typeof WeakMap != "function") return null;
      var e = new WeakMap(),
        t = new WeakMap();
      return (Ic = function Ic(n) {
        return n ? t : e;
      })(i);
    }
    function Kv(i, e) {
      if (!e && i && i.__esModule) return i;
      if (i === null || _typeof(i) != "object" && typeof i != "function") return {
        "default": i
      };
      var t = Ic(e);
      if (t && t.has(i)) return t.get(i);
      var r = {},
        n = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var a in i) if (a !== "default" && Object.prototype.hasOwnProperty.call(i, a)) {
        var s = n ? Object.getOwnPropertyDescriptor(i, a) : null;
        s && (s.get || s.set) ? Object.defineProperty(r, a, s) : r[a] = i[a];
      }
      return r["default"] = i, t && t.set(i, r), r;
    }
    function Zv(i) {
      return i && i.__esModule ? i : {
        "default": i
      };
    }
    function ex(i, e) {
      var t = typeof Symbol != "undefined" && i[Symbol.iterator] || i["@@iterator"];
      if (t) return (t = t.call(i)).next.bind(t);
      if (Array.isArray(i) || (t = tx(i)) || e && i && typeof i.length == "number") {
        t && (i = t);
        var r = 0;
        return function () {
          return r >= i.length ? {
            done: !0
          } : {
            done: !1,
            value: i[r++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function tx(i, e) {
      if (!!i) {
        if (typeof i == "string") return qc(i, e);
        var t = Object.prototype.toString.call(i).slice(8, -1);
        if (t === "Object" && i.constructor && (t = i.constructor.name), t === "Map" || t === "Set") return Array.from(i);
        if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return qc(i, e);
      }
    }
    function qc(i, e) {
      (e == null || e > i.length) && (e = i.length);
      for (var t = 0, r = new Array(e); t < e; t++) r[t] = i[t];
      return r;
    }
    function Rc(i, e) {
      for (var t = 0; t < e.length; t++) {
        var r = e[t];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r);
      }
    }
    function rx(i, e, t) {
      return e && Rc(i.prototype, e), t && Rc(i, t), Object.defineProperty(i, "prototype", {
        writable: !1
      }), i;
    }
    function ix(i, e) {
      i.prototype = Object.create(e.prototype), i.prototype.constructor = i, $s(i, e);
    }
    function $s(i, e) {
      return $s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, n) {
        return r.__proto__ = n, r;
      }, $s(i, e);
    }
    var nx = function (i) {
      ix(e, i);
      function e(r) {
        var n;
        return n = i.call(this, r) || this, n.nodes || (n.nodes = []), n;
      }
      var t = e.prototype;
      return t.append = function (n) {
        return n.parent = this, this.nodes.push(n), this;
      }, t.prepend = function (n) {
        return n.parent = this, this.nodes.unshift(n), this;
      }, t.at = function (n) {
        return this.nodes[n];
      }, t.index = function (n) {
        return typeof n == "number" ? n : this.nodes.indexOf(n);
      }, t.removeChild = function (n) {
        n = this.index(n), this.at(n).parent = void 0, this.nodes.splice(n, 1);
        var a;
        for (var s in this.indexes) a = this.indexes[s], a >= n && (this.indexes[s] = a - 1);
        return this;
      }, t.removeAll = function () {
        for (var n = ex(this.nodes), a; !(a = n()).done;) {
          var s = a.value;
          s.parent = void 0;
        }
        return this.nodes = [], this;
      }, t.empty = function () {
        return this.removeAll();
      }, t.insertAfter = function (n, a) {
        a.parent = this;
        var s = this.index(n);
        this.nodes.splice(s + 1, 0, a), a.parent = this;
        var o;
        for (var u in this.indexes) o = this.indexes[u], s <= o && (this.indexes[u] = o + 1);
        return this;
      }, t.insertBefore = function (n, a) {
        a.parent = this;
        var s = this.index(n);
        this.nodes.splice(s, 0, a), a.parent = this;
        var o;
        for (var u in this.indexes) o = this.indexes[u], o <= s && (this.indexes[u] = o + 1);
        return this;
      }, t._findChildAtPosition = function (n, a) {
        var s = void 0;
        return this.each(function (o) {
          if (o.atPosition) {
            var u = o.atPosition(n, a);
            if (u) return s = u, !1;
          } else if (o.isAtPosition(n, a)) return s = o, !1;
        }), s;
      }, t.atPosition = function (n, a) {
        if (this.isAtPosition(n, a)) return this._findChildAtPosition(n, a) || this;
      }, t._inferEndPosition = function () {
        this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
      }, t.each = function (n) {
        this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
        var a = this.lastEach;
        if (this.indexes[a] = 0, !!this.length) {
          for (var s, o; this.indexes[a] < this.length && (s = this.indexes[a], o = n(this.at(s), s), o !== !1);) this.indexes[a] += 1;
          if (delete this.indexes[a], o === !1) return !1;
        }
      }, t.walk = function (n) {
        return this.each(function (a, s) {
          var o = n(a, s);
          if (o !== !1 && a.length && (o = a.walk(n)), o === !1) return !1;
        });
      }, t.walkAttributes = function (n) {
        var a = this;
        return this.walk(function (s) {
          if (s.type === We.ATTRIBUTE) return n.call(a, s);
        });
      }, t.walkClasses = function (n) {
        var a = this;
        return this.walk(function (s) {
          if (s.type === We.CLASS) return n.call(a, s);
        });
      }, t.walkCombinators = function (n) {
        var a = this;
        return this.walk(function (s) {
          if (s.type === We.COMBINATOR) return n.call(a, s);
        });
      }, t.walkComments = function (n) {
        var a = this;
        return this.walk(function (s) {
          if (s.type === We.COMMENT) return n.call(a, s);
        });
      }, t.walkIds = function (n) {
        var a = this;
        return this.walk(function (s) {
          if (s.type === We.ID) return n.call(a, s);
        });
      }, t.walkNesting = function (n) {
        var a = this;
        return this.walk(function (s) {
          if (s.type === We.NESTING) return n.call(a, s);
        });
      }, t.walkPseudos = function (n) {
        var a = this;
        return this.walk(function (s) {
          if (s.type === We.PSEUDO) return n.call(a, s);
        });
      }, t.walkTags = function (n) {
        var a = this;
        return this.walk(function (s) {
          if (s.type === We.TAG) return n.call(a, s);
        });
      }, t.walkUniversals = function (n) {
        var a = this;
        return this.walk(function (s) {
          if (s.type === We.UNIVERSAL) return n.call(a, s);
        });
      }, t.split = function (n) {
        var a = this,
          s = [];
        return this.reduce(function (o, u, c) {
          var f = n.call(a, u);
          return s.push(u), f ? (o.push(s), s = []) : c === a.length - 1 && o.push(s), o;
        }, []);
      }, t.map = function (n) {
        return this.nodes.map(n);
      }, t.reduce = function (n, a) {
        return this.nodes.reduce(n, a);
      }, t.every = function (n) {
        return this.nodes.every(n);
      }, t.some = function (n) {
        return this.nodes.some(n);
      }, t.filter = function (n) {
        return this.nodes.filter(n);
      }, t.sort = function (n) {
        return this.nodes.sort(n);
      }, t.toString = function () {
        return this.map(String).join("");
      }, rx(e, [{
        key: "first",
        get: function get() {
          return this.at(0);
        }
      }, {
        key: "last",
        get: function get() {
          return this.at(this.length - 1);
        }
      }, {
        key: "length",
        get: function get() {
          return this.nodes.length;
        }
      }]), e;
    }(Xv["default"]);
    Er["default"] = nx;
    Mc.exports = Er["default"];
  });
  var zs = v(function (Tr, Fc) {
    l();
    "use strict";
    Tr.__esModule = !0;
    Tr["default"] = void 0;
    var sx = ox(Zi()),
      ax = ne();
    function ox(i) {
      return i && i.__esModule ? i : {
        "default": i
      };
    }
    function Bc(i, e) {
      for (var t = 0; t < e.length; t++) {
        var r = e[t];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r);
      }
    }
    function lx(i, e, t) {
      return e && Bc(i.prototype, e), t && Bc(i, t), Object.defineProperty(i, "prototype", {
        writable: !1
      }), i;
    }
    function ux(i, e) {
      i.prototype = Object.create(e.prototype), i.prototype.constructor = i, js(i, e);
    }
    function js(i, e) {
      return js = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, n) {
        return r.__proto__ = n, r;
      }, js(i, e);
    }
    var fx = function (i) {
      ux(e, i);
      function e(r) {
        var n;
        return n = i.call(this, r) || this, n.type = ax.ROOT, n;
      }
      var t = e.prototype;
      return t.toString = function () {
        var n = this.reduce(function (a, s) {
          return a.push(String(s)), a;
        }, []).join(",");
        return this.trailingComma ? n + "," : n;
      }, t.error = function (n, a) {
        return this._error ? this._error(n, a) : new Error(n);
      }, lx(e, [{
        key: "errorGenerator",
        set: function set(n) {
          this._error = n;
        }
      }]), e;
    }(sx["default"]);
    Tr["default"] = fx;
    Fc.exports = Tr["default"];
  });
  var Us = v(function (Pr, Nc) {
    l();
    "use strict";
    Pr.__esModule = !0;
    Pr["default"] = void 0;
    var cx = dx(Zi()),
      px = ne();
    function dx(i) {
      return i && i.__esModule ? i : {
        "default": i
      };
    }
    function hx(i, e) {
      i.prototype = Object.create(e.prototype), i.prototype.constructor = i, Vs(i, e);
    }
    function Vs(i, e) {
      return Vs = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, n) {
        return r.__proto__ = n, r;
      }, Vs(i, e);
    }
    var mx = function (i) {
      hx(e, i);
      function e(t) {
        var r;
        return r = i.call(this, t) || this, r.type = px.SELECTOR, r;
      }
      return e;
    }(cx["default"]);
    Pr["default"] = mx;
    Nc.exports = Pr["default"];
  });
  var en = v(function (QT, Lc) {
    l();
    "use strict";
    var gx = {},
      yx = gx.hasOwnProperty,
      wx = function wx(e, t) {
        if (!e) return t;
        var r = {};
        for (var n in t) r[n] = yx.call(e, n) ? e[n] : t[n];
        return r;
      },
      bx = /[ -,\.\/:-@\[-\^`\{-~]/,
      vx = /[ -,\.\/:-@\[\]\^`\{-~]/,
      xx = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g,
      Ws = function i(e, t) {
        t = wx(t, i.options), t.quotes != "single" && t.quotes != "double" && (t.quotes = "single");
        for (var r = t.quotes == "double" ? '"' : "'", n = t.isIdentifier, a = e.charAt(0), s = "", o = 0, u = e.length; o < u;) {
          var c = e.charAt(o++),
            f = c.charCodeAt(),
            d = void 0;
          if (f < 32 || f > 126) {
            if (f >= 55296 && f <= 56319 && o < u) {
              var p = e.charCodeAt(o++);
              (p & 64512) == 56320 ? f = ((f & 1023) << 10) + (p & 1023) + 65536 : o--;
            }
            d = "\\" + f.toString(16).toUpperCase() + " ";
          } else t.escapeEverything ? bx.test(c) ? d = "\\" + c : d = "\\" + f.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(c) ? d = "\\" + f.toString(16).toUpperCase() + " " : c == "\\" || !n && (c == '"' && r == c || c == "'" && r == c) || n && vx.test(c) ? d = "\\" + c : d = c;
          s += d;
        }
        return n && (/^-[-\d]/.test(s) ? s = "\\-" + s.slice(1) : /\d/.test(a) && (s = "\\3" + a + " " + s.slice(1))), s = s.replace(xx, function (m, b, x) {
          return b && b.length % 2 ? m : (b || "") + x;
        }), !n && t.wrap ? r + s + r : s;
      };
    Ws.options = {
      escapeEverything: !1,
      isIdentifier: !1,
      quotes: "single",
      wrap: !1
    };
    Ws.version = "3.0.0";
    Lc.exports = Ws;
  });
  var Hs = v(function (Dr, zc) {
    l();
    "use strict";
    Dr.__esModule = !0;
    Dr["default"] = void 0;
    var kx = $c(en()),
      Sx = _r(),
      Cx = $c(Ue()),
      Ax = ne();
    function $c(i) {
      return i && i.__esModule ? i : {
        "default": i
      };
    }
    function jc(i, e) {
      for (var t = 0; t < e.length; t++) {
        var r = e[t];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r);
      }
    }
    function _x(i, e, t) {
      return e && jc(i.prototype, e), t && jc(i, t), Object.defineProperty(i, "prototype", {
        writable: !1
      }), i;
    }
    function Ox(i, e) {
      i.prototype = Object.create(e.prototype), i.prototype.constructor = i, Gs(i, e);
    }
    function Gs(i, e) {
      return Gs = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, n) {
        return r.__proto__ = n, r;
      }, Gs(i, e);
    }
    var Ex = function (i) {
      Ox(e, i);
      function e(r) {
        var n;
        return n = i.call(this, r) || this, n.type = Ax.CLASS, n._constructed = !0, n;
      }
      var t = e.prototype;
      return t.valueToString = function () {
        return "." + i.prototype.valueToString.call(this);
      }, _x(e, [{
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(n) {
          if (this._constructed) {
            var a = (0, kx["default"])(n, {
              isIdentifier: !0
            });
            a !== n ? ((0, Sx.ensureObject)(this, "raws"), this.raws.value = a) : this.raws && delete this.raws.value;
          }
          this._value = n;
        }
      }]), e;
    }(Cx["default"]);
    Dr["default"] = Ex;
    zc.exports = Dr["default"];
  });
  var Qs = v(function (Ir, Vc) {
    l();
    "use strict";
    Ir.__esModule = !0;
    Ir["default"] = void 0;
    var Tx = Dx(Ue()),
      Px = ne();
    function Dx(i) {
      return i && i.__esModule ? i : {
        "default": i
      };
    }
    function Ix(i, e) {
      i.prototype = Object.create(e.prototype), i.prototype.constructor = i, Ys(i, e);
    }
    function Ys(i, e) {
      return Ys = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, n) {
        return r.__proto__ = n, r;
      }, Ys(i, e);
    }
    var qx = function (i) {
      Ix(e, i);
      function e(t) {
        var r;
        return r = i.call(this, t) || this, r.type = Px.COMMENT, r;
      }
      return e;
    }(Tx["default"]);
    Ir["default"] = qx;
    Vc.exports = Ir["default"];
  });
  var Xs = v(function (qr, Uc) {
    l();
    "use strict";
    qr.__esModule = !0;
    qr["default"] = void 0;
    var Rx = Bx(Ue()),
      Mx = ne();
    function Bx(i) {
      return i && i.__esModule ? i : {
        "default": i
      };
    }
    function Fx(i, e) {
      i.prototype = Object.create(e.prototype), i.prototype.constructor = i, Js(i, e);
    }
    function Js(i, e) {
      return Js = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, n) {
        return r.__proto__ = n, r;
      }, Js(i, e);
    }
    var Nx = function (i) {
      Fx(e, i);
      function e(r) {
        var n;
        return n = i.call(this, r) || this, n.type = Mx.ID, n;
      }
      var t = e.prototype;
      return t.valueToString = function () {
        return "#" + i.prototype.valueToString.call(this);
      }, e;
    }(Rx["default"]);
    qr["default"] = Nx;
    Uc.exports = qr["default"];
  });
  var tn = v(function (Rr, Hc) {
    l();
    "use strict";
    Rr.__esModule = !0;
    Rr["default"] = void 0;
    var Lx = Wc(en()),
      $x = _r(),
      jx = Wc(Ue());
    function Wc(i) {
      return i && i.__esModule ? i : {
        "default": i
      };
    }
    function Gc(i, e) {
      for (var t = 0; t < e.length; t++) {
        var r = e[t];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r);
      }
    }
    function zx(i, e, t) {
      return e && Gc(i.prototype, e), t && Gc(i, t), Object.defineProperty(i, "prototype", {
        writable: !1
      }), i;
    }
    function Vx(i, e) {
      i.prototype = Object.create(e.prototype), i.prototype.constructor = i, Ks(i, e);
    }
    function Ks(i, e) {
      return Ks = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, n) {
        return r.__proto__ = n, r;
      }, Ks(i, e);
    }
    var Ux = function (i) {
      Vx(e, i);
      function e() {
        return i.apply(this, arguments) || this;
      }
      var t = e.prototype;
      return t.qualifiedName = function (n) {
        return this.namespace ? this.namespaceString + "|" + n : n;
      }, t.valueToString = function () {
        return this.qualifiedName(i.prototype.valueToString.call(this));
      }, zx(e, [{
        key: "namespace",
        get: function get() {
          return this._namespace;
        },
        set: function set(n) {
          if (n === !0 || n === "*" || n === "&") {
            this._namespace = n, this.raws && delete this.raws.namespace;
            return;
          }
          var a = (0, Lx["default"])(n, {
            isIdentifier: !0
          });
          this._namespace = n, a !== n ? ((0, $x.ensureObject)(this, "raws"), this.raws.namespace = a) : this.raws && delete this.raws.namespace;
        }
      }, {
        key: "ns",
        get: function get() {
          return this._namespace;
        },
        set: function set(n) {
          this.namespace = n;
        }
      }, {
        key: "namespaceString",
        get: function get() {
          if (this.namespace) {
            var n = this.stringifyProperty("namespace");
            return n === !0 ? "" : n;
          } else return "";
        }
      }]), e;
    }(jx["default"]);
    Rr["default"] = Ux;
    Hc.exports = Rr["default"];
  });
  var ea = v(function (Mr, Yc) {
    l();
    "use strict";
    Mr.__esModule = !0;
    Mr["default"] = void 0;
    var Wx = Hx(tn()),
      Gx = ne();
    function Hx(i) {
      return i && i.__esModule ? i : {
        "default": i
      };
    }
    function Yx(i, e) {
      i.prototype = Object.create(e.prototype), i.prototype.constructor = i, Zs(i, e);
    }
    function Zs(i, e) {
      return Zs = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, n) {
        return r.__proto__ = n, r;
      }, Zs(i, e);
    }
    var Qx = function (i) {
      Yx(e, i);
      function e(t) {
        var r;
        return r = i.call(this, t) || this, r.type = Gx.TAG, r;
      }
      return e;
    }(Wx["default"]);
    Mr["default"] = Qx;
    Yc.exports = Mr["default"];
  });
  var ra = v(function (Br, Qc) {
    l();
    "use strict";
    Br.__esModule = !0;
    Br["default"] = void 0;
    var Jx = Kx(Ue()),
      Xx = ne();
    function Kx(i) {
      return i && i.__esModule ? i : {
        "default": i
      };
    }
    function Zx(i, e) {
      i.prototype = Object.create(e.prototype), i.prototype.constructor = i, ta(i, e);
    }
    function ta(i, e) {
      return ta = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, n) {
        return r.__proto__ = n, r;
      }, ta(i, e);
    }
    var e1 = function (i) {
      Zx(e, i);
      function e(t) {
        var r;
        return r = i.call(this, t) || this, r.type = Xx.STRING, r;
      }
      return e;
    }(Jx["default"]);
    Br["default"] = e1;
    Qc.exports = Br["default"];
  });
  var na = v(function (Fr, Jc) {
    l();
    "use strict";
    Fr.__esModule = !0;
    Fr["default"] = void 0;
    var t1 = i1(Zi()),
      r1 = ne();
    function i1(i) {
      return i && i.__esModule ? i : {
        "default": i
      };
    }
    function n1(i, e) {
      i.prototype = Object.create(e.prototype), i.prototype.constructor = i, ia(i, e);
    }
    function ia(i, e) {
      return ia = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, n) {
        return r.__proto__ = n, r;
      }, ia(i, e);
    }
    var s1 = function (i) {
      n1(e, i);
      function e(r) {
        var n;
        return n = i.call(this, r) || this, n.type = r1.PSEUDO, n;
      }
      var t = e.prototype;
      return t.toString = function () {
        var n = this.length ? "(" + this.map(String).join(",") + ")" : "";
        return [this.rawSpaceBefore, this.stringifyProperty("value"), n, this.rawSpaceAfter].join("");
      }, e;
    }(t1["default"]);
    Fr["default"] = s1;
    Jc.exports = Fr["default"];
  });
  var Xc = {};
  Ae(Xc, {
    deprecate: function deprecate() {
      return a1;
    }
  });
  function a1(i) {
    return i;
  }
  var Kc = C(function () {
    l();
  });
  var ep = v(function (JT, Zc) {
    l();
    Zc.exports = (Kc(), Xc).deprecate;
  });
  var fa = v(function ($r) {
    l();
    "use strict";
    $r.__esModule = !0;
    $r["default"] = void 0;
    $r.unescapeValue = la;
    var Nr = aa(en()),
      o1 = aa(Yi()),
      l1 = aa(tn()),
      u1 = ne(),
      sa;
    function aa(i) {
      return i && i.__esModule ? i : {
        "default": i
      };
    }
    function tp(i, e) {
      for (var t = 0; t < e.length; t++) {
        var r = e[t];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r);
      }
    }
    function f1(i, e, t) {
      return e && tp(i.prototype, e), t && tp(i, t), Object.defineProperty(i, "prototype", {
        writable: !1
      }), i;
    }
    function c1(i, e) {
      i.prototype = Object.create(e.prototype), i.prototype.constructor = i, oa(i, e);
    }
    function oa(i, e) {
      return oa = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, n) {
        return r.__proto__ = n, r;
      }, oa(i, e);
    }
    var Lr = ep(),
      p1 = /^('|")([^]*)\1$/,
      d1 = Lr(function () {}, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."),
      h1 = Lr(function () {}, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."),
      m1 = Lr(function () {}, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
    function la(i) {
      var e = !1,
        t = null,
        r = i,
        n = r.match(p1);
      return n && (t = n[1], r = n[2]), r = (0, o1["default"])(r), r !== i && (e = !0), {
        deprecatedUsage: e,
        unescaped: r,
        quoteMark: t
      };
    }
    function g1(i) {
      if (i.quoteMark !== void 0 || i.value === void 0) return i;
      m1();
      var e = la(i.value),
        t = e.quoteMark,
        r = e.unescaped;
      return i.raws || (i.raws = {}), i.raws.value === void 0 && (i.raws.value = i.value), i.value = r, i.quoteMark = t, i;
    }
    var rn = function (i) {
      c1(e, i);
      function e(r) {
        var n;
        return r === void 0 && (r = {}), n = i.call(this, g1(r)) || this, n.type = u1.ATTRIBUTE, n.raws = n.raws || {}, Object.defineProperty(n.raws, "unquoted", {
          get: Lr(function () {
            return n.value;
          }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
          set: Lr(function () {
            return n.value;
          }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
        }), n._constructed = !0, n;
      }
      var t = e.prototype;
      return t.getQuotedValue = function (n) {
        n === void 0 && (n = {});
        var a = this._determineQuoteMark(n),
          s = ua[a],
          o = (0, Nr["default"])(this._value, s);
        return o;
      }, t._determineQuoteMark = function (n) {
        return n.smart ? this.smartQuoteMark(n) : this.preferredQuoteMark(n);
      }, t.setValue = function (n, a) {
        a === void 0 && (a = {}), this._value = n, this._quoteMark = this._determineQuoteMark(a), this._syncRawValue();
      }, t.smartQuoteMark = function (n) {
        var a = this.value,
          s = a.replace(/[^']/g, "").length,
          o = a.replace(/[^"]/g, "").length;
        if (s + o === 0) {
          var u = (0, Nr["default"])(a, {
            isIdentifier: !0
          });
          if (u === a) return e.NO_QUOTE;
          var c = this.preferredQuoteMark(n);
          if (c === e.NO_QUOTE) {
            var f = this.quoteMark || n.quoteMark || e.DOUBLE_QUOTE,
              d = ua[f],
              p = (0, Nr["default"])(a, d);
            if (p.length < u.length) return f;
          }
          return c;
        } else return o === s ? this.preferredQuoteMark(n) : o < s ? e.DOUBLE_QUOTE : e.SINGLE_QUOTE;
      }, t.preferredQuoteMark = function (n) {
        var a = n.preferCurrentQuoteMark ? this.quoteMark : n.quoteMark;
        return a === void 0 && (a = n.preferCurrentQuoteMark ? n.quoteMark : this.quoteMark), a === void 0 && (a = e.DOUBLE_QUOTE), a;
      }, t._syncRawValue = function () {
        var n = (0, Nr["default"])(this._value, ua[this.quoteMark]);
        n === this._value ? this.raws && delete this.raws.value : this.raws.value = n;
      }, t._handleEscapes = function (n, a) {
        if (this._constructed) {
          var s = (0, Nr["default"])(a, {
            isIdentifier: !0
          });
          s !== a ? this.raws[n] = s : delete this.raws[n];
        }
      }, t._spacesFor = function (n) {
        var a = {
            before: "",
            after: ""
          },
          s = this.spaces[n] || {},
          o = this.raws.spaces && this.raws.spaces[n] || {};
        return Object.assign(a, s, o);
      }, t._stringFor = function (n, a, s) {
        a === void 0 && (a = n), s === void 0 && (s = rp);
        var o = this._spacesFor(a);
        return s(this.stringifyProperty(n), o);
      }, t.offsetOf = function (n) {
        var a = 1,
          s = this._spacesFor("attribute");
        if (a += s.before.length, n === "namespace" || n === "ns") return this.namespace ? a : -1;
        if (n === "attributeNS" || (a += this.namespaceString.length, this.namespace && (a += 1), n === "attribute")) return a;
        a += this.stringifyProperty("attribute").length, a += s.after.length;
        var o = this._spacesFor("operator");
        a += o.before.length;
        var u = this.stringifyProperty("operator");
        if (n === "operator") return u ? a : -1;
        a += u.length, a += o.after.length;
        var c = this._spacesFor("value");
        a += c.before.length;
        var f = this.stringifyProperty("value");
        if (n === "value") return f ? a : -1;
        a += f.length, a += c.after.length;
        var d = this._spacesFor("insensitive");
        return a += d.before.length, n === "insensitive" && this.insensitive ? a : -1;
      }, t.toString = function () {
        var n = this,
          a = [this.rawSpaceBefore, "["];
        return a.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (a.push(this._stringFor("operator")), a.push(this._stringFor("value")), a.push(this._stringFor("insensitiveFlag", "insensitive", function (s, o) {
          return s.length > 0 && !n.quoted && o.before.length === 0 && !(n.spaces.value && n.spaces.value.after) && (o.before = " "), rp(s, o);
        }))), a.push("]"), a.push(this.rawSpaceAfter), a.join("");
      }, f1(e, [{
        key: "quoted",
        get: function get() {
          var n = this.quoteMark;
          return n === "'" || n === '"';
        },
        set: function set(n) {
          h1();
        }
      }, {
        key: "quoteMark",
        get: function get() {
          return this._quoteMark;
        },
        set: function set(n) {
          if (!this._constructed) {
            this._quoteMark = n;
            return;
          }
          this._quoteMark !== n && (this._quoteMark = n, this._syncRawValue());
        }
      }, {
        key: "qualifiedAttribute",
        get: function get() {
          return this.qualifiedName(this.raws.attribute || this.attribute);
        }
      }, {
        key: "insensitiveFlag",
        get: function get() {
          return this.insensitive ? "i" : "";
        }
      }, {
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(n) {
          if (this._constructed) {
            var a = la(n),
              s = a.deprecatedUsage,
              o = a.unescaped,
              u = a.quoteMark;
            if (s && d1(), o === this._value && u === this._quoteMark) return;
            this._value = o, this._quoteMark = u, this._syncRawValue();
          } else this._value = n;
        }
      }, {
        key: "insensitive",
        get: function get() {
          return this._insensitive;
        },
        set: function set(n) {
          n || (this._insensitive = !1, this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i") && (this.raws.insensitiveFlag = void 0)), this._insensitive = n;
        }
      }, {
        key: "attribute",
        get: function get() {
          return this._attribute;
        },
        set: function set(n) {
          this._handleEscapes("attribute", n), this._attribute = n;
        }
      }]), e;
    }(l1["default"]);
    $r["default"] = rn;
    rn.NO_QUOTE = null;
    rn.SINGLE_QUOTE = "'";
    rn.DOUBLE_QUOTE = '"';
    var ua = (sa = {
      "'": {
        quotes: "single",
        wrap: !0
      },
      '"': {
        quotes: "double",
        wrap: !0
      }
    }, sa[null] = {
      isIdentifier: !0
    }, sa);
    function rp(i, e) {
      return "" + e.before + i + e.after;
    }
  });
  var pa = v(function (jr, ip) {
    l();
    "use strict";
    jr.__esModule = !0;
    jr["default"] = void 0;
    var y1 = b1(tn()),
      w1 = ne();
    function b1(i) {
      return i && i.__esModule ? i : {
        "default": i
      };
    }
    function v1(i, e) {
      i.prototype = Object.create(e.prototype), i.prototype.constructor = i, ca(i, e);
    }
    function ca(i, e) {
      return ca = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, n) {
        return r.__proto__ = n, r;
      }, ca(i, e);
    }
    var x1 = function (i) {
      v1(e, i);
      function e(t) {
        var r;
        return r = i.call(this, t) || this, r.type = w1.UNIVERSAL, r.value = "*", r;
      }
      return e;
    }(y1["default"]);
    jr["default"] = x1;
    ip.exports = jr["default"];
  });
  var ha = v(function (zr, np) {
    l();
    "use strict";
    zr.__esModule = !0;
    zr["default"] = void 0;
    var k1 = C1(Ue()),
      S1 = ne();
    function C1(i) {
      return i && i.__esModule ? i : {
        "default": i
      };
    }
    function A1(i, e) {
      i.prototype = Object.create(e.prototype), i.prototype.constructor = i, da(i, e);
    }
    function da(i, e) {
      return da = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, n) {
        return r.__proto__ = n, r;
      }, da(i, e);
    }
    var _1 = function (i) {
      A1(e, i);
      function e(t) {
        var r;
        return r = i.call(this, t) || this, r.type = S1.COMBINATOR, r;
      }
      return e;
    }(k1["default"]);
    zr["default"] = _1;
    np.exports = zr["default"];
  });
  var ga = v(function (Vr, sp) {
    l();
    "use strict";
    Vr.__esModule = !0;
    Vr["default"] = void 0;
    var O1 = T1(Ue()),
      E1 = ne();
    function T1(i) {
      return i && i.__esModule ? i : {
        "default": i
      };
    }
    function P1(i, e) {
      i.prototype = Object.create(e.prototype), i.prototype.constructor = i, ma(i, e);
    }
    function ma(i, e) {
      return ma = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, n) {
        return r.__proto__ = n, r;
      }, ma(i, e);
    }
    var D1 = function (i) {
      P1(e, i);
      function e(t) {
        var r;
        return r = i.call(this, t) || this, r.type = E1.NESTING, r.value = "&", r;
      }
      return e;
    }(O1["default"]);
    Vr["default"] = D1;
    sp.exports = Vr["default"];
  });
  var op = v(function (nn, ap) {
    l();
    "use strict";
    nn.__esModule = !0;
    nn["default"] = I1;
    function I1(i) {
      return i.sort(function (e, t) {
        return e - t;
      });
    }
    ap.exports = nn["default"];
  });
  var ya = v(function (D) {
    l();
    "use strict";
    D.__esModule = !0;
    D.word = D.tilde = D.tab = D.str = D.space = D.slash = D.singleQuote = D.semicolon = D.plus = D.pipe = D.openSquare = D.openParenthesis = D.newline = D.greaterThan = D.feed = D.equals = D.doubleQuote = D.dollar = D.cr = D.comment = D.comma = D.combinator = D.colon = D.closeSquare = D.closeParenthesis = D.caret = D.bang = D.backslash = D.at = D.asterisk = D.ampersand = void 0;
    var q1 = 38;
    D.ampersand = q1;
    var R1 = 42;
    D.asterisk = R1;
    var M1 = 64;
    D.at = M1;
    var B1 = 44;
    D.comma = B1;
    var F1 = 58;
    D.colon = F1;
    var N1 = 59;
    D.semicolon = N1;
    var L1 = 40;
    D.openParenthesis = L1;
    var $1 = 41;
    D.closeParenthesis = $1;
    var j1 = 91;
    D.openSquare = j1;
    var z1 = 93;
    D.closeSquare = z1;
    var V1 = 36;
    D.dollar = V1;
    var U1 = 126;
    D.tilde = U1;
    var W1 = 94;
    D.caret = W1;
    var G1 = 43;
    D.plus = G1;
    var H1 = 61;
    D.equals = H1;
    var Y1 = 124;
    D.pipe = Y1;
    var Q1 = 62;
    D.greaterThan = Q1;
    var J1 = 32;
    D.space = J1;
    var lp = 39;
    D.singleQuote = lp;
    var X1 = 34;
    D.doubleQuote = X1;
    var K1 = 47;
    D.slash = K1;
    var Z1 = 33;
    D.bang = Z1;
    var ek = 92;
    D.backslash = ek;
    var tk = 13;
    D.cr = tk;
    var rk = 12;
    D.feed = rk;
    var ik = 10;
    D.newline = ik;
    var nk = 9;
    D.tab = nk;
    var sk = lp;
    D.str = sk;
    var ak = -1;
    D.comment = ak;
    var ok = -2;
    D.word = ok;
    var lk = -3;
    D.combinator = lk;
  });
  var cp = v(function (Ur) {
    l();
    "use strict";
    Ur.__esModule = !0;
    Ur.FIELDS = void 0;
    Ur["default"] = mk;
    var O = uk(ya()),
      It,
      V;
    function up(i) {
      if (typeof WeakMap != "function") return null;
      var e = new WeakMap(),
        t = new WeakMap();
      return (up = function up(n) {
        return n ? t : e;
      })(i);
    }
    function uk(i, e) {
      if (!e && i && i.__esModule) return i;
      if (i === null || _typeof(i) != "object" && typeof i != "function") return {
        "default": i
      };
      var t = up(e);
      if (t && t.has(i)) return t.get(i);
      var r = {},
        n = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var a in i) if (a !== "default" && Object.prototype.hasOwnProperty.call(i, a)) {
        var s = n ? Object.getOwnPropertyDescriptor(i, a) : null;
        s && (s.get || s.set) ? Object.defineProperty(r, a, s) : r[a] = i[a];
      }
      return r["default"] = i, t && t.set(i, r), r;
    }
    var fk = (It = {}, It[O.tab] = !0, It[O.newline] = !0, It[O.cr] = !0, It[O.feed] = !0, It),
      ck = (V = {}, V[O.space] = !0, V[O.tab] = !0, V[O.newline] = !0, V[O.cr] = !0, V[O.feed] = !0, V[O.ampersand] = !0, V[O.asterisk] = !0, V[O.bang] = !0, V[O.comma] = !0, V[O.colon] = !0, V[O.semicolon] = !0, V[O.openParenthesis] = !0, V[O.closeParenthesis] = !0, V[O.openSquare] = !0, V[O.closeSquare] = !0, V[O.singleQuote] = !0, V[O.doubleQuote] = !0, V[O.plus] = !0, V[O.pipe] = !0, V[O.tilde] = !0, V[O.greaterThan] = !0, V[O.equals] = !0, V[O.dollar] = !0, V[O.caret] = !0, V[O.slash] = !0, V),
      wa = {},
      fp = "0123456789abcdefABCDEF";
    for (sn = 0; sn < fp.length; sn++) wa[fp.charCodeAt(sn)] = !0;
    var sn;
    function pk(i, e) {
      var t = e,
        r;
      do {
        if (r = i.charCodeAt(t), ck[r]) return t - 1;
        r === O.backslash ? t = dk(i, t) + 1 : t++;
      } while (t < i.length);
      return t - 1;
    }
    function dk(i, e) {
      var t = e,
        r = i.charCodeAt(t + 1);
      if (!fk[r]) if (wa[r]) {
        var n = 0;
        do t++, n++, r = i.charCodeAt(t + 1); while (wa[r] && n < 6);
        n < 6 && r === O.space && t++;
      } else t++;
      return t;
    }
    var hk = {
      TYPE: 0,
      START_LINE: 1,
      START_COL: 2,
      END_LINE: 3,
      END_COL: 4,
      START_POS: 5,
      END_POS: 6
    };
    Ur.FIELDS = hk;
    function mk(i) {
      var e = [],
        t = i.css.valueOf(),
        r = t,
        n = r.length,
        a = -1,
        s = 1,
        o = 0,
        u = 0,
        c,
        f,
        d,
        p,
        m,
        b,
        x,
        y,
        w,
        k,
        S,
        _,
        E;
      function I(q, R) {
        if (i.safe) t += R, w = t.length - 1;else throw i.error("Unclosed " + q, s, o - a, o);
      }
      for (; o < n;) {
        switch (c = t.charCodeAt(o), c === O.newline && (a = o, s += 1), c) {
          case O.space:
          case O.tab:
          case O.newline:
          case O.cr:
          case O.feed:
            w = o;
            do w += 1, c = t.charCodeAt(w), c === O.newline && (a = w, s += 1); while (c === O.space || c === O.newline || c === O.tab || c === O.cr || c === O.feed);
            E = O.space, p = s, d = w - a - 1, u = w;
            break;
          case O.plus:
          case O.greaterThan:
          case O.tilde:
          case O.pipe:
            w = o;
            do w += 1, c = t.charCodeAt(w); while (c === O.plus || c === O.greaterThan || c === O.tilde || c === O.pipe);
            E = O.combinator, p = s, d = o - a, u = w;
            break;
          case O.asterisk:
          case O.ampersand:
          case O.bang:
          case O.comma:
          case O.equals:
          case O.dollar:
          case O.caret:
          case O.openSquare:
          case O.closeSquare:
          case O.colon:
          case O.semicolon:
          case O.openParenthesis:
          case O.closeParenthesis:
            w = o, E = c, p = s, d = o - a, u = w + 1;
            break;
          case O.singleQuote:
          case O.doubleQuote:
            _ = c === O.singleQuote ? "'" : '"', w = o;
            do for (m = !1, w = t.indexOf(_, w + 1), w === -1 && I("quote", _), b = w; t.charCodeAt(b - 1) === O.backslash;) b -= 1, m = !m; while (m);
            E = O.str, p = s, d = o - a, u = w + 1;
            break;
          default:
            c === O.slash && t.charCodeAt(o + 1) === O.asterisk ? (w = t.indexOf("*/", o + 2) + 1, w === 0 && I("comment", "*/"), f = t.slice(o, w + 1), y = f.split("\n"), x = y.length - 1, x > 0 ? (k = s + x, S = w - y[x].length) : (k = s, S = a), E = O.comment, s = k, p = k, d = w - S) : c === O.slash ? (w = o, E = c, p = s, d = o - a, u = w + 1) : (w = pk(t, o), E = O.word, p = s, d = w - a), u = w + 1;
            break;
        }
        e.push([E, s, o - a, p, d, o, u]), S && (a = S, S = null), o = u;
      }
      return e;
    }
  });
  var bp = v(function (Wr, wp) {
    l();
    "use strict";
    Wr.__esModule = !0;
    Wr["default"] = void 0;
    var gk = be(zs()),
      ba = be(Us()),
      yk = be(Hs()),
      pp = be(Qs()),
      wk = be(Xs()),
      bk = be(ea()),
      va = be(ra()),
      vk = be(na()),
      dp = an(fa()),
      xk = be(pa()),
      xa = be(ha()),
      kk = be(ga()),
      Sk = be(op()),
      A = an(cp()),
      T = an(ya()),
      Ck = an(ne()),
      Y = _r(),
      bt,
      ka;
    function hp(i) {
      if (typeof WeakMap != "function") return null;
      var e = new WeakMap(),
        t = new WeakMap();
      return (hp = function hp(n) {
        return n ? t : e;
      })(i);
    }
    function an(i, e) {
      if (!e && i && i.__esModule) return i;
      if (i === null || _typeof(i) != "object" && typeof i != "function") return {
        "default": i
      };
      var t = hp(e);
      if (t && t.has(i)) return t.get(i);
      var r = {},
        n = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var a in i) if (a !== "default" && Object.prototype.hasOwnProperty.call(i, a)) {
        var s = n ? Object.getOwnPropertyDescriptor(i, a) : null;
        s && (s.get || s.set) ? Object.defineProperty(r, a, s) : r[a] = i[a];
      }
      return r["default"] = i, t && t.set(i, r), r;
    }
    function be(i) {
      return i && i.__esModule ? i : {
        "default": i
      };
    }
    function mp(i, e) {
      for (var t = 0; t < e.length; t++) {
        var r = e[t];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r);
      }
    }
    function Ak(i, e, t) {
      return e && mp(i.prototype, e), t && mp(i, t), Object.defineProperty(i, "prototype", {
        writable: !1
      }), i;
    }
    var Sa = (bt = {}, bt[T.space] = !0, bt[T.cr] = !0, bt[T.feed] = !0, bt[T.newline] = !0, bt[T.tab] = !0, bt),
      _k = Object.assign({}, Sa, (ka = {}, ka[T.comment] = !0, ka));
    function gp(i) {
      return {
        line: i[A.FIELDS.START_LINE],
        column: i[A.FIELDS.START_COL]
      };
    }
    function yp(i) {
      return {
        line: i[A.FIELDS.END_LINE],
        column: i[A.FIELDS.END_COL]
      };
    }
    function vt(i, e, t, r) {
      return {
        start: {
          line: i,
          column: e
        },
        end: {
          line: t,
          column: r
        }
      };
    }
    function qt(i) {
      return vt(i[A.FIELDS.START_LINE], i[A.FIELDS.START_COL], i[A.FIELDS.END_LINE], i[A.FIELDS.END_COL]);
    }
    function Ca(i, e) {
      if (!!i) return vt(i[A.FIELDS.START_LINE], i[A.FIELDS.START_COL], e[A.FIELDS.END_LINE], e[A.FIELDS.END_COL]);
    }
    function Rt(i, e) {
      var t = i[e];
      if (typeof t == "string") return t.indexOf("\\") !== -1 && ((0, Y.ensureObject)(i, "raws"), i[e] = (0, Y.unesc)(t), i.raws[e] === void 0 && (i.raws[e] = t)), i;
    }
    function Aa(i, e) {
      for (var t = -1, r = []; (t = i.indexOf(e, t + 1)) !== -1;) r.push(t);
      return r;
    }
    function Ok() {
      var i = Array.prototype.concat.apply([], arguments);
      return i.filter(function (e, t) {
        return t === i.indexOf(e);
      });
    }
    var Ek = function () {
      function i(t, r) {
        r === void 0 && (r = {}), this.rule = t, this.options = Object.assign({
          lossy: !1,
          safe: !1
        }, r), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, A["default"])({
          css: this.css,
          error: this._errorGenerator(),
          safe: this.options.safe
        });
        var n = Ca(this.tokens[0], this.tokens[this.tokens.length - 1]);
        this.root = new gk["default"]({
          source: n
        }), this.root.errorGenerator = this._errorGenerator();
        var a = new ba["default"]({
          source: {
            start: {
              line: 1,
              column: 1
            }
          }
        });
        this.root.append(a), this.current = a, this.loop();
      }
      var e = i.prototype;
      return e._errorGenerator = function () {
        var r = this;
        return function (n, a) {
          return typeof r.rule == "string" ? new Error(n) : r.rule.error(n, a);
        };
      }, e.attribute = function () {
        var r = [],
          n = this.currToken;
        for (this.position++; this.position < this.tokens.length && this.currToken[A.FIELDS.TYPE] !== T.closeSquare;) r.push(this.currToken), this.position++;
        if (this.currToken[A.FIELDS.TYPE] !== T.closeSquare) return this.expected("closing square bracket", this.currToken[A.FIELDS.START_POS]);
        var a = r.length,
          s = {
            source: vt(n[1], n[2], this.currToken[3], this.currToken[4]),
            sourceIndex: n[A.FIELDS.START_POS]
          };
        if (a === 1 && !~[T.word].indexOf(r[0][A.FIELDS.TYPE])) return this.expected("attribute", r[0][A.FIELDS.START_POS]);
        for (var o = 0, u = "", c = "", f = null, d = !1; o < a;) {
          var p = r[o],
            m = this.content(p),
            b = r[o + 1];
          switch (p[A.FIELDS.TYPE]) {
            case T.space:
              if (d = !0, this.options.lossy) break;
              if (f) {
                (0, Y.ensureObject)(s, "spaces", f);
                var x = s.spaces[f].after || "";
                s.spaces[f].after = x + m;
                var y = (0, Y.getProp)(s, "raws", "spaces", f, "after") || null;
                y && (s.raws.spaces[f].after = y + m);
              } else u = u + m, c = c + m;
              break;
            case T.asterisk:
              if (b[A.FIELDS.TYPE] === T.equals) s.operator = m, f = "operator";else if ((!s.namespace || f === "namespace" && !d) && b) {
                u && ((0, Y.ensureObject)(s, "spaces", "attribute"), s.spaces.attribute.before = u, u = ""), c && ((0, Y.ensureObject)(s, "raws", "spaces", "attribute"), s.raws.spaces.attribute.before = u, c = ""), s.namespace = (s.namespace || "") + m;
                var w = (0, Y.getProp)(s, "raws", "namespace") || null;
                w && (s.raws.namespace += m), f = "namespace";
              }
              d = !1;
              break;
            case T.dollar:
              if (f === "value") {
                var k = (0, Y.getProp)(s, "raws", "value");
                s.value += "$", k && (s.raws.value = k + "$");
                break;
              }
            case T.caret:
              b[A.FIELDS.TYPE] === T.equals && (s.operator = m, f = "operator"), d = !1;
              break;
            case T.combinator:
              if (m === "~" && b[A.FIELDS.TYPE] === T.equals && (s.operator = m, f = "operator"), m !== "|") {
                d = !1;
                break;
              }
              b[A.FIELDS.TYPE] === T.equals ? (s.operator = m, f = "operator") : !s.namespace && !s.attribute && (s.namespace = !0), d = !1;
              break;
            case T.word:
              if (b && this.content(b) === "|" && r[o + 2] && r[o + 2][A.FIELDS.TYPE] !== T.equals && !s.operator && !s.namespace) s.namespace = m, f = "namespace";else if (!s.attribute || f === "attribute" && !d) {
                u && ((0, Y.ensureObject)(s, "spaces", "attribute"), s.spaces.attribute.before = u, u = ""), c && ((0, Y.ensureObject)(s, "raws", "spaces", "attribute"), s.raws.spaces.attribute.before = c, c = ""), s.attribute = (s.attribute || "") + m;
                var S = (0, Y.getProp)(s, "raws", "attribute") || null;
                S && (s.raws.attribute += m), f = "attribute";
              } else if (!s.value && s.value !== "" || f === "value" && !(d || s.quoteMark)) {
                var _ = (0, Y.unesc)(m),
                  E = (0, Y.getProp)(s, "raws", "value") || "",
                  I = s.value || "";
                s.value = I + _, s.quoteMark = null, (_ !== m || E) && ((0, Y.ensureObject)(s, "raws"), s.raws.value = (E || I) + m), f = "value";
              } else {
                var q = m === "i" || m === "I";
                (s.value || s.value === "") && (s.quoteMark || d) ? (s.insensitive = q, (!q || m === "I") && ((0, Y.ensureObject)(s, "raws"), s.raws.insensitiveFlag = m), f = "insensitive", u && ((0, Y.ensureObject)(s, "spaces", "insensitive"), s.spaces.insensitive.before = u, u = ""), c && ((0, Y.ensureObject)(s, "raws", "spaces", "insensitive"), s.raws.spaces.insensitive.before = c, c = "")) : (s.value || s.value === "") && (f = "value", s.value += m, s.raws.value && (s.raws.value += m));
              }
              d = !1;
              break;
            case T.str:
              if (!s.attribute || !s.operator) return this.error("Expected an attribute followed by an operator preceding the string.", {
                index: p[A.FIELDS.START_POS]
              });
              var R = (0, dp.unescapeValue)(m),
                J = R.unescaped,
                ue = R.quoteMark;
              s.value = J, s.quoteMark = ue, f = "value", (0, Y.ensureObject)(s, "raws"), s.raws.value = m, d = !1;
              break;
            case T.equals:
              if (!s.attribute) return this.expected("attribute", p[A.FIELDS.START_POS], m);
              if (s.value) return this.error('Unexpected "=" found; an operator was already defined.', {
                index: p[A.FIELDS.START_POS]
              });
              s.operator = s.operator ? s.operator + m : m, f = "operator", d = !1;
              break;
            case T.comment:
              if (f) {
                if (d || b && b[A.FIELDS.TYPE] === T.space || f === "insensitive") {
                  var de = (0, Y.getProp)(s, "spaces", f, "after") || "",
                    De = (0, Y.getProp)(s, "raws", "spaces", f, "after") || de;
                  (0, Y.ensureObject)(s, "raws", "spaces", f), s.raws.spaces[f].after = De + m;
                } else {
                  var ee = s[f] || "",
                    oe = (0, Y.getProp)(s, "raws", f) || ee;
                  (0, Y.ensureObject)(s, "raws"), s.raws[f] = oe + m;
                }
              } else c = c + m;
              break;
            default:
              return this.error('Unexpected "' + m + '" found.', {
                index: p[A.FIELDS.START_POS]
              });
          }
          o++;
        }
        Rt(s, "attribute"), Rt(s, "namespace"), this.newNode(new dp["default"](s)), this.position++;
      }, e.parseWhitespaceEquivalentTokens = function (r) {
        r < 0 && (r = this.tokens.length);
        var n = this.position,
          a = [],
          s = "",
          o = void 0;
        do if (Sa[this.currToken[A.FIELDS.TYPE]]) this.options.lossy || (s += this.content());else if (this.currToken[A.FIELDS.TYPE] === T.comment) {
          var u = {};
          s && (u.before = s, s = ""), o = new pp["default"]({
            value: this.content(),
            source: qt(this.currToken),
            sourceIndex: this.currToken[A.FIELDS.START_POS],
            spaces: u
          }), a.push(o);
        } while (++this.position < r);
        if (s) {
          if (o) o.spaces.after = s;else if (!this.options.lossy) {
            var c = this.tokens[n],
              f = this.tokens[this.position - 1];
            a.push(new va["default"]({
              value: "",
              source: vt(c[A.FIELDS.START_LINE], c[A.FIELDS.START_COL], f[A.FIELDS.END_LINE], f[A.FIELDS.END_COL]),
              sourceIndex: c[A.FIELDS.START_POS],
              spaces: {
                before: s,
                after: ""
              }
            }));
          }
        }
        return a;
      }, e.convertWhitespaceNodesToSpace = function (r, n) {
        var a = this;
        n === void 0 && (n = !1);
        var s = "",
          o = "";
        r.forEach(function (c) {
          var f = a.lossySpace(c.spaces.before, n),
            d = a.lossySpace(c.rawSpaceBefore, n);
          s += f + a.lossySpace(c.spaces.after, n && f.length === 0), o += f + c.value + a.lossySpace(c.rawSpaceAfter, n && d.length === 0);
        }), o === s && (o = void 0);
        var u = {
          space: s,
          rawSpace: o
        };
        return u;
      }, e.isNamedCombinator = function (r) {
        return r === void 0 && (r = this.position), this.tokens[r + 0] && this.tokens[r + 0][A.FIELDS.TYPE] === T.slash && this.tokens[r + 1] && this.tokens[r + 1][A.FIELDS.TYPE] === T.word && this.tokens[r + 2] && this.tokens[r + 2][A.FIELDS.TYPE] === T.slash;
      }, e.namedCombinator = function () {
        if (this.isNamedCombinator()) {
          var r = this.content(this.tokens[this.position + 1]),
            n = (0, Y.unesc)(r).toLowerCase(),
            a = {};
          n !== r && (a.value = "/" + r + "/");
          var s = new xa["default"]({
            value: "/" + n + "/",
            source: vt(this.currToken[A.FIELDS.START_LINE], this.currToken[A.FIELDS.START_COL], this.tokens[this.position + 2][A.FIELDS.END_LINE], this.tokens[this.position + 2][A.FIELDS.END_COL]),
            sourceIndex: this.currToken[A.FIELDS.START_POS],
            raws: a
          });
          return this.position = this.position + 3, s;
        } else this.unexpected();
      }, e.combinator = function () {
        var r = this;
        if (this.content() === "|") return this.namespace();
        var n = this.locateNextMeaningfulToken(this.position);
        if (n < 0 || this.tokens[n][A.FIELDS.TYPE] === T.comma) {
          var a = this.parseWhitespaceEquivalentTokens(n);
          if (a.length > 0) {
            var s = this.current.last;
            if (s) {
              var o = this.convertWhitespaceNodesToSpace(a),
                u = o.space,
                c = o.rawSpace;
              c !== void 0 && (s.rawSpaceAfter += c), s.spaces.after += u;
            } else a.forEach(function (E) {
              return r.newNode(E);
            });
          }
          return;
        }
        var f = this.currToken,
          d = void 0;
        n > this.position && (d = this.parseWhitespaceEquivalentTokens(n));
        var p;
        if (this.isNamedCombinator() ? p = this.namedCombinator() : this.currToken[A.FIELDS.TYPE] === T.combinator ? (p = new xa["default"]({
          value: this.content(),
          source: qt(this.currToken),
          sourceIndex: this.currToken[A.FIELDS.START_POS]
        }), this.position++) : Sa[this.currToken[A.FIELDS.TYPE]] || d || this.unexpected(), p) {
          if (d) {
            var m = this.convertWhitespaceNodesToSpace(d),
              b = m.space,
              x = m.rawSpace;
            p.spaces.before = b, p.rawSpaceBefore = x;
          }
        } else {
          var y = this.convertWhitespaceNodesToSpace(d, !0),
            w = y.space,
            k = y.rawSpace;
          k || (k = w);
          var S = {},
            _ = {
              spaces: {}
            };
          w.endsWith(" ") && k.endsWith(" ") ? (S.before = w.slice(0, w.length - 1), _.spaces.before = k.slice(0, k.length - 1)) : w.startsWith(" ") && k.startsWith(" ") ? (S.after = w.slice(1), _.spaces.after = k.slice(1)) : _.value = k, p = new xa["default"]({
            value: " ",
            source: Ca(f, this.tokens[this.position - 1]),
            sourceIndex: f[A.FIELDS.START_POS],
            spaces: S,
            raws: _
          });
        }
        return this.currToken && this.currToken[A.FIELDS.TYPE] === T.space && (p.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(p);
      }, e.comma = function () {
        if (this.position === this.tokens.length - 1) {
          this.root.trailingComma = !0, this.position++;
          return;
        }
        this.current._inferEndPosition();
        var r = new ba["default"]({
          source: {
            start: gp(this.tokens[this.position + 1])
          }
        });
        this.current.parent.append(r), this.current = r, this.position++;
      }, e.comment = function () {
        var r = this.currToken;
        this.newNode(new pp["default"]({
          value: this.content(),
          source: qt(r),
          sourceIndex: r[A.FIELDS.START_POS]
        })), this.position++;
      }, e.error = function (r, n) {
        throw this.root.error(r, n);
      }, e.missingBackslash = function () {
        return this.error("Expected a backslash preceding the semicolon.", {
          index: this.currToken[A.FIELDS.START_POS]
        });
      }, e.missingParenthesis = function () {
        return this.expected("opening parenthesis", this.currToken[A.FIELDS.START_POS]);
      }, e.missingSquareBracket = function () {
        return this.expected("opening square bracket", this.currToken[A.FIELDS.START_POS]);
      }, e.unexpected = function () {
        return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[A.FIELDS.START_POS]);
      }, e.unexpectedPipe = function () {
        return this.error("Unexpected '|'.", this.currToken[A.FIELDS.START_POS]);
      }, e.namespace = function () {
        var r = this.prevToken && this.content(this.prevToken) || !0;
        if (this.nextToken[A.FIELDS.TYPE] === T.word) return this.position++, this.word(r);
        if (this.nextToken[A.FIELDS.TYPE] === T.asterisk) return this.position++, this.universal(r);
        this.unexpectedPipe();
      }, e.nesting = function () {
        if (this.nextToken) {
          var r = this.content(this.nextToken);
          if (r === "|") {
            this.position++;
            return;
          }
        }
        var n = this.currToken;
        this.newNode(new kk["default"]({
          value: this.content(),
          source: qt(n),
          sourceIndex: n[A.FIELDS.START_POS]
        })), this.position++;
      }, e.parentheses = function () {
        var r = this.current.last,
          n = 1;
        if (this.position++, r && r.type === Ck.PSEUDO) {
          var a = new ba["default"]({
              source: {
                start: gp(this.tokens[this.position - 1])
              }
            }),
            s = this.current;
          for (r.append(a), this.current = a; this.position < this.tokens.length && n;) this.currToken[A.FIELDS.TYPE] === T.openParenthesis && n++, this.currToken[A.FIELDS.TYPE] === T.closeParenthesis && n--, n ? this.parse() : (this.current.source.end = yp(this.currToken), this.current.parent.source.end = yp(this.currToken), this.position++);
          this.current = s;
        } else {
          for (var o = this.currToken, u = "(", c; this.position < this.tokens.length && n;) this.currToken[A.FIELDS.TYPE] === T.openParenthesis && n++, this.currToken[A.FIELDS.TYPE] === T.closeParenthesis && n--, c = this.currToken, u += this.parseParenthesisToken(this.currToken), this.position++;
          r ? r.appendToPropertyAndEscape("value", u, u) : this.newNode(new va["default"]({
            value: u,
            source: vt(o[A.FIELDS.START_LINE], o[A.FIELDS.START_COL], c[A.FIELDS.END_LINE], c[A.FIELDS.END_COL]),
            sourceIndex: o[A.FIELDS.START_POS]
          }));
        }
        if (n) return this.expected("closing parenthesis", this.currToken[A.FIELDS.START_POS]);
      }, e.pseudo = function () {
        for (var r = this, n = "", a = this.currToken; this.currToken && this.currToken[A.FIELDS.TYPE] === T.colon;) n += this.content(), this.position++;
        if (!this.currToken) return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
        if (this.currToken[A.FIELDS.TYPE] === T.word) this.splitWord(!1, function (s, o) {
          n += s, r.newNode(new vk["default"]({
            value: n,
            source: Ca(a, r.currToken),
            sourceIndex: a[A.FIELDS.START_POS]
          })), o > 1 && r.nextToken && r.nextToken[A.FIELDS.TYPE] === T.openParenthesis && r.error("Misplaced parenthesis.", {
            index: r.nextToken[A.FIELDS.START_POS]
          });
        });else return this.expected(["pseudo-class", "pseudo-element"], this.currToken[A.FIELDS.START_POS]);
      }, e.space = function () {
        var r = this.content();
        this.position === 0 || this.prevToken[A.FIELDS.TYPE] === T.comma || this.prevToken[A.FIELDS.TYPE] === T.openParenthesis || this.current.nodes.every(function (n) {
          return n.type === "comment";
        }) ? (this.spaces = this.optionalSpace(r), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[A.FIELDS.TYPE] === T.comma || this.nextToken[A.FIELDS.TYPE] === T.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(r), this.position++) : this.combinator();
      }, e.string = function () {
        var r = this.currToken;
        this.newNode(new va["default"]({
          value: this.content(),
          source: qt(r),
          sourceIndex: r[A.FIELDS.START_POS]
        })), this.position++;
      }, e.universal = function (r) {
        var n = this.nextToken;
        if (n && this.content(n) === "|") return this.position++, this.namespace();
        var a = this.currToken;
        this.newNode(new xk["default"]({
          value: this.content(),
          source: qt(a),
          sourceIndex: a[A.FIELDS.START_POS]
        }), r), this.position++;
      }, e.splitWord = function (r, n) {
        for (var a = this, s = this.nextToken, o = this.content(); s && ~[T.dollar, T.caret, T.equals, T.word].indexOf(s[A.FIELDS.TYPE]);) {
          this.position++;
          var u = this.content();
          if (o += u, u.lastIndexOf("\\") === u.length - 1) {
            var c = this.nextToken;
            c && c[A.FIELDS.TYPE] === T.space && (o += this.requiredSpace(this.content(c)), this.position++);
          }
          s = this.nextToken;
        }
        var f = Aa(o, ".").filter(function (b) {
            var x = o[b - 1] === "\\",
              y = /^\d+\.\d+%$/.test(o);
            return !x && !y;
          }),
          d = Aa(o, "#").filter(function (b) {
            return o[b - 1] !== "\\";
          }),
          p = Aa(o, "#{");
        p.length && (d = d.filter(function (b) {
          return !~p.indexOf(b);
        }));
        var m = (0, Sk["default"])(Ok([0].concat(f, d)));
        m.forEach(function (b, x) {
          var y = m[x + 1] || o.length,
            w = o.slice(b, y);
          if (x === 0 && n) return n.call(a, w, m.length);
          var k,
            S = a.currToken,
            _ = S[A.FIELDS.START_POS] + m[x],
            E = vt(S[1], S[2] + b, S[3], S[2] + (y - 1));
          if (~f.indexOf(b)) {
            var I = {
              value: w.slice(1),
              source: E,
              sourceIndex: _
            };
            k = new yk["default"](Rt(I, "value"));
          } else if (~d.indexOf(b)) {
            var q = {
              value: w.slice(1),
              source: E,
              sourceIndex: _
            };
            k = new wk["default"](Rt(q, "value"));
          } else {
            var R = {
              value: w,
              source: E,
              sourceIndex: _
            };
            Rt(R, "value"), k = new bk["default"](R);
          }
          a.newNode(k, r), r = null;
        }), this.position++;
      }, e.word = function (r) {
        var n = this.nextToken;
        return n && this.content(n) === "|" ? (this.position++, this.namespace()) : this.splitWord(r);
      }, e.loop = function () {
        for (; this.position < this.tokens.length;) this.parse(!0);
        return this.current._inferEndPosition(), this.root;
      }, e.parse = function (r) {
        switch (this.currToken[A.FIELDS.TYPE]) {
          case T.space:
            this.space();
            break;
          case T.comment:
            this.comment();
            break;
          case T.openParenthesis:
            this.parentheses();
            break;
          case T.closeParenthesis:
            r && this.missingParenthesis();
            break;
          case T.openSquare:
            this.attribute();
            break;
          case T.dollar:
          case T.caret:
          case T.equals:
          case T.word:
            this.word();
            break;
          case T.colon:
            this.pseudo();
            break;
          case T.comma:
            this.comma();
            break;
          case T.asterisk:
            this.universal();
            break;
          case T.ampersand:
            this.nesting();
            break;
          case T.slash:
          case T.combinator:
            this.combinator();
            break;
          case T.str:
            this.string();
            break;
          case T.closeSquare:
            this.missingSquareBracket();
          case T.semicolon:
            this.missingBackslash();
          default:
            this.unexpected();
        }
      }, e.expected = function (r, n, a) {
        if (Array.isArray(r)) {
          var s = r.pop();
          r = r.join(", ") + " or " + s;
        }
        var o = /^[aeiou]/.test(r[0]) ? "an" : "a";
        return a ? this.error("Expected " + o + " " + r + ', found "' + a + '" instead.', {
          index: n
        }) : this.error("Expected " + o + " " + r + ".", {
          index: n
        });
      }, e.requiredSpace = function (r) {
        return this.options.lossy ? " " : r;
      }, e.optionalSpace = function (r) {
        return this.options.lossy ? "" : r;
      }, e.lossySpace = function (r, n) {
        return this.options.lossy ? n ? " " : "" : r;
      }, e.parseParenthesisToken = function (r) {
        var n = this.content(r);
        return r[A.FIELDS.TYPE] === T.space ? this.requiredSpace(n) : n;
      }, e.newNode = function (r, n) {
        return n && (/^ +$/.test(n) && (this.options.lossy || (this.spaces = (this.spaces || "") + n), n = !0), r.namespace = n, Rt(r, "namespace")), this.spaces && (r.spaces.before = this.spaces, this.spaces = ""), this.current.append(r);
      }, e.content = function (r) {
        return r === void 0 && (r = this.currToken), this.css.slice(r[A.FIELDS.START_POS], r[A.FIELDS.END_POS]);
      }, e.locateNextMeaningfulToken = function (r) {
        r === void 0 && (r = this.position + 1);
        for (var n = r; n < this.tokens.length;) if (_k[this.tokens[n][A.FIELDS.TYPE]]) {
          n++;
          continue;
        } else return n;
        return -1;
      }, Ak(i, [{
        key: "currToken",
        get: function get() {
          return this.tokens[this.position];
        }
      }, {
        key: "nextToken",
        get: function get() {
          return this.tokens[this.position + 1];
        }
      }, {
        key: "prevToken",
        get: function get() {
          return this.tokens[this.position - 1];
        }
      }]), i;
    }();
    Wr["default"] = Ek;
    wp.exports = Wr["default"];
  });
  var xp = v(function (Gr, vp) {
    l();
    "use strict";
    Gr.__esModule = !0;
    Gr["default"] = void 0;
    var Tk = Pk(bp());
    function Pk(i) {
      return i && i.__esModule ? i : {
        "default": i
      };
    }
    var Dk = function () {
      function i(t, r) {
        this.func = t || function () {}, this.funcRes = null, this.options = r;
      }
      var e = i.prototype;
      return e._shouldUpdateSelector = function (r, n) {
        n === void 0 && (n = {});
        var a = Object.assign({}, this.options, n);
        return a.updateSelector === !1 ? !1 : typeof r != "string";
      }, e._isLossy = function (r) {
        r === void 0 && (r = {});
        var n = Object.assign({}, this.options, r);
        return n.lossless === !1;
      }, e._root = function (r, n) {
        n === void 0 && (n = {});
        var a = new Tk["default"](r, this._parseOptions(n));
        return a.root;
      }, e._parseOptions = function (r) {
        return {
          lossy: this._isLossy(r)
        };
      }, e._run = function (r, n) {
        var a = this;
        return n === void 0 && (n = {}), new Promise(function (s, o) {
          try {
            var u = a._root(r, n);
            Promise.resolve(a.func(u)).then(function (c) {
              var f = void 0;
              return a._shouldUpdateSelector(r, n) && (f = u.toString(), r.selector = f), {
                transform: c,
                root: u,
                string: f
              };
            }).then(s, o);
          } catch (c) {
            o(c);
            return;
          }
        });
      }, e._runSync = function (r, n) {
        n === void 0 && (n = {});
        var a = this._root(r, n),
          s = this.func(a);
        if (s && typeof s.then == "function") throw new Error("Selector processor returned a promise to a synchronous call.");
        var o = void 0;
        return n.updateSelector && typeof r != "string" && (o = a.toString(), r.selector = o), {
          transform: s,
          root: a,
          string: o
        };
      }, e.ast = function (r, n) {
        return this._run(r, n).then(function (a) {
          return a.root;
        });
      }, e.astSync = function (r, n) {
        return this._runSync(r, n).root;
      }, e.transform = function (r, n) {
        return this._run(r, n).then(function (a) {
          return a.transform;
        });
      }, e.transformSync = function (r, n) {
        return this._runSync(r, n).transform;
      }, e.process = function (r, n) {
        return this._run(r, n).then(function (a) {
          return a.string || a.root.toString();
        });
      }, e.processSync = function (r, n) {
        var a = this._runSync(r, n);
        return a.string || a.root.toString();
      }, i;
    }();
    Gr["default"] = Dk;
    vp.exports = Gr["default"];
  });
  var kp = v(function (G) {
    l();
    "use strict";
    G.__esModule = !0;
    G.universal = G.tag = G.string = G.selector = G.root = G.pseudo = G.nesting = G.id = G.comment = G.combinator = G.className = G.attribute = void 0;
    var Ik = ve(fa()),
      qk = ve(Hs()),
      Rk = ve(ha()),
      Mk = ve(Qs()),
      Bk = ve(Xs()),
      Fk = ve(ga()),
      Nk = ve(na()),
      Lk = ve(zs()),
      $k = ve(Us()),
      jk = ve(ra()),
      zk = ve(ea()),
      Vk = ve(pa());
    function ve(i) {
      return i && i.__esModule ? i : {
        "default": i
      };
    }
    var Uk = function Uk(e) {
      return new Ik["default"](e);
    };
    G.attribute = Uk;
    var Wk = function Wk(e) {
      return new qk["default"](e);
    };
    G.className = Wk;
    var Gk = function Gk(e) {
      return new Rk["default"](e);
    };
    G.combinator = Gk;
    var Hk = function Hk(e) {
      return new Mk["default"](e);
    };
    G.comment = Hk;
    var Yk = function Yk(e) {
      return new Bk["default"](e);
    };
    G.id = Yk;
    var Qk = function Qk(e) {
      return new Fk["default"](e);
    };
    G.nesting = Qk;
    var Jk = function Jk(e) {
      return new Nk["default"](e);
    };
    G.pseudo = Jk;
    var Xk = function Xk(e) {
      return new Lk["default"](e);
    };
    G.root = Xk;
    var Kk = function Kk(e) {
      return new $k["default"](e);
    };
    G.selector = Kk;
    var Zk = function Zk(e) {
      return new jk["default"](e);
    };
    G.string = Zk;
    var eS = function eS(e) {
      return new zk["default"](e);
    };
    G.tag = eS;
    var tS = function tS(e) {
      return new Vk["default"](e);
    };
    G.universal = tS;
  });
  var _p = v(function ($) {
    l();
    "use strict";
    $.__esModule = !0;
    $.isComment = $.isCombinator = $.isClassName = $.isAttribute = void 0;
    $.isContainer = dS;
    $.isIdentifier = void 0;
    $.isNamespace = hS;
    $.isNesting = void 0;
    $.isNode = _a;
    $.isPseudo = void 0;
    $.isPseudoClass = pS;
    $.isPseudoElement = Ap;
    $.isUniversal = $.isTag = $.isString = $.isSelector = $.isRoot = void 0;
    var Q = ne(),
      fe,
      rS = (fe = {}, fe[Q.ATTRIBUTE] = !0, fe[Q.CLASS] = !0, fe[Q.COMBINATOR] = !0, fe[Q.COMMENT] = !0, fe[Q.ID] = !0, fe[Q.NESTING] = !0, fe[Q.PSEUDO] = !0, fe[Q.ROOT] = !0, fe[Q.SELECTOR] = !0, fe[Q.STRING] = !0, fe[Q.TAG] = !0, fe[Q.UNIVERSAL] = !0, fe);
    function _a(i) {
      return _typeof(i) == "object" && rS[i.type];
    }
    function xe(i, e) {
      return _a(e) && e.type === i;
    }
    var Sp = xe.bind(null, Q.ATTRIBUTE);
    $.isAttribute = Sp;
    var iS = xe.bind(null, Q.CLASS);
    $.isClassName = iS;
    var nS = xe.bind(null, Q.COMBINATOR);
    $.isCombinator = nS;
    var sS = xe.bind(null, Q.COMMENT);
    $.isComment = sS;
    var aS = xe.bind(null, Q.ID);
    $.isIdentifier = aS;
    var oS = xe.bind(null, Q.NESTING);
    $.isNesting = oS;
    var Oa = xe.bind(null, Q.PSEUDO);
    $.isPseudo = Oa;
    var lS = xe.bind(null, Q.ROOT);
    $.isRoot = lS;
    var uS = xe.bind(null, Q.SELECTOR);
    $.isSelector = uS;
    var fS = xe.bind(null, Q.STRING);
    $.isString = fS;
    var Cp = xe.bind(null, Q.TAG);
    $.isTag = Cp;
    var cS = xe.bind(null, Q.UNIVERSAL);
    $.isUniversal = cS;
    function Ap(i) {
      return Oa(i) && i.value && (i.value.startsWith("::") || i.value.toLowerCase() === ":before" || i.value.toLowerCase() === ":after" || i.value.toLowerCase() === ":first-letter" || i.value.toLowerCase() === ":first-line");
    }
    function pS(i) {
      return Oa(i) && !Ap(i);
    }
    function dS(i) {
      return !!(_a(i) && i.walk);
    }
    function hS(i) {
      return Sp(i) || Cp(i);
    }
  });
  var Op = v(function (Ee) {
    l();
    "use strict";
    Ee.__esModule = !0;
    var Ea = ne();
    Object.keys(Ea).forEach(function (i) {
      i === "default" || i === "__esModule" || i in Ee && Ee[i] === Ea[i] || (Ee[i] = Ea[i]);
    });
    var Ta = kp();
    Object.keys(Ta).forEach(function (i) {
      i === "default" || i === "__esModule" || i in Ee && Ee[i] === Ta[i] || (Ee[i] = Ta[i]);
    });
    var Pa = _p();
    Object.keys(Pa).forEach(function (i) {
      i === "default" || i === "__esModule" || i in Ee && Ee[i] === Pa[i] || (Ee[i] = Pa[i]);
    });
  });
  var Me = v(function (Hr, Tp) {
    l();
    "use strict";
    Hr.__esModule = !0;
    Hr["default"] = void 0;
    var mS = wS(xp()),
      gS = yS(Op());
    function Ep(i) {
      if (typeof WeakMap != "function") return null;
      var e = new WeakMap(),
        t = new WeakMap();
      return (Ep = function Ep(n) {
        return n ? t : e;
      })(i);
    }
    function yS(i, e) {
      if (!e && i && i.__esModule) return i;
      if (i === null || _typeof(i) != "object" && typeof i != "function") return {
        "default": i
      };
      var t = Ep(e);
      if (t && t.has(i)) return t.get(i);
      var r = {},
        n = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var a in i) if (a !== "default" && Object.prototype.hasOwnProperty.call(i, a)) {
        var s = n ? Object.getOwnPropertyDescriptor(i, a) : null;
        s && (s.get || s.set) ? Object.defineProperty(r, a, s) : r[a] = i[a];
      }
      return r["default"] = i, t && t.set(i, r), r;
    }
    function wS(i) {
      return i && i.__esModule ? i : {
        "default": i
      };
    }
    var Da = function Da(e) {
      return new mS["default"](e);
    };
    Object.assign(Da, gS);
    delete Da.__esModule;
    var bS = Da;
    Hr["default"] = bS;
    Tp.exports = Hr["default"];
  });
  function Ge(i) {
    return ["fontSize", "outline"].includes(i) ? function (e) {
      return typeof e == "function" && (e = e({})), Array.isArray(e) && (e = e[0]), e;
    } : i === "fontFamily" ? function (e) {
      typeof e == "function" && (e = e({}));
      var t = Array.isArray(e) && ie(e[1]) ? e[0] : e;
      return Array.isArray(t) ? t.join(", ") : t;
    } : ["boxShadow", "transitionProperty", "transitionDuration", "transitionDelay", "transitionTimingFunction", "backgroundImage", "backgroundSize", "backgroundColor", "cursor", "animation"].includes(i) ? function (e) {
      return typeof e == "function" && (e = e({})), Array.isArray(e) && (e = e.join(", ")), e;
    } : ["gridTemplateColumns", "gridTemplateRows", "objectPosition"].includes(i) ? function (e) {
      return typeof e == "function" && (e = e({})), typeof e == "string" && (e = z.list.comma(e).join(" ")), e;
    } : function (e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return typeof e == "function" && (e = e(t)), e;
    };
  }
  var Yr = C(function () {
    l();
    nt();
    St();
  });
  var Bp = v(function (a3, Ba) {
    l();
    var _ge = ge(),
      Pp = _ge.Rule,
      vS = _ge.AtRule,
      Dp = Me();
    function Ia(i, e) {
      var t;
      try {
        Dp(function (r) {
          t = r;
        }).processSync(i);
      } catch (r) {
        throw i.includes(":") ? e ? e.error("Missed semicolon") : r : e ? e.error(r.message) : r;
      }
      return t.at(0);
    }
    function Ip(i, e) {
      var t = !1;
      return i.each(function (r) {
        if (r.type === "nesting") {
          var n = e.clone({});
          r.value !== "&" ? r.replaceWith(Ia(r.value.replace("&", n.toString()))) : r.replaceWith(n), t = !0;
        } else "nodes" in r && r.nodes && Ip(r, e) && (t = !0);
      }), t;
    }
    function qp(i, e) {
      var t = [];
      return i.selectors.forEach(function (r) {
        var n = Ia(r, i);
        e.selectors.forEach(function (a) {
          if (!a) return;
          var s = Ia(a, e);
          Ip(s, n) || (s.prepend(Dp.combinator({
            value: " "
          })), s.prepend(n.clone({}))), t.push(s.toString());
        });
      }), t;
    }
    function on(i, e) {
      var t = i.prev();
      for (e.after(i); t && t.type === "comment";) {
        var r = t.prev();
        e.after(t), t = r;
      }
      return i;
    }
    function xS(i) {
      return function e(t, r, n) {
        var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : n;
        var s = [];
        if (r.each(function (o) {
          o.type === "rule" && n ? a && (o.selectors = qp(t, o)) : o.type === "atrule" && o.nodes ? i[o.name] ? e(t, o, a) : r[Ra] !== !1 && s.push(o) : s.push(o);
        }), n && s.length) {
          var o = t.clone({
            nodes: []
          });
          var _iterator46 = _createForOfIteratorHelper(s),
            _step46;
          try {
            for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {
              var u = _step46.value;
              o.append(u);
            }
          } catch (err) {
            _iterator46.e(err);
          } finally {
            _iterator46.f();
          }
          r.prepend(o);
        }
      };
    }
    function qa(i, e, t) {
      var r = new Pp({
        selector: i,
        nodes: []
      });
      return r.append(e), t.after(r), r;
    }
    function Rp(i, e) {
      var t = {};
      var _iterator47 = _createForOfIteratorHelper(i),
        _step47;
      try {
        for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {
          var _r11 = _step47.value;
          t[_r11] = !0;
        }
      } catch (err) {
        _iterator47.e(err);
      } finally {
        _iterator47.f();
      }
      if (e) {
        var _iterator48 = _createForOfIteratorHelper(e),
          _step48;
        try {
          for (_iterator48.s(); !(_step48 = _iterator48.n()).done;) {
            var r = _step48.value;
            t[r.replace(/^@/, "")] = !0;
          }
        } catch (err) {
          _iterator48.e(err);
        } finally {
          _iterator48.f();
        }
      }
      return t;
    }
    function kS(i) {
      i = i.trim();
      var e = i.match(/^\((.*)\)$/);
      if (!e) return {
        type: "basic",
        selector: i
      };
      var t = e[1].match(/^(with(?:out)?):(.+)$/);
      if (t) {
        var r = t[1] === "with",
          n = Object.fromEntries(t[2].trim().split(/\s+/).map(function (s) {
            return [s, !0];
          }));
        if (r && n.all) return {
          type: "noop"
        };
        var a = function a(s) {
          return !!n[s];
        };
        return n.all ? a = function a() {
          return !0;
        } : r && (a = function a(s) {
          return s === "all" ? !1 : !n[s];
        }), {
          type: "withrules",
          escapes: a
        };
      }
      return {
        type: "unknown"
      };
    }
    function SS(i) {
      var e = [],
        t = i.parent;
      for (; t && t instanceof vS;) e.push(t), t = t.parent;
      return e;
    }
    function CS(i) {
      var e = i[Mp];
      if (!e) i.after(i.nodes);else {
        var t = i.nodes,
          r,
          n = -1,
          a,
          s,
          o,
          u = SS(i);
        if (u.forEach(function (c, f) {
          if (e(c.name)) r = c, n = f, s = o;else {
            var d = o;
            o = c.clone({
              nodes: []
            }), d && o.append(d), a = a || o;
          }
        }), r ? s ? (a.append(t), r.after(s)) : r.after(t) : i.after(t), i.next() && r) {
          var c;
          u.slice(0, n + 1).forEach(function (f, d, p) {
            var m = c;
            c = f.clone({
              nodes: []
            }), m && c.append(m);
            var b = [],
              y = (p[d - 1] || i).next();
            for (; y;) b.push(y), y = y.next();
            c.append(b);
          }), c && (s || t[t.length - 1]).after(c);
        }
      }
      i.remove();
    }
    var Ra = Symbol("rootRuleMergeSel"),
      Mp = Symbol("rootRuleEscapes");
    function AS(i) {
      var e = i.params,
        _kS = kS(e),
        t = _kS.type,
        r = _kS.selector,
        n = _kS.escapes;
      if (t === "unknown") throw i.error("Unknown @".concat(i.name, " parameter ").concat(JSON.stringify(e)));
      if (t === "basic" && r) {
        var a = new Pp({
          selector: r,
          nodes: i.nodes
        });
        i.removeAll(), i.append(a);
      }
      i[Mp] = n, i[Ra] = n ? !n("all") : t === "noop";
    }
    var Ma = Symbol("hasRootRule");
    Ba.exports = function () {
      var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var e = Rp(["media", "supports", "layer", "container"], i.bubble),
        t = xS(e),
        r = Rp(["document", "font-face", "keyframes", "-webkit-keyframes", "-moz-keyframes"], i.unwrap),
        n = (i.rootRuleName || "at-root").replace(/^@/, ""),
        a = i.preserveEmpty;
      return {
        postcssPlugin: "postcss-nested",
        Once: function Once(s) {
          s.walkAtRules(n, function (o) {
            AS(o), s[Ma] = !0;
          });
        },
        Rule: function Rule(s) {
          var o = !1,
            u = s,
            c = !1,
            f = [];
          s.each(function (d) {
            d.type === "rule" ? (f.length && (u = qa(s.selector, f, u), f = []), c = !0, o = !0, d.selectors = qp(s, d), u = on(d, u)) : d.type === "atrule" ? (f.length && (u = qa(s.selector, f, u), f = []), d.name === n ? (o = !0, t(s, d, !0, d[Ra]), u = on(d, u)) : e[d.name] ? (c = !0, o = !0, t(s, d, !0), u = on(d, u)) : r[d.name] ? (c = !0, o = !0, t(s, d, !1), u = on(d, u)) : c && f.push(d)) : d.type === "decl" && c && f.push(d);
          }), f.length && (u = qa(s.selector, f, u)), o && a !== !0 && (s.raws.semicolon = !0, s.nodes.length === 0 && s.remove());
        },
        RootExit: function RootExit(s) {
          s[Ma] && (s.walkAtRules(n, CS), s[Ma] = !1);
        }
      };
    };
    Ba.exports.postcss = !0;
  });
  var $p = v(function (o3, Lp) {
    l();
    "use strict";
    var Fp = /-(\w|$)/g,
      Np = function Np(i, e) {
        return e.toUpperCase();
      },
      _S = function _S(i) {
        return i = i.toLowerCase(), i === "float" ? "cssFloat" : i.startsWith("-ms-") ? i.substr(1).replace(Fp, Np) : i.replace(Fp, Np);
      };
    Lp.exports = _S;
  });
  var La = v(function (l3, jp) {
    l();
    var OS = $p(),
      ES = {
        boxFlex: !0,
        boxFlexGroup: !0,
        columnCount: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        strokeDashoffset: !0,
        strokeOpacity: !0,
        strokeWidth: !0
      };
    function Fa(i) {
      return typeof i.nodes == "undefined" ? !0 : Na(i);
    }
    function Na(i) {
      var e,
        t = {};
      return i.each(function (r) {
        if (r.type === "atrule") e = "@" + r.name, r.params && (e += " " + r.params), typeof t[e] == "undefined" ? t[e] = Fa(r) : Array.isArray(t[e]) ? t[e].push(Fa(r)) : t[e] = [t[e], Fa(r)];else if (r.type === "rule") {
          var n = Na(r);
          if (t[r.selector]) for (var a in n) t[r.selector][a] = n[a];else t[r.selector] = n;
        } else if (r.type === "decl") {
          r.prop[0] === "-" && r.prop[1] === "-" || r.parent && r.parent.selector === ":export" ? e = r.prop : e = OS(r.prop);
          var _n7 = r.value;
          !isNaN(r.value) && ES[e] && (_n7 = parseFloat(r.value)), r.important && (_n7 += " !important"), typeof t[e] == "undefined" ? t[e] = _n7 : Array.isArray(t[e]) ? t[e].push(_n7) : t[e] = [t[e], _n7];
        }
      }), t;
    }
    jp.exports = Na;
  });
  var ln = v(function (u3, Wp) {
    l();
    var Qr = ge(),
      zp = /\s*!important\s*$/i,
      TS = {
        "box-flex": !0,
        "box-flex-group": !0,
        "column-count": !0,
        flex: !0,
        "flex-grow": !0,
        "flex-positive": !0,
        "flex-shrink": !0,
        "flex-negative": !0,
        "font-weight": !0,
        "line-clamp": !0,
        "line-height": !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        "tab-size": !0,
        widows: !0,
        "z-index": !0,
        zoom: !0,
        "fill-opacity": !0,
        "stroke-dashoffset": !0,
        "stroke-opacity": !0,
        "stroke-width": !0
      };
    function PS(i) {
      return i.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
    }
    function Vp(i, e, t) {
      t === !1 || t === null || (e.startsWith("--") || (e = PS(e)), typeof t == "number" && (t === 0 || TS[e] ? t = t.toString() : t += "px"), e === "css-float" && (e = "float"), zp.test(t) ? (t = t.replace(zp, ""), i.push(Qr.decl({
        prop: e,
        value: t,
        important: !0
      }))) : i.push(Qr.decl({
        prop: e,
        value: t
      })));
    }
    function Up(i, e, t) {
      var r = Qr.atRule({
        name: e[1],
        params: e[3] || ""
      });
      _typeof(t) == "object" && (r.nodes = [], $a(t, r)), i.push(r);
    }
    function $a(i, e) {
      var t, r, n;
      for (t in i) if (r = i[t], !(r === null || typeof r == "undefined")) if (t[0] === "@") {
        var a = t.match(/@(\S+)(\s+([\W\w]*)\s*)?/);
        if (Array.isArray(r)) {
          var _iterator49 = _createForOfIteratorHelper(r),
            _step49;
          try {
            for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {
              var s = _step49.value;
              Up(e, a, s);
            }
          } catch (err) {
            _iterator49.e(err);
          } finally {
            _iterator49.f();
          }
        } else Up(e, a, r);
      } else if (Array.isArray(r)) {
        var _iterator50 = _createForOfIteratorHelper(r),
          _step50;
        try {
          for (_iterator50.s(); !(_step50 = _iterator50.n()).done;) {
            var _a7 = _step50.value;
            Vp(e, t, _a7);
          }
        } catch (err) {
          _iterator50.e(err);
        } finally {
          _iterator50.f();
        }
      } else _typeof(r) == "object" ? (n = Qr.rule({
        selector: t
      }), $a(r, n), e.push(n)) : Vp(e, t, r);
    }
    Wp.exports = function (i) {
      var e = Qr.root();
      return $a(i, e), e;
    };
  });
  var ja = v(function (f3, Gp) {
    l();
    var DS = La();
    Gp.exports = function (e) {
      return console && console.warn && e.warnings().forEach(function (t) {
        var r = t.plugin || "PostCSS";
        console.warn(r + ": " + t.text);
      }), DS(e.root);
    };
  });
  var Yp = v(function (c3, Hp) {
    l();
    var IS = ge(),
      qS = ja(),
      RS = ln();
    Hp.exports = function (e) {
      var t = IS(e);
      return /*#__PURE__*/function () {
        var _ref68 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(r) {
          var n;
          return _regeneratorRuntime().wrap(function _callee2$(_context11) {
            while (1) switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return t.process(r, {
                  parser: RS,
                  from: void 0
                });
              case 2:
                n = _context11.sent;
                return _context11.abrupt("return", qS(n));
              case 4:
              case "end":
                return _context11.stop();
            }
          }, _callee2);
        }));
        return function (_x2) {
          return _ref68.apply(this, arguments);
        };
      }();
    };
  });
  var Jp = v(function (p3, Qp) {
    l();
    var MS = ge(),
      BS = ja(),
      FS = ln();
    Qp.exports = function (i) {
      var e = MS(i);
      return function (t) {
        var r = e.process(t, {
          parser: FS,
          from: void 0
        });
        return BS(r);
      };
    };
  });
  var Kp = v(function (d3, Xp) {
    l();
    var NS = La(),
      LS = ln(),
      $S = Yp(),
      jS = Jp();
    Xp.exports = {
      objectify: NS,
      parse: LS,
      async: $S,
      sync: jS
    };
  });
  var Mt,
    Zp,
    h3,
    m3,
    g3,
    y3,
    ed = C(function () {
      l();
      Mt = X(Kp()), Zp = Mt["default"], h3 = Mt["default"].objectify, m3 = Mt["default"].parse, g3 = Mt["default"].async, y3 = Mt["default"].sync;
    });
  function Bt(i) {
    return Array.isArray(i) ? i.flatMap(function (e) {
      return z([(0, td["default"])({
        bubble: ["screen"]
      })]).process(e, {
        parser: Zp
      }).root.nodes;
    }) : Bt([i]);
  }
  var td,
    za = C(function () {
      l();
      nt();
      td = X(Bp());
      ed();
    });
  function Ft(i, e) {
    var t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    if (i === "") return e;
    var r = typeof e == "string" ? (0, rd["default"])().astSync(e) : e;
    return r.walkClasses(function (n) {
      var a = n.value,
        s = t && a.startsWith("-");
      n.value = s ? "-".concat(i).concat(a.slice(1)) : "".concat(i).concat(a);
    }), typeof e == "string" ? r.toString() : r;
  }
  var rd,
    un = C(function () {
      l();
      rd = X(Me());
    });
  function ce(i) {
    var _e$raws$value, _e$raws;
    var e = id["default"].className();
    return e.value = i, gt((_e$raws$value = e === null || e === void 0 || (_e$raws = e.raws) === null || _e$raws === void 0 ? void 0 : _e$raws.value) !== null && _e$raws$value !== void 0 ? _e$raws$value : e.value);
  }
  var id,
    Nt = C(function () {
      l();
      id = X(Me());
      mi();
    });
  function Va(i) {
    return gt(".".concat(ce(i)));
  }
  function fn(i, e) {
    return Va(Jr(i, e));
  }
  function Jr(i, e) {
    return e === "DEFAULT" ? i : e === "-" || e === "-DEFAULT" ? "-".concat(i) : e.startsWith("-") ? "-".concat(i).concat(e) : e.startsWith("/") ? "".concat(i).concat(e) : "".concat(i, "-").concat(e);
  }
  var Ua = C(function () {
    l();
    Nt();
    mi();
  });
  function P(i) {
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [[i, [i]]];
    var _ref69 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var _ref69$filterDefault = _ref69.filterDefault,
      t = _ref69$filterDefault === void 0 ? !1 : _ref69$filterDefault,
      r = _objectWithoutProperties(_ref69, _excluded4);
    var n = Ge(i);
    return function (_ref70) {
      var a = _ref70.matchUtilities,
        s = _ref70.theme;
      var _iterator51 = _createForOfIteratorHelper(e),
        _step51;
      try {
        for (_iterator51.s(); !(_step51 = _iterator51.n()).done;) {
          var _s9;
          var o = _step51.value;
          var u = Array.isArray(o[0]) ? o : [o];
          a(u.reduce(function (c, _ref71) {
            var _ref72 = _slicedToArray(_ref71, 2),
              f = _ref72[0],
              d = _ref72[1];
            return Object.assign(c, _defineProperty({}, f, function (p) {
              return d.reduce(function (m, b) {
                return Array.isArray(b) ? Object.assign(m, _defineProperty({}, b[0], b[1])) : Object.assign(m, _defineProperty({}, b, n(p)));
              }, {});
            }));
          }, {}), _objectSpread(_objectSpread({}, r), {}, {
            values: t ? Object.fromEntries(Object.entries((_s9 = s(i)) !== null && _s9 !== void 0 ? _s9 : {}).filter(function (_ref73) {
              var _ref74 = _slicedToArray(_ref73, 1),
                c = _ref74[0];
              return c !== "DEFAULT";
            })) : s(i)
          }));
        }
      } catch (err) {
        _iterator51.e(err);
      } finally {
        _iterator51.f();
      }
    };
  }
  var nd = C(function () {
    l();
    Yr();
  });
  function st(i) {
    return i = Array.isArray(i) ? i : [i], i.map(function (e) {
      var t = e.values.map(function (r) {
        return r.raw !== void 0 ? r.raw : [r.min && "(min-width: ".concat(r.min, ")"), r.max && "(max-width: ".concat(r.max, ")")].filter(Boolean).join(" and ");
      });
      return e.not ? "not all and ".concat(t) : t;
    }).join(", ");
  }
  var cn = C(function () {
    l();
  });
  function Wa(i) {
    return i.split(YS).map(function (t) {
      var r = t.trim(),
        n = {
          value: r
        },
        a = r.split(QS),
        s = new Set();
      var _iterator52 = _createForOfIteratorHelper(a),
        _step52;
      try {
        var _loop4 = function _loop4() {
          var o = _step52.value;
          !s.has("DIRECTIONS") && zS.has(o) ? (n.direction = o, s.add("DIRECTIONS")) : !s.has("PLAY_STATES") && VS.has(o) ? (n.playState = o, s.add("PLAY_STATES")) : !s.has("FILL_MODES") && US.has(o) ? (n.fillMode = o, s.add("FILL_MODES")) : !s.has("ITERATION_COUNTS") && (WS.has(o) || JS.test(o)) ? (n.iterationCount = o, s.add("ITERATION_COUNTS")) : !s.has("TIMING_FUNCTION") && GS.has(o) || !s.has("TIMING_FUNCTION") && HS.some(function (u) {
            return o.startsWith("".concat(u, "("));
          }) ? (n.timingFunction = o, s.add("TIMING_FUNCTION")) : !s.has("DURATION") && sd.test(o) ? (n.duration = o, s.add("DURATION")) : !s.has("DELAY") && sd.test(o) ? (n.delay = o, s.add("DELAY")) : s.has("NAME") ? (n.unknown || (n.unknown = []), n.unknown.push(o)) : (n.name = o, s.add("NAME"));
        };
        for (_iterator52.s(); !(_step52 = _iterator52.n()).done;) {
          _loop4();
        }
      } catch (err) {
        _iterator52.e(err);
      } finally {
        _iterator52.f();
      }
      return n;
    });
  }
  var zS,
    VS,
    US,
    WS,
    GS,
    HS,
    YS,
    QS,
    sd,
    JS,
    ad = C(function () {
      l();
      zS = new Set(["normal", "reverse", "alternate", "alternate-reverse"]), VS = new Set(["running", "paused"]), US = new Set(["none", "forwards", "backwards", "both"]), WS = new Set(["infinite"]), GS = new Set(["linear", "ease", "ease-in", "ease-out", "ease-in-out", "step-start", "step-end"]), HS = ["cubic-bezier", "steps"], YS = /\,(?![^(]*\))/g, QS = /\ +(?![^(]*\))/g, sd = /^(-?[\d.]+m?s)$/, JS = /^(\d+)$/;
    });
  var _od,
    re,
    ld = C(function () {
      l();
      _od = function od(i) {
        return Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(i !== null && i !== void 0 ? i : {}).flatMap(function (_ref75) {
          var _ref76 = _slicedToArray(_ref75, 2),
            e = _ref76[0],
            t = _ref76[1];
          return _typeof(t) == "object" ? Object.entries(_od(t)).map(function (_ref77) {
            var _ref78 = _slicedToArray(_ref77, 2),
              r = _ref78[0],
              n = _ref78[1];
            return _defineProperty({}, e + (r === "DEFAULT" ? "" : "-".concat(r)), n);
          }) : [_defineProperty({}, "".concat(e), t)];
        }))));
      }, re = _od;
    });
  var fd,
    ud = C(function () {
      fd = "3.4.4";
    });
  function at(i) {
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    return Array.isArray(i) ? i.map(function (t) {
      if (e && Array.isArray(t)) throw new Error("The tuple syntax is not supported for `screens`.");
      if (typeof t == "string") return {
        name: t.toString(),
        not: !1,
        values: [{
          min: t,
          max: void 0
        }]
      };
      var _t9 = _slicedToArray(t, 2),
        r = _t9[0],
        n = _t9[1];
      return r = r.toString(), typeof n == "string" ? {
        name: r,
        not: !1,
        values: [{
          min: n,
          max: void 0
        }]
      } : Array.isArray(n) ? {
        name: r,
        not: !1,
        values: n.map(function (a) {
          return pd(a);
        })
      } : {
        name: r,
        not: !1,
        values: [pd(n)]
      };
    }) : at(Object.entries(i !== null && i !== void 0 ? i : {}), !1);
  }
  function pn(i) {
    return i.values.length !== 1 ? {
      result: !1,
      reason: "multiple-values"
    } : i.values[0].raw !== void 0 ? {
      result: !1,
      reason: "raw-values"
    } : i.values[0].min !== void 0 && i.values[0].max !== void 0 ? {
      result: !1,
      reason: "min-and-max"
    } : {
      result: !0,
      reason: null
    };
  }
  function cd(i, e, t) {
    var _ref81, _ref82;
    var r = dn(e, i),
      n = dn(t, i),
      a = pn(r),
      s = pn(n);
    if (a.reason === "multiple-values" || s.reason === "multiple-values") throw new Error("Attempted to sort a screen with multiple values. This should never happen. Please open a bug report.");
    if (a.reason === "raw-values" || s.reason === "raw-values") throw new Error("Attempted to sort a screen with raw values. This should never happen. Please open a bug report.");
    if (a.reason === "min-and-max" || s.reason === "min-and-max") throw new Error("Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report.");
    var _r$values$ = r.values[0],
      o = _r$values$.min,
      u = _r$values$.max,
      _n$values$ = n.values[0],
      c = _n$values$.min,
      f = _n$values$.max;
    e.not && (_ref81 = [u, o], o = _ref81[0], u = _ref81[1], _ref81), t.not && (_ref82 = [f, c], c = _ref82[0], f = _ref82[1], _ref82), o = o === void 0 ? o : parseFloat(o), u = u === void 0 ? u : parseFloat(u), c = c === void 0 ? c : parseFloat(c), f = f === void 0 ? f : parseFloat(f);
    var _ref83 = i === "min" ? [o, c] : [f, u],
      _ref84 = _slicedToArray(_ref83, 2),
      d = _ref84[0],
      p = _ref84[1];
    return d - p;
  }
  function dn(i, e) {
    return _typeof(i) == "object" ? i : {
      name: "arbitrary-screen",
      values: [_defineProperty({}, e, i)]
    };
  }
  function pd() {
    var _ref86 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      i = _ref86["min-width"],
      _ref86$min = _ref86.min,
      e = _ref86$min === void 0 ? i : _ref86$min,
      t = _ref86.max,
      r = _ref86.raw;
    return {
      min: e,
      max: t,
      raw: r
    };
  }
  var hn = C(function () {
    l();
  });
  function mn(i, e) {
    i.walkDecls(function (t) {
      if (e.includes(t.prop)) {
        t.remove();
        return;
      }
      var _iterator53 = _createForOfIteratorHelper(e),
        _step53;
      try {
        for (_iterator53.s(); !(_step53 = _iterator53.n()).done;) {
          var r = _step53.value;
          t.value.includes("/ var(".concat(r, ")")) && (t.value = t.value.replace("/ var(".concat(r, ")"), ""));
        }
      } catch (err) {
        _iterator53.e(err);
      } finally {
        _iterator53.f();
      }
    });
  }
  var dd = C(function () {
    l();
  });
  var H,
    Te,
    Be,
    Fe,
    hd,
    md = C(function () {
      l();
      je();
      yt();
      nt();
      nd();
      cn();
      Nt();
      ad();
      ld();
      lr();
      cs();
      St();
      Yr();
      ud();
      Oe();
      hn();
      ns();
      dd();
      ze();
      cr();
      Xr();
      H = {
        childVariant: function childVariant(_ref87) {
          var i = _ref87.addVariant;
          i("*", "& > *");
        },
        pseudoElementVariants: function pseudoElementVariants(_ref88) {
          var i = _ref88.addVariant;
          i("first-letter", "&::first-letter"), i("first-line", "&::first-line"), i("marker", [function (_ref89) {
            var e = _ref89.container;
            return mn(e, ["--tw-text-opacity"]), "& *::marker";
          }, function (_ref90) {
            var e = _ref90.container;
            return mn(e, ["--tw-text-opacity"]), "&::marker";
          }]), i("selection", ["& *::selection", "&::selection"]), i("file", "&::file-selector-button"), i("placeholder", "&::placeholder"), i("backdrop", "&::backdrop"), i("before", function (_ref91) {
            var e = _ref91.container;
            return e.walkRules(function (t) {
              var r = !1;
              t.walkDecls("content", function () {
                r = !0;
              }), r || t.prepend(z.decl({
                prop: "content",
                value: "var(--tw-content)"
              }));
            }), "&::before";
          }), i("after", function (_ref92) {
            var e = _ref92.container;
            return e.walkRules(function (t) {
              var r = !1;
              t.walkDecls("content", function () {
                r = !0;
              }), r || t.prepend(z.decl({
                prop: "content",
                value: "var(--tw-content)"
              }));
            }), "&::after";
          });
        },
        pseudoClassVariants: function pseudoClassVariants(_ref93) {
          var i = _ref93.addVariant,
            e = _ref93.matchVariant,
            t = _ref93.config,
            r = _ref93.prefix;
          var n = [["first", "&:first-child"], ["last", "&:last-child"], ["only", "&:only-child"], ["odd", "&:nth-child(odd)"], ["even", "&:nth-child(even)"], "first-of-type", "last-of-type", "only-of-type", ["visited", function (_ref94) {
            var s = _ref94.container;
            return mn(s, ["--tw-text-opacity", "--tw-border-opacity", "--tw-bg-opacity"]), "&:visited";
          }], "target", ["open", "&[open]"], "default", "checked", "indeterminate", "placeholder-shown", "autofill", "optional", "required", "valid", "invalid", "in-range", "out-of-range", "read-only", "empty", "focus-within", ["hover", K(t(), "hoverOnlyWhenSupported") ? "@media (hover: hover) and (pointer: fine) { &:hover }" : "&:hover"], "focus", "focus-visible", "active", "enabled", "disabled"].map(function (s) {
            return Array.isArray(s) ? s : [s, "&:".concat(s)];
          });
          var _iterator54 = _createForOfIteratorHelper(n),
            _step54;
          try {
            var _loop6 = function _loop6() {
              var _step54$value = _slicedToArray(_step54.value, 2),
                s = _step54$value[0],
                o = _step54$value[1];
              i(s, function (u) {
                return typeof o == "function" ? o(u) : o;
              });
            };
            for (_iterator54.s(); !(_step54 = _iterator54.n()).done;) {
              _loop6();
            }
          } catch (err) {
            _iterator54.e(err);
          } finally {
            _iterator54.f();
          }
          var a = {
            group: function group(s, _ref95) {
              var o = _ref95.modifier;
              return o ? [":merge(".concat(r(".group"), "\\/").concat(ce(o), ")"), " &"] : [":merge(".concat(r(".group"), ")"), " &"];
            },
            peer: function peer(s, _ref96) {
              var o = _ref96.modifier;
              return o ? [":merge(".concat(r(".peer"), "\\/").concat(ce(o), ")"), " ~ &"] : [":merge(".concat(r(".peer"), ")"), " ~ &"];
            }
          };
          var _loop5 = function _loop5() {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i10], 2),
              s = _Object$entries$_i[0],
              o = _Object$entries$_i[1];
            e(s, function () {
              var u = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
              var c = arguments.length > 1 ? arguments[1] : undefined;
              var f = N(typeof u == "function" ? u(c) : u);
              f.includes("&") || (f = "&" + f);
              var _o4 = o("", c),
                _o5 = _slicedToArray(_o4, 2),
                d = _o5[0],
                p = _o5[1],
                m = null,
                b = null,
                x = 0;
              for (var y = 0; y < f.length; ++y) {
                var w = f[y];
                w === "&" ? m = y : w === "'" || w === '"' ? x += 1 : m !== null && w === " " && !x && (b = y);
              }
              return m !== null && b === null && (b = f.length), f.slice(0, m) + d + f.slice(m + 1, b) + p + f.slice(b);
            }, _defineProperty({
              values: Object.fromEntries(n)
            }, ot, {
              respectPrefix: !1
            }));
          };
          for (var _i10 = 0, _Object$entries = Object.entries(a); _i10 < _Object$entries.length; _i10++) {
            _loop5();
          }
        },
        directionVariants: function directionVariants(_ref97) {
          var i = _ref97.addVariant;
          i("ltr", '&:where([dir="ltr"], [dir="ltr"] *)'), i("rtl", '&:where([dir="rtl"], [dir="rtl"] *)');
        },
        reducedMotionVariants: function reducedMotionVariants(_ref98) {
          var i = _ref98.addVariant;
          i("motion-safe", "@media (prefers-reduced-motion: no-preference)"), i("motion-reduce", "@media (prefers-reduced-motion: reduce)");
        },
        darkVariants: function darkVariants(_ref99) {
          var i = _ref99.config,
            e = _ref99.addVariant;
          var _concat = [].concat(i("darkMode", "media")),
            _concat2 = _slicedToArray(_concat, 2),
            t = _concat2[0],
            _concat2$ = _concat2[1],
            r = _concat2$ === void 0 ? ".dark" : _concat2$;
          if (t === !1 && (t = "media", F.warn("darkmode-false", ["The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.", "Change `darkMode` to `media` or remove it entirely.", "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"])), t === "variant") {
            var n;
            if (Array.isArray(r) || typeof r == "function" ? n = r : typeof r == "string" && (n = [r]), Array.isArray(n)) {
              var _iterator55 = _createForOfIteratorHelper(n),
                _step55;
              try {
                for (_iterator55.s(); !(_step55 = _iterator55.n()).done;) {
                  var a = _step55.value;
                  a === ".dark" ? (t = !1, F.warn("darkmode-variant-without-selector", ["When using `variant` for `darkMode`, you must provide a selector.", 'Example: `darkMode: ["variant", ".your-selector &"]`'])) : a.includes("&") || (t = !1, F.warn("darkmode-variant-without-ampersand", ["When using `variant` for `darkMode`, your selector must contain `&`.", 'Example `darkMode: ["variant", ".your-selector &"]`']));
                }
              } catch (err) {
                _iterator55.e(err);
              } finally {
                _iterator55.f();
              }
            }
            r = n;
          }
          t === "selector" ? e("dark", "&:where(".concat(r, ", ").concat(r, " *)")) : t === "media" ? e("dark", "@media (prefers-color-scheme: dark)") : t === "variant" ? e("dark", r) : t === "class" && e("dark", "&:is(".concat(r, " *)"));
        },
        printVariant: function printVariant(_ref100) {
          var i = _ref100.addVariant;
          i("print", "@media print");
        },
        screenVariants: function screenVariants(_ref101) {
          var _i11;
          var i = _ref101.theme,
            e = _ref101.addVariant,
            t = _ref101.matchVariant;
          var r = (_i11 = i("screens")) !== null && _i11 !== void 0 ? _i11 : {},
            n = Object.values(r).every(function (w) {
              return typeof w == "string";
            }),
            a = at(i("screens")),
            s = new Set([]);
          function o(w) {
            var _w$match$, _w$match;
            return (_w$match$ = (_w$match = w.match(/(\D+)$/)) === null || _w$match === void 0 ? void 0 : _w$match[1]) !== null && _w$match$ !== void 0 ? _w$match$ : "(none)";
          }
          function u(w) {
            w !== void 0 && s.add(o(w));
          }
          function c(w) {
            return u(w), s.size === 1;
          }
          var _iterator56 = _createForOfIteratorHelper(a),
            _step56;
          try {
            for (_iterator56.s(); !(_step56 = _iterator56.n()).done;) {
              var w = _step56.value;
              var _iterator58 = _createForOfIteratorHelper(w.values),
                _step58;
              try {
                for (_iterator58.s(); !(_step58 = _iterator58.n()).done;) {
                  var k = _step58.value;
                  u(k.min), u(k.max);
                }
              } catch (err) {
                _iterator58.e(err);
              } finally {
                _iterator58.f();
              }
            }
          } catch (err) {
            _iterator56.e(err);
          } finally {
            _iterator56.f();
          }
          var f = s.size <= 1;
          function d(w) {
            return Object.fromEntries(a.filter(function (k) {
              return pn(k).result;
            }).map(function (k) {
              var _k$values$ = k.values[0],
                S = _k$values$.min,
                _ = _k$values$.max;
              if (w === "min" && S !== void 0) return k;
              if (w === "min" && _ !== void 0) return _objectSpread(_objectSpread({}, k), {}, {
                not: !k.not
              });
              if (w === "max" && _ !== void 0) return k;
              if (w === "max" && S !== void 0) return _objectSpread(_objectSpread({}, k), {}, {
                not: !k.not
              });
            }).map(function (k) {
              return [k.name, k];
            }));
          }
          function p(w) {
            return function (k, S) {
              return cd(w, k.value, S.value);
            };
          }
          var m = p("max"),
            b = p("min");
          function x(w) {
            return function (k) {
              if (n) {
                if (f) {
                  if (typeof k == "string" && !c(k)) return F.warn("minmax-have-mixed-units", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."]), [];
                } else return F.warn("mixed-screen-units", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."]), [];
              } else return F.warn("complex-screen-config", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."]), [];
              return ["@media ".concat(st(dn(k, w)))];
            };
          }
          t("max", x("max"), {
            sort: m,
            values: n ? d("max") : {}
          });
          var y = "min-screens";
          var _iterator57 = _createForOfIteratorHelper(a),
            _step57;
          try {
            for (_iterator57.s(); !(_step57 = _iterator57.n()).done;) {
              var _w2 = _step57.value;
              e(_w2.name, "@media ".concat(st(_w2)), {
                id: y,
                sort: n && f ? b : void 0,
                value: _w2
              });
            }
          } catch (err) {
            _iterator57.e(err);
          } finally {
            _iterator57.f();
          }
          t("min", x("min"), {
            id: y,
            sort: b
          });
        },
        supportsVariants: function supportsVariants(_ref102) {
          var _e16;
          var i = _ref102.matchVariant,
            e = _ref102.theme;
          i("supports", function () {
            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var r = N(t),
              n = /^\w*\s*\(/.test(r);
            return r = n ? r.replace(/\b(and|or|not)\b/g, " $1 ") : r, n ? "@supports ".concat(r) : (r.includes(":") || (r = "".concat(r, ": var(--tw)")), r.startsWith("(") && r.endsWith(")") || (r = "(".concat(r, ")")), "@supports ".concat(r));
          }, {
            values: (_e16 = e("supports")) !== null && _e16 !== void 0 ? _e16 : {}
          });
        },
        hasVariants: function hasVariants(_ref103) {
          var i = _ref103.matchVariant,
            e = _ref103.prefix;
          i("has", function (t) {
            return "&:has(".concat(N(t), ")");
          }, _defineProperty({
            values: {}
          }, ot, {
            respectPrefix: !1
          })), i("group-has", function (t, _ref104) {
            var r = _ref104.modifier;
            return r ? ":merge(".concat(e(".group"), "\\/").concat(r, "):has(").concat(N(t), ") &") : ":merge(".concat(e(".group"), "):has(").concat(N(t), ") &");
          }, _defineProperty({
            values: {}
          }, ot, {
            respectPrefix: !1
          })), i("peer-has", function (t, _ref105) {
            var r = _ref105.modifier;
            return r ? ":merge(".concat(e(".peer"), "\\/").concat(r, "):has(").concat(N(t), ") ~ &") : ":merge(".concat(e(".peer"), "):has(").concat(N(t), ") ~ &");
          }, _defineProperty({
            values: {}
          }, ot, {
            respectPrefix: !1
          }));
        },
        ariaVariants: function ariaVariants(_ref106) {
          var _e17, _e18, _e19;
          var i = _ref106.matchVariant,
            e = _ref106.theme;
          i("aria", function (t) {
            return "&[aria-".concat(N(t), "]");
          }, {
            values: (_e17 = e("aria")) !== null && _e17 !== void 0 ? _e17 : {}
          }), i("group-aria", function (t, _ref107) {
            var r = _ref107.modifier;
            return r ? ":merge(.group\\/".concat(r, ")[aria-").concat(N(t), "] &") : ":merge(.group)[aria-".concat(N(t), "] &");
          }, {
            values: (_e18 = e("aria")) !== null && _e18 !== void 0 ? _e18 : {}
          }), i("peer-aria", function (t, _ref108) {
            var r = _ref108.modifier;
            return r ? ":merge(.peer\\/".concat(r, ")[aria-").concat(N(t), "] ~ &") : ":merge(.peer)[aria-".concat(N(t), "] ~ &");
          }, {
            values: (_e19 = e("aria")) !== null && _e19 !== void 0 ? _e19 : {}
          });
        },
        dataVariants: function dataVariants(_ref109) {
          var _e20, _e21, _e22;
          var i = _ref109.matchVariant,
            e = _ref109.theme;
          i("data", function (t) {
            return "&[data-".concat(N(t), "]");
          }, {
            values: (_e20 = e("data")) !== null && _e20 !== void 0 ? _e20 : {}
          }), i("group-data", function (t, _ref110) {
            var r = _ref110.modifier;
            return r ? ":merge(.group\\/".concat(r, ")[data-").concat(N(t), "] &") : ":merge(.group)[data-".concat(N(t), "] &");
          }, {
            values: (_e21 = e("data")) !== null && _e21 !== void 0 ? _e21 : {}
          }), i("peer-data", function (t, _ref111) {
            var r = _ref111.modifier;
            return r ? ":merge(.peer\\/".concat(r, ")[data-").concat(N(t), "] ~ &") : ":merge(.peer)[data-".concat(N(t), "] ~ &");
          }, {
            values: (_e22 = e("data")) !== null && _e22 !== void 0 ? _e22 : {}
          });
        },
        orientationVariants: function orientationVariants(_ref112) {
          var i = _ref112.addVariant;
          i("portrait", "@media (orientation: portrait)"), i("landscape", "@media (orientation: landscape)");
        },
        prefersContrastVariants: function prefersContrastVariants(_ref113) {
          var i = _ref113.addVariant;
          i("contrast-more", "@media (prefers-contrast: more)"), i("contrast-less", "@media (prefers-contrast: less)");
        },
        forcedColorsVariants: function forcedColorsVariants(_ref114) {
          var i = _ref114.addVariant;
          i("forced-colors", "@media (forced-colors: active)");
        }
      }, Te = ["translate(var(--tw-translate-x), var(--tw-translate-y))", "rotate(var(--tw-rotate))", "skewX(var(--tw-skew-x))", "skewY(var(--tw-skew-y))", "scaleX(var(--tw-scale-x))", "scaleY(var(--tw-scale-y))"].join(" "), Be = ["var(--tw-blur)", "var(--tw-brightness)", "var(--tw-contrast)", "var(--tw-grayscale)", "var(--tw-hue-rotate)", "var(--tw-invert)", "var(--tw-saturate)", "var(--tw-sepia)", "var(--tw-drop-shadow)"].join(" "), Fe = ["var(--tw-backdrop-blur)", "var(--tw-backdrop-brightness)", "var(--tw-backdrop-contrast)", "var(--tw-backdrop-grayscale)", "var(--tw-backdrop-hue-rotate)", "var(--tw-backdrop-invert)", "var(--tw-backdrop-opacity)", "var(--tw-backdrop-saturate)", "var(--tw-backdrop-sepia)"].join(" "), hd = {
        preflight: function preflight(_ref115) {
          var i = _ref115.addBase;
          var e = z.parse("*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:theme('borderColor.DEFAULT', currentColor)}::after,::before{--tw-content:''}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:theme('fontFamily.sans', ui-sans-serif, system-ui, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\");font-feature-settings:theme('fontFamily.sans[1].fontFeatureSettings', normal);font-variation-settings:theme('fontFamily.sans[1].fontVariationSettings', normal);-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:theme('fontFamily.mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace);font-feature-settings:theme('fontFamily.mono[1].fontFeatureSettings', normal);font-variation-settings:theme('fontFamily.mono[1].fontVariationSettings', normal);font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:theme('colors.gray.4', #9ca3af)}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}");
          i([z.comment({
            text: "! tailwindcss v".concat(fd, " | MIT License | https://tailwindcss.com")
          })].concat(_toConsumableArray(e.nodes)));
        },
        container: function () {
          function i() {
            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            return t.flatMap(function (r) {
              return r.values.map(function (n) {
                return n.min;
              });
            }).filter(function (r) {
              return r !== void 0;
            });
          }
          function e(t, r, n) {
            if (typeof n == "undefined") return [];
            if (!(_typeof(n) == "object" && n !== null)) return [{
              screen: "DEFAULT",
              minWidth: 0,
              padding: n
            }];
            var a = [];
            n.DEFAULT && a.push({
              screen: "DEFAULT",
              minWidth: 0,
              padding: n.DEFAULT
            });
            var _iterator59 = _createForOfIteratorHelper(t),
              _step59;
            try {
              for (_iterator59.s(); !(_step59 = _iterator59.n()).done;) {
                var s = _step59.value;
                var _iterator60 = _createForOfIteratorHelper(r),
                  _step60;
                try {
                  for (_iterator60.s(); !(_step60 = _iterator60.n()).done;) {
                    var o = _step60.value;
                    var _iterator61 = _createForOfIteratorHelper(o.values),
                      _step61;
                    try {
                      for (_iterator61.s(); !(_step61 = _iterator61.n()).done;) {
                        var u = _step61.value.min;
                        u === s && a.push({
                          minWidth: s,
                          padding: n[o.name]
                        });
                      }
                    } catch (err) {
                      _iterator61.e(err);
                    } finally {
                      _iterator61.f();
                    }
                  }
                } catch (err) {
                  _iterator60.e(err);
                } finally {
                  _iterator60.f();
                }
              }
            } catch (err) {
              _iterator59.e(err);
            } finally {
              _iterator59.f();
            }
            return a;
          }
          return function (_ref116) {
            var t = _ref116.addComponents,
              r = _ref116.theme;
            var n = at(r("container.screens", r("screens"))),
              a = i(n),
              s = e(a, n, r("container.padding")),
              o = function o(c) {
                var f = s.find(function (d) {
                  return d.minWidth === c;
                });
                return f ? {
                  paddingRight: f.padding,
                  paddingLeft: f.padding
                } : {};
              },
              u = Array.from(new Set(a.slice().sort(function (c, f) {
                return parseInt(c) - parseInt(f);
              }))).map(function (c) {
                return _defineProperty({}, "@media (min-width: ".concat(c, ")"), {
                  ".container": _objectSpread({
                    "max-width": c
                  }, o(c))
                });
              });
            t([{
              ".container": Object.assign({
                width: "100%"
              }, r("container.center", !1) ? {
                marginRight: "auto",
                marginLeft: "auto"
              } : {}, o(0))
            }].concat(_toConsumableArray(u)));
          };
        }(),
        accessibility: function accessibility(_ref118) {
          var i = _ref118.addUtilities;
          i({
            ".sr-only": {
              position: "absolute",
              width: "1px",
              height: "1px",
              padding: "0",
              margin: "-1px",
              overflow: "hidden",
              clip: "rect(0, 0, 0, 0)",
              whiteSpace: "nowrap",
              borderWidth: "0"
            },
            ".not-sr-only": {
              position: "static",
              width: "auto",
              height: "auto",
              padding: "0",
              margin: "0",
              overflow: "visible",
              clip: "auto",
              whiteSpace: "normal"
            }
          });
        },
        pointerEvents: function pointerEvents(_ref119) {
          var i = _ref119.addUtilities;
          i({
            ".pointer-events-none": {
              "pointer-events": "none"
            },
            ".pointer-events-auto": {
              "pointer-events": "auto"
            }
          });
        },
        visibility: function visibility(_ref120) {
          var i = _ref120.addUtilities;
          i({
            ".visible": {
              visibility: "visible"
            },
            ".invisible": {
              visibility: "hidden"
            },
            ".collapse": {
              visibility: "collapse"
            }
          });
        },
        position: function position(_ref121) {
          var i = _ref121.addUtilities;
          i({
            ".static": {
              position: "static"
            },
            ".fixed": {
              position: "fixed"
            },
            ".absolute": {
              position: "absolute"
            },
            ".relative": {
              position: "relative"
            },
            ".sticky": {
              position: "sticky"
            }
          });
        },
        inset: P("inset", [["inset", ["inset"]], [["inset-x", ["left", "right"]], ["inset-y", ["top", "bottom"]]], [["start", ["inset-inline-start"]], ["end", ["inset-inline-end"]], ["top", ["top"]], ["right", ["right"]], ["bottom", ["bottom"]], ["left", ["left"]]]], {
          supportsNegativeValues: !0
        }),
        isolation: function isolation(_ref122) {
          var i = _ref122.addUtilities;
          i({
            ".isolate": {
              isolation: "isolate"
            },
            ".isolation-auto": {
              isolation: "auto"
            }
          });
        },
        zIndex: P("zIndex", [["z", ["zIndex"]]], {
          supportsNegativeValues: !0
        }),
        order: P("order", void 0, {
          supportsNegativeValues: !0
        }),
        gridColumn: P("gridColumn", [["col", ["gridColumn"]]]),
        gridColumnStart: P("gridColumnStart", [["col-start", ["gridColumnStart"]]], {
          supportsNegativeValues: !0
        }),
        gridColumnEnd: P("gridColumnEnd", [["col-end", ["gridColumnEnd"]]], {
          supportsNegativeValues: !0
        }),
        gridRow: P("gridRow", [["row", ["gridRow"]]]),
        gridRowStart: P("gridRowStart", [["row-start", ["gridRowStart"]]], {
          supportsNegativeValues: !0
        }),
        gridRowEnd: P("gridRowEnd", [["row-end", ["gridRowEnd"]]], {
          supportsNegativeValues: !0
        }),
        "float": function float(_ref123) {
          var i = _ref123.addUtilities;
          i({
            ".float-start": {
              "float": "inline-start"
            },
            ".float-end": {
              "float": "inline-end"
            },
            ".float-right": {
              "float": "right"
            },
            ".float-left": {
              "float": "left"
            },
            ".float-none": {
              "float": "none"
            }
          });
        },
        clear: function clear(_ref124) {
          var i = _ref124.addUtilities;
          i({
            ".clear-start": {
              clear: "inline-start"
            },
            ".clear-end": {
              clear: "inline-end"
            },
            ".clear-left": {
              clear: "left"
            },
            ".clear-right": {
              clear: "right"
            },
            ".clear-both": {
              clear: "both"
            },
            ".clear-none": {
              clear: "none"
            }
          });
        },
        margin: P("margin", [["m", ["margin"]], [["mx", ["margin-left", "margin-right"]], ["my", ["margin-top", "margin-bottom"]]], [["ms", ["margin-inline-start"]], ["me", ["margin-inline-end"]], ["mt", ["margin-top"]], ["mr", ["margin-right"]], ["mb", ["margin-bottom"]], ["ml", ["margin-left"]]]], {
          supportsNegativeValues: !0
        }),
        boxSizing: function boxSizing(_ref125) {
          var i = _ref125.addUtilities;
          i({
            ".box-border": {
              "box-sizing": "border-box"
            },
            ".box-content": {
              "box-sizing": "content-box"
            }
          });
        },
        lineClamp: function lineClamp(_ref126) {
          var i = _ref126.matchUtilities,
            e = _ref126.addUtilities,
            t = _ref126.theme;
          i({
            "line-clamp": function lineClamp(r) {
              return {
                overflow: "hidden",
                display: "-webkit-box",
                "-webkit-box-orient": "vertical",
                "-webkit-line-clamp": "".concat(r)
              };
            }
          }, {
            values: t("lineClamp")
          }), e({
            ".line-clamp-none": {
              overflow: "visible",
              display: "block",
              "-webkit-box-orient": "horizontal",
              "-webkit-line-clamp": "none"
            }
          });
        },
        display: function display(_ref127) {
          var i = _ref127.addUtilities;
          i({
            ".block": {
              display: "block"
            },
            ".inline-block": {
              display: "inline-block"
            },
            ".inline": {
              display: "inline"
            },
            ".flex": {
              display: "flex"
            },
            ".inline-flex": {
              display: "inline-flex"
            },
            ".table": {
              display: "table"
            },
            ".inline-table": {
              display: "inline-table"
            },
            ".table-caption": {
              display: "table-caption"
            },
            ".table-cell": {
              display: "table-cell"
            },
            ".table-column": {
              display: "table-column"
            },
            ".table-column-group": {
              display: "table-column-group"
            },
            ".table-footer-group": {
              display: "table-footer-group"
            },
            ".table-header-group": {
              display: "table-header-group"
            },
            ".table-row-group": {
              display: "table-row-group"
            },
            ".table-row": {
              display: "table-row"
            },
            ".flow-root": {
              display: "flow-root"
            },
            ".grid": {
              display: "grid"
            },
            ".inline-grid": {
              display: "inline-grid"
            },
            ".contents": {
              display: "contents"
            },
            ".list-item": {
              display: "list-item"
            },
            ".hidden": {
              display: "none"
            }
          });
        },
        aspectRatio: P("aspectRatio", [["aspect", ["aspect-ratio"]]]),
        size: P("size", [["size", ["width", "height"]]]),
        height: P("height", [["h", ["height"]]]),
        maxHeight: P("maxHeight", [["max-h", ["maxHeight"]]]),
        minHeight: P("minHeight", [["min-h", ["minHeight"]]]),
        width: P("width", [["w", ["width"]]]),
        minWidth: P("minWidth", [["min-w", ["minWidth"]]]),
        maxWidth: P("maxWidth", [["max-w", ["maxWidth"]]]),
        flex: P("flex"),
        flexShrink: P("flexShrink", [["flex-shrink", ["flex-shrink"]], ["shrink", ["flex-shrink"]]]),
        flexGrow: P("flexGrow", [["flex-grow", ["flex-grow"]], ["grow", ["flex-grow"]]]),
        flexBasis: P("flexBasis", [["basis", ["flex-basis"]]]),
        tableLayout: function tableLayout(_ref128) {
          var i = _ref128.addUtilities;
          i({
            ".table-auto": {
              "table-layout": "auto"
            },
            ".table-fixed": {
              "table-layout": "fixed"
            }
          });
        },
        captionSide: function captionSide(_ref129) {
          var i = _ref129.addUtilities;
          i({
            ".caption-top": {
              "caption-side": "top"
            },
            ".caption-bottom": {
              "caption-side": "bottom"
            }
          });
        },
        borderCollapse: function borderCollapse(_ref130) {
          var i = _ref130.addUtilities;
          i({
            ".border-collapse": {
              "border-collapse": "collapse"
            },
            ".border-separate": {
              "border-collapse": "separate"
            }
          });
        },
        borderSpacing: function borderSpacing(_ref131) {
          var i = _ref131.addDefaults,
            e = _ref131.matchUtilities,
            t = _ref131.theme;
          i("border-spacing", {
            "--tw-border-spacing-x": 0,
            "--tw-border-spacing-y": 0
          }), e({
            "border-spacing": function borderSpacing(r) {
              return {
                "--tw-border-spacing-x": r,
                "--tw-border-spacing-y": r,
                "@defaults border-spacing": {},
                "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
              };
            },
            "border-spacing-x": function borderSpacingX(r) {
              return {
                "--tw-border-spacing-x": r,
                "@defaults border-spacing": {},
                "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
              };
            },
            "border-spacing-y": function borderSpacingY(r) {
              return {
                "--tw-border-spacing-y": r,
                "@defaults border-spacing": {},
                "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
              };
            }
          }, {
            values: t("borderSpacing")
          });
        },
        transformOrigin: P("transformOrigin", [["origin", ["transformOrigin"]]]),
        translate: P("translate", [[["translate-x", [["@defaults transform", {}], "--tw-translate-x", ["transform", Te]]], ["translate-y", [["@defaults transform", {}], "--tw-translate-y", ["transform", Te]]]]], {
          supportsNegativeValues: !0
        }),
        rotate: P("rotate", [["rotate", [["@defaults transform", {}], "--tw-rotate", ["transform", Te]]]], {
          supportsNegativeValues: !0
        }),
        skew: P("skew", [[["skew-x", [["@defaults transform", {}], "--tw-skew-x", ["transform", Te]]], ["skew-y", [["@defaults transform", {}], "--tw-skew-y", ["transform", Te]]]]], {
          supportsNegativeValues: !0
        }),
        scale: P("scale", [["scale", [["@defaults transform", {}], "--tw-scale-x", "--tw-scale-y", ["transform", Te]]], [["scale-x", [["@defaults transform", {}], "--tw-scale-x", ["transform", Te]]], ["scale-y", [["@defaults transform", {}], "--tw-scale-y", ["transform", Te]]]]], {
          supportsNegativeValues: !0
        }),
        transform: function transform(_ref132) {
          var i = _ref132.addDefaults,
            e = _ref132.addUtilities;
          i("transform", {
            "--tw-translate-x": "0",
            "--tw-translate-y": "0",
            "--tw-rotate": "0",
            "--tw-skew-x": "0",
            "--tw-skew-y": "0",
            "--tw-scale-x": "1",
            "--tw-scale-y": "1"
          }), e({
            ".transform": {
              "@defaults transform": {},
              transform: Te
            },
            ".transform-cpu": {
              transform: Te
            },
            ".transform-gpu": {
              transform: Te.replace("translate(var(--tw-translate-x), var(--tw-translate-y))", "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)")
            },
            ".transform-none": {
              transform: "none"
            }
          });
        },
        animation: function animation(_ref133) {
          var _e23;
          var i = _ref133.matchUtilities,
            e = _ref133.theme,
            t = _ref133.config;
          var r = function r(a) {
              return ce(t("prefix") + a);
            },
            n = Object.fromEntries(Object.entries((_e23 = e("keyframes")) !== null && _e23 !== void 0 ? _e23 : {}).map(function (_ref134) {
              var _ref135 = _slicedToArray(_ref134, 2),
                a = _ref135[0],
                s = _ref135[1];
              return [a, _defineProperty({}, "@keyframes ".concat(r(a)), s)];
            }));
          i({
            animate: function animate(a) {
              var s = Wa(a);
              return [].concat(_toConsumableArray(s.flatMap(function (o) {
                return n[o.name];
              })), [{
                animation: s.map(function (_ref137) {
                  var o = _ref137.name,
                    u = _ref137.value;
                  return o === void 0 || n[o] === void 0 ? u : u.replace(o, r(o));
                }).join(", ")
              }]);
            }
          }, {
            values: e("animation")
          });
        },
        cursor: P("cursor"),
        touchAction: function touchAction(_ref138) {
          var i = _ref138.addDefaults,
            e = _ref138.addUtilities;
          i("touch-action", {
            "--tw-pan-x": " ",
            "--tw-pan-y": " ",
            "--tw-pinch-zoom": " "
          });
          var t = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
          e({
            ".touch-auto": {
              "touch-action": "auto"
            },
            ".touch-none": {
              "touch-action": "none"
            },
            ".touch-pan-x": {
              "@defaults touch-action": {},
              "--tw-pan-x": "pan-x",
              "touch-action": t
            },
            ".touch-pan-left": {
              "@defaults touch-action": {},
              "--tw-pan-x": "pan-left",
              "touch-action": t
            },
            ".touch-pan-right": {
              "@defaults touch-action": {},
              "--tw-pan-x": "pan-right",
              "touch-action": t
            },
            ".touch-pan-y": {
              "@defaults touch-action": {},
              "--tw-pan-y": "pan-y",
              "touch-action": t
            },
            ".touch-pan-up": {
              "@defaults touch-action": {},
              "--tw-pan-y": "pan-up",
              "touch-action": t
            },
            ".touch-pan-down": {
              "@defaults touch-action": {},
              "--tw-pan-y": "pan-down",
              "touch-action": t
            },
            ".touch-pinch-zoom": {
              "@defaults touch-action": {},
              "--tw-pinch-zoom": "pinch-zoom",
              "touch-action": t
            },
            ".touch-manipulation": {
              "touch-action": "manipulation"
            }
          });
        },
        userSelect: function userSelect(_ref139) {
          var i = _ref139.addUtilities;
          i({
            ".select-none": {
              "user-select": "none"
            },
            ".select-text": {
              "user-select": "text"
            },
            ".select-all": {
              "user-select": "all"
            },
            ".select-auto": {
              "user-select": "auto"
            }
          });
        },
        resize: function resize(_ref140) {
          var i = _ref140.addUtilities;
          i({
            ".resize-none": {
              resize: "none"
            },
            ".resize-y": {
              resize: "vertical"
            },
            ".resize-x": {
              resize: "horizontal"
            },
            ".resize": {
              resize: "both"
            }
          });
        },
        scrollSnapType: function scrollSnapType(_ref141) {
          var i = _ref141.addDefaults,
            e = _ref141.addUtilities;
          i("scroll-snap-type", {
            "--tw-scroll-snap-strictness": "proximity"
          }), e({
            ".snap-none": {
              "scroll-snap-type": "none"
            },
            ".snap-x": {
              "@defaults scroll-snap-type": {},
              "scroll-snap-type": "x var(--tw-scroll-snap-strictness)"
            },
            ".snap-y": {
              "@defaults scroll-snap-type": {},
              "scroll-snap-type": "y var(--tw-scroll-snap-strictness)"
            },
            ".snap-both": {
              "@defaults scroll-snap-type": {},
              "scroll-snap-type": "both var(--tw-scroll-snap-strictness)"
            },
            ".snap-mandatory": {
              "--tw-scroll-snap-strictness": "mandatory"
            },
            ".snap-proximity": {
              "--tw-scroll-snap-strictness": "proximity"
            }
          });
        },
        scrollSnapAlign: function scrollSnapAlign(_ref142) {
          var i = _ref142.addUtilities;
          i({
            ".snap-start": {
              "scroll-snap-align": "start"
            },
            ".snap-end": {
              "scroll-snap-align": "end"
            },
            ".snap-center": {
              "scroll-snap-align": "center"
            },
            ".snap-align-none": {
              "scroll-snap-align": "none"
            }
          });
        },
        scrollSnapStop: function scrollSnapStop(_ref143) {
          var i = _ref143.addUtilities;
          i({
            ".snap-normal": {
              "scroll-snap-stop": "normal"
            },
            ".snap-always": {
              "scroll-snap-stop": "always"
            }
          });
        },
        scrollMargin: P("scrollMargin", [["scroll-m", ["scroll-margin"]], [["scroll-mx", ["scroll-margin-left", "scroll-margin-right"]], ["scroll-my", ["scroll-margin-top", "scroll-margin-bottom"]]], [["scroll-ms", ["scroll-margin-inline-start"]], ["scroll-me", ["scroll-margin-inline-end"]], ["scroll-mt", ["scroll-margin-top"]], ["scroll-mr", ["scroll-margin-right"]], ["scroll-mb", ["scroll-margin-bottom"]], ["scroll-ml", ["scroll-margin-left"]]]], {
          supportsNegativeValues: !0
        }),
        scrollPadding: P("scrollPadding", [["scroll-p", ["scroll-padding"]], [["scroll-px", ["scroll-padding-left", "scroll-padding-right"]], ["scroll-py", ["scroll-padding-top", "scroll-padding-bottom"]]], [["scroll-ps", ["scroll-padding-inline-start"]], ["scroll-pe", ["scroll-padding-inline-end"]], ["scroll-pt", ["scroll-padding-top"]], ["scroll-pr", ["scroll-padding-right"]], ["scroll-pb", ["scroll-padding-bottom"]], ["scroll-pl", ["scroll-padding-left"]]]]),
        listStylePosition: function listStylePosition(_ref144) {
          var i = _ref144.addUtilities;
          i({
            ".list-inside": {
              "list-style-position": "inside"
            },
            ".list-outside": {
              "list-style-position": "outside"
            }
          });
        },
        listStyleType: P("listStyleType", [["list", ["listStyleType"]]]),
        listStyleImage: P("listStyleImage", [["list-image", ["listStyleImage"]]]),
        appearance: function appearance(_ref145) {
          var i = _ref145.addUtilities;
          i({
            ".appearance-none": {
              appearance: "none"
            },
            ".appearance-auto": {
              appearance: "auto"
            }
          });
        },
        columns: P("columns", [["columns", ["columns"]]]),
        breakBefore: function breakBefore(_ref146) {
          var i = _ref146.addUtilities;
          i({
            ".break-before-auto": {
              "break-before": "auto"
            },
            ".break-before-avoid": {
              "break-before": "avoid"
            },
            ".break-before-all": {
              "break-before": "all"
            },
            ".break-before-avoid-page": {
              "break-before": "avoid-page"
            },
            ".break-before-page": {
              "break-before": "page"
            },
            ".break-before-left": {
              "break-before": "left"
            },
            ".break-before-right": {
              "break-before": "right"
            },
            ".break-before-column": {
              "break-before": "column"
            }
          });
        },
        breakInside: function breakInside(_ref147) {
          var i = _ref147.addUtilities;
          i({
            ".break-inside-auto": {
              "break-inside": "auto"
            },
            ".break-inside-avoid": {
              "break-inside": "avoid"
            },
            ".break-inside-avoid-page": {
              "break-inside": "avoid-page"
            },
            ".break-inside-avoid-column": {
              "break-inside": "avoid-column"
            }
          });
        },
        breakAfter: function breakAfter(_ref148) {
          var i = _ref148.addUtilities;
          i({
            ".break-after-auto": {
              "break-after": "auto"
            },
            ".break-after-avoid": {
              "break-after": "avoid"
            },
            ".break-after-all": {
              "break-after": "all"
            },
            ".break-after-avoid-page": {
              "break-after": "avoid-page"
            },
            ".break-after-page": {
              "break-after": "page"
            },
            ".break-after-left": {
              "break-after": "left"
            },
            ".break-after-right": {
              "break-after": "right"
            },
            ".break-after-column": {
              "break-after": "column"
            }
          });
        },
        gridAutoColumns: P("gridAutoColumns", [["auto-cols", ["gridAutoColumns"]]]),
        gridAutoFlow: function gridAutoFlow(_ref149) {
          var i = _ref149.addUtilities;
          i({
            ".grid-flow-row": {
              gridAutoFlow: "row"
            },
            ".grid-flow-col": {
              gridAutoFlow: "column"
            },
            ".grid-flow-dense": {
              gridAutoFlow: "dense"
            },
            ".grid-flow-row-dense": {
              gridAutoFlow: "row dense"
            },
            ".grid-flow-col-dense": {
              gridAutoFlow: "column dense"
            }
          });
        },
        gridAutoRows: P("gridAutoRows", [["auto-rows", ["gridAutoRows"]]]),
        gridTemplateColumns: P("gridTemplateColumns", [["grid-cols", ["gridTemplateColumns"]]]),
        gridTemplateRows: P("gridTemplateRows", [["grid-rows", ["gridTemplateRows"]]]),
        flexDirection: function flexDirection(_ref150) {
          var i = _ref150.addUtilities;
          i({
            ".flex-row": {
              "flex-direction": "row"
            },
            ".flex-row-reverse": {
              "flex-direction": "row-reverse"
            },
            ".flex-col": {
              "flex-direction": "column"
            },
            ".flex-col-reverse": {
              "flex-direction": "column-reverse"
            }
          });
        },
        flexWrap: function flexWrap(_ref151) {
          var i = _ref151.addUtilities;
          i({
            ".flex-wrap": {
              "flex-wrap": "wrap"
            },
            ".flex-wrap-reverse": {
              "flex-wrap": "wrap-reverse"
            },
            ".flex-nowrap": {
              "flex-wrap": "nowrap"
            }
          });
        },
        placeContent: function placeContent(_ref152) {
          var i = _ref152.addUtilities;
          i({
            ".place-content-center": {
              "place-content": "center"
            },
            ".place-content-start": {
              "place-content": "start"
            },
            ".place-content-end": {
              "place-content": "end"
            },
            ".place-content-between": {
              "place-content": "space-between"
            },
            ".place-content-around": {
              "place-content": "space-around"
            },
            ".place-content-evenly": {
              "place-content": "space-evenly"
            },
            ".place-content-baseline": {
              "place-content": "baseline"
            },
            ".place-content-stretch": {
              "place-content": "stretch"
            }
          });
        },
        placeItems: function placeItems(_ref153) {
          var i = _ref153.addUtilities;
          i({
            ".place-items-start": {
              "place-items": "start"
            },
            ".place-items-end": {
              "place-items": "end"
            },
            ".place-items-center": {
              "place-items": "center"
            },
            ".place-items-baseline": {
              "place-items": "baseline"
            },
            ".place-items-stretch": {
              "place-items": "stretch"
            }
          });
        },
        alignContent: function alignContent(_ref154) {
          var i = _ref154.addUtilities;
          i({
            ".content-normal": {
              "align-content": "normal"
            },
            ".content-center": {
              "align-content": "center"
            },
            ".content-start": {
              "align-content": "flex-start"
            },
            ".content-end": {
              "align-content": "flex-end"
            },
            ".content-between": {
              "align-content": "space-between"
            },
            ".content-around": {
              "align-content": "space-around"
            },
            ".content-evenly": {
              "align-content": "space-evenly"
            },
            ".content-baseline": {
              "align-content": "baseline"
            },
            ".content-stretch": {
              "align-content": "stretch"
            }
          });
        },
        alignItems: function alignItems(_ref155) {
          var i = _ref155.addUtilities;
          i({
            ".items-start": {
              "align-items": "flex-start"
            },
            ".items-end": {
              "align-items": "flex-end"
            },
            ".items-center": {
              "align-items": "center"
            },
            ".items-baseline": {
              "align-items": "baseline"
            },
            ".items-stretch": {
              "align-items": "stretch"
            }
          });
        },
        justifyContent: function justifyContent(_ref156) {
          var i = _ref156.addUtilities;
          i({
            ".justify-normal": {
              "justify-content": "normal"
            },
            ".justify-start": {
              "justify-content": "flex-start"
            },
            ".justify-end": {
              "justify-content": "flex-end"
            },
            ".justify-center": {
              "justify-content": "center"
            },
            ".justify-between": {
              "justify-content": "space-between"
            },
            ".justify-around": {
              "justify-content": "space-around"
            },
            ".justify-evenly": {
              "justify-content": "space-evenly"
            },
            ".justify-stretch": {
              "justify-content": "stretch"
            }
          });
        },
        justifyItems: function justifyItems(_ref157) {
          var i = _ref157.addUtilities;
          i({
            ".justify-items-start": {
              "justify-items": "start"
            },
            ".justify-items-end": {
              "justify-items": "end"
            },
            ".justify-items-center": {
              "justify-items": "center"
            },
            ".justify-items-stretch": {
              "justify-items": "stretch"
            }
          });
        },
        gap: P("gap", [["gap", ["gap"]], [["gap-x", ["columnGap"]], ["gap-y", ["rowGap"]]]]),
        space: function space(_ref158) {
          var i = _ref158.matchUtilities,
            e = _ref158.addUtilities,
            t = _ref158.theme;
          i({
            "space-x": function spaceX(r) {
              return r = r === "0" ? "0px" : r, {
                "& > :not([hidden]) ~ :not([hidden])": {
                  "--tw-space-x-reverse": "0",
                  "margin-right": "calc(".concat(r, " * var(--tw-space-x-reverse))"),
                  "margin-left": "calc(".concat(r, " * calc(1 - var(--tw-space-x-reverse)))")
                }
              };
            },
            "space-y": function spaceY(r) {
              return r = r === "0" ? "0px" : r, {
                "& > :not([hidden]) ~ :not([hidden])": {
                  "--tw-space-y-reverse": "0",
                  "margin-top": "calc(".concat(r, " * calc(1 - var(--tw-space-y-reverse)))"),
                  "margin-bottom": "calc(".concat(r, " * var(--tw-space-y-reverse))")
                }
              };
            }
          }, {
            values: t("space"),
            supportsNegativeValues: !0
          }), e({
            ".space-y-reverse > :not([hidden]) ~ :not([hidden])": {
              "--tw-space-y-reverse": "1"
            },
            ".space-x-reverse > :not([hidden]) ~ :not([hidden])": {
              "--tw-space-x-reverse": "1"
            }
          });
        },
        divideWidth: function divideWidth(_ref159) {
          var i = _ref159.matchUtilities,
            e = _ref159.addUtilities,
            t = _ref159.theme;
          i({
            "divide-x": function divideX(r) {
              return r = r === "0" ? "0px" : r, {
                "& > :not([hidden]) ~ :not([hidden])": {
                  "@defaults border-width": {},
                  "--tw-divide-x-reverse": "0",
                  "border-right-width": "calc(".concat(r, " * var(--tw-divide-x-reverse))"),
                  "border-left-width": "calc(".concat(r, " * calc(1 - var(--tw-divide-x-reverse)))")
                }
              };
            },
            "divide-y": function divideY(r) {
              return r = r === "0" ? "0px" : r, {
                "& > :not([hidden]) ~ :not([hidden])": {
                  "@defaults border-width": {},
                  "--tw-divide-y-reverse": "0",
                  "border-top-width": "calc(".concat(r, " * calc(1 - var(--tw-divide-y-reverse)))"),
                  "border-bottom-width": "calc(".concat(r, " * var(--tw-divide-y-reverse))")
                }
              };
            }
          }, {
            values: t("divideWidth"),
            type: ["line-width", "length", "any"]
          }), e({
            ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": {
              "@defaults border-width": {},
              "--tw-divide-y-reverse": "1"
            },
            ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": {
              "@defaults border-width": {},
              "--tw-divide-x-reverse": "1"
            }
          });
        },
        divideStyle: function divideStyle(_ref160) {
          var i = _ref160.addUtilities;
          i({
            ".divide-solid > :not([hidden]) ~ :not([hidden])": {
              "border-style": "solid"
            },
            ".divide-dashed > :not([hidden]) ~ :not([hidden])": {
              "border-style": "dashed"
            },
            ".divide-dotted > :not([hidden]) ~ :not([hidden])": {
              "border-style": "dotted"
            },
            ".divide-double > :not([hidden]) ~ :not([hidden])": {
              "border-style": "double"
            },
            ".divide-none > :not([hidden]) ~ :not([hidden])": {
              "border-style": "none"
            }
          });
        },
        divideColor: function divideColor(_ref161) {
          var i = _ref161.matchUtilities,
            e = _ref161.theme,
            t = _ref161.corePlugins;
          i({
            divide: function divide(r) {
              return t("divideOpacity") ? _defineProperty({}, "& > :not([hidden]) ~ :not([hidden])", se({
                color: r,
                property: "border-color",
                variable: "--tw-divide-opacity"
              })) : _defineProperty({}, "& > :not([hidden]) ~ :not([hidden])", {
                "border-color": L(r)
              });
            }
          }, {
            values: function (_ref164) {
              var r = _ref164.DEFAULT,
                n = _objectWithoutProperties(_ref164, _excluded5);
              return n;
            }(re(e("divideColor"))),
            type: ["color", "any"]
          });
        },
        divideOpacity: function divideOpacity(_ref165) {
          var i = _ref165.matchUtilities,
            e = _ref165.theme;
          i({
            "divide-opacity": function divideOpacity(t) {
              return _defineProperty({}, "& > :not([hidden]) ~ :not([hidden])", {
                "--tw-divide-opacity": t
              });
            }
          }, {
            values: e("divideOpacity")
          });
        },
        placeSelf: function placeSelf(_ref167) {
          var i = _ref167.addUtilities;
          i({
            ".place-self-auto": {
              "place-self": "auto"
            },
            ".place-self-start": {
              "place-self": "start"
            },
            ".place-self-end": {
              "place-self": "end"
            },
            ".place-self-center": {
              "place-self": "center"
            },
            ".place-self-stretch": {
              "place-self": "stretch"
            }
          });
        },
        alignSelf: function alignSelf(_ref168) {
          var i = _ref168.addUtilities;
          i({
            ".self-auto": {
              "align-self": "auto"
            },
            ".self-start": {
              "align-self": "flex-start"
            },
            ".self-end": {
              "align-self": "flex-end"
            },
            ".self-center": {
              "align-self": "center"
            },
            ".self-stretch": {
              "align-self": "stretch"
            },
            ".self-baseline": {
              "align-self": "baseline"
            }
          });
        },
        justifySelf: function justifySelf(_ref169) {
          var i = _ref169.addUtilities;
          i({
            ".justify-self-auto": {
              "justify-self": "auto"
            },
            ".justify-self-start": {
              "justify-self": "start"
            },
            ".justify-self-end": {
              "justify-self": "end"
            },
            ".justify-self-center": {
              "justify-self": "center"
            },
            ".justify-self-stretch": {
              "justify-self": "stretch"
            }
          });
        },
        overflow: function overflow(_ref170) {
          var i = _ref170.addUtilities;
          i({
            ".overflow-auto": {
              overflow: "auto"
            },
            ".overflow-hidden": {
              overflow: "hidden"
            },
            ".overflow-clip": {
              overflow: "clip"
            },
            ".overflow-visible": {
              overflow: "visible"
            },
            ".overflow-scroll": {
              overflow: "scroll"
            },
            ".overflow-x-auto": {
              "overflow-x": "auto"
            },
            ".overflow-y-auto": {
              "overflow-y": "auto"
            },
            ".overflow-x-hidden": {
              "overflow-x": "hidden"
            },
            ".overflow-y-hidden": {
              "overflow-y": "hidden"
            },
            ".overflow-x-clip": {
              "overflow-x": "clip"
            },
            ".overflow-y-clip": {
              "overflow-y": "clip"
            },
            ".overflow-x-visible": {
              "overflow-x": "visible"
            },
            ".overflow-y-visible": {
              "overflow-y": "visible"
            },
            ".overflow-x-scroll": {
              "overflow-x": "scroll"
            },
            ".overflow-y-scroll": {
              "overflow-y": "scroll"
            }
          });
        },
        overscrollBehavior: function overscrollBehavior(_ref171) {
          var i = _ref171.addUtilities;
          i({
            ".overscroll-auto": {
              "overscroll-behavior": "auto"
            },
            ".overscroll-contain": {
              "overscroll-behavior": "contain"
            },
            ".overscroll-none": {
              "overscroll-behavior": "none"
            },
            ".overscroll-y-auto": {
              "overscroll-behavior-y": "auto"
            },
            ".overscroll-y-contain": {
              "overscroll-behavior-y": "contain"
            },
            ".overscroll-y-none": {
              "overscroll-behavior-y": "none"
            },
            ".overscroll-x-auto": {
              "overscroll-behavior-x": "auto"
            },
            ".overscroll-x-contain": {
              "overscroll-behavior-x": "contain"
            },
            ".overscroll-x-none": {
              "overscroll-behavior-x": "none"
            }
          });
        },
        scrollBehavior: function scrollBehavior(_ref172) {
          var i = _ref172.addUtilities;
          i({
            ".scroll-auto": {
              "scroll-behavior": "auto"
            },
            ".scroll-smooth": {
              "scroll-behavior": "smooth"
            }
          });
        },
        textOverflow: function textOverflow(_ref173) {
          var i = _ref173.addUtilities;
          i({
            ".truncate": {
              overflow: "hidden",
              "text-overflow": "ellipsis",
              "white-space": "nowrap"
            },
            ".overflow-ellipsis": {
              "text-overflow": "ellipsis"
            },
            ".text-ellipsis": {
              "text-overflow": "ellipsis"
            },
            ".text-clip": {
              "text-overflow": "clip"
            }
          });
        },
        hyphens: function hyphens(_ref174) {
          var i = _ref174.addUtilities;
          i({
            ".hyphens-none": {
              hyphens: "none"
            },
            ".hyphens-manual": {
              hyphens: "manual"
            },
            ".hyphens-auto": {
              hyphens: "auto"
            }
          });
        },
        whitespace: function whitespace(_ref175) {
          var i = _ref175.addUtilities;
          i({
            ".whitespace-normal": {
              "white-space": "normal"
            },
            ".whitespace-nowrap": {
              "white-space": "nowrap"
            },
            ".whitespace-pre": {
              "white-space": "pre"
            },
            ".whitespace-pre-line": {
              "white-space": "pre-line"
            },
            ".whitespace-pre-wrap": {
              "white-space": "pre-wrap"
            },
            ".whitespace-break-spaces": {
              "white-space": "break-spaces"
            }
          });
        },
        textWrap: function textWrap(_ref176) {
          var i = _ref176.addUtilities;
          i({
            ".text-wrap": {
              "text-wrap": "wrap"
            },
            ".text-nowrap": {
              "text-wrap": "nowrap"
            },
            ".text-balance": {
              "text-wrap": "balance"
            },
            ".text-pretty": {
              "text-wrap": "pretty"
            }
          });
        },
        wordBreak: function wordBreak(_ref177) {
          var i = _ref177.addUtilities;
          i({
            ".break-normal": {
              "overflow-wrap": "normal",
              "word-break": "normal"
            },
            ".break-words": {
              "overflow-wrap": "break-word"
            },
            ".break-all": {
              "word-break": "break-all"
            },
            ".break-keep": {
              "word-break": "keep-all"
            }
          });
        },
        borderRadius: P("borderRadius", [["rounded", ["border-radius"]], [["rounded-s", ["border-start-start-radius", "border-end-start-radius"]], ["rounded-e", ["border-start-end-radius", "border-end-end-radius"]], ["rounded-t", ["border-top-left-radius", "border-top-right-radius"]], ["rounded-r", ["border-top-right-radius", "border-bottom-right-radius"]], ["rounded-b", ["border-bottom-right-radius", "border-bottom-left-radius"]], ["rounded-l", ["border-top-left-radius", "border-bottom-left-radius"]]], [["rounded-ss", ["border-start-start-radius"]], ["rounded-se", ["border-start-end-radius"]], ["rounded-ee", ["border-end-end-radius"]], ["rounded-es", ["border-end-start-radius"]], ["rounded-tl", ["border-top-left-radius"]], ["rounded-tr", ["border-top-right-radius"]], ["rounded-br", ["border-bottom-right-radius"]], ["rounded-bl", ["border-bottom-left-radius"]]]]),
        borderWidth: P("borderWidth", [["border", [["@defaults border-width", {}], "border-width"]], [["border-x", [["@defaults border-width", {}], "border-left-width", "border-right-width"]], ["border-y", [["@defaults border-width", {}], "border-top-width", "border-bottom-width"]]], [["border-s", [["@defaults border-width", {}], "border-inline-start-width"]], ["border-e", [["@defaults border-width", {}], "border-inline-end-width"]], ["border-t", [["@defaults border-width", {}], "border-top-width"]], ["border-r", [["@defaults border-width", {}], "border-right-width"]], ["border-b", [["@defaults border-width", {}], "border-bottom-width"]], ["border-l", [["@defaults border-width", {}], "border-left-width"]]]], {
          type: ["line-width", "length"]
        }),
        borderStyle: function borderStyle(_ref178) {
          var i = _ref178.addUtilities;
          i({
            ".border-solid": {
              "border-style": "solid"
            },
            ".border-dashed": {
              "border-style": "dashed"
            },
            ".border-dotted": {
              "border-style": "dotted"
            },
            ".border-double": {
              "border-style": "double"
            },
            ".border-hidden": {
              "border-style": "hidden"
            },
            ".border-none": {
              "border-style": "none"
            }
          });
        },
        borderColor: function borderColor(_ref179) {
          var i = _ref179.matchUtilities,
            e = _ref179.theme,
            t = _ref179.corePlugins;
          i({
            border: function border(r) {
              return t("borderOpacity") ? se({
                color: r,
                property: "border-color",
                variable: "--tw-border-opacity"
              }) : {
                "border-color": L(r)
              };
            }
          }, {
            values: function (_ref180) {
              var r = _ref180.DEFAULT,
                n = _objectWithoutProperties(_ref180, _excluded6);
              return n;
            }(re(e("borderColor"))),
            type: ["color", "any"]
          }), i({
            "border-x": function borderX(r) {
              return t("borderOpacity") ? se({
                color: r,
                property: ["border-left-color", "border-right-color"],
                variable: "--tw-border-opacity"
              }) : {
                "border-left-color": L(r),
                "border-right-color": L(r)
              };
            },
            "border-y": function borderY(r) {
              return t("borderOpacity") ? se({
                color: r,
                property: ["border-top-color", "border-bottom-color"],
                variable: "--tw-border-opacity"
              }) : {
                "border-top-color": L(r),
                "border-bottom-color": L(r)
              };
            }
          }, {
            values: function (_ref181) {
              var r = _ref181.DEFAULT,
                n = _objectWithoutProperties(_ref181, _excluded7);
              return n;
            }(re(e("borderColor"))),
            type: ["color", "any"]
          }), i({
            "border-s": function borderS(r) {
              return t("borderOpacity") ? se({
                color: r,
                property: "border-inline-start-color",
                variable: "--tw-border-opacity"
              }) : {
                "border-inline-start-color": L(r)
              };
            },
            "border-e": function borderE(r) {
              return t("borderOpacity") ? se({
                color: r,
                property: "border-inline-end-color",
                variable: "--tw-border-opacity"
              }) : {
                "border-inline-end-color": L(r)
              };
            },
            "border-t": function borderT(r) {
              return t("borderOpacity") ? se({
                color: r,
                property: "border-top-color",
                variable: "--tw-border-opacity"
              }) : {
                "border-top-color": L(r)
              };
            },
            "border-r": function borderR(r) {
              return t("borderOpacity") ? se({
                color: r,
                property: "border-right-color",
                variable: "--tw-border-opacity"
              }) : {
                "border-right-color": L(r)
              };
            },
            "border-b": function borderB(r) {
              return t("borderOpacity") ? se({
                color: r,
                property: "border-bottom-color",
                variable: "--tw-border-opacity"
              }) : {
                "border-bottom-color": L(r)
              };
            },
            "border-l": function borderL(r) {
              return t("borderOpacity") ? se({
                color: r,
                property: "border-left-color",
                variable: "--tw-border-opacity"
              }) : {
                "border-left-color": L(r)
              };
            }
          }, {
            values: function (_ref182) {
              var r = _ref182.DEFAULT,
                n = _objectWithoutProperties(_ref182, _excluded8);
              return n;
            }(re(e("borderColor"))),
            type: ["color", "any"]
          });
        },
        borderOpacity: P("borderOpacity", [["border-opacity", ["--tw-border-opacity"]]]),
        backgroundColor: function backgroundColor(_ref183) {
          var i = _ref183.matchUtilities,
            e = _ref183.theme,
            t = _ref183.corePlugins;
          i({
            bg: function bg(r) {
              return t("backgroundOpacity") ? se({
                color: r,
                property: "background-color",
                variable: "--tw-bg-opacity"
              }) : {
                "background-color": L(r)
              };
            }
          }, {
            values: re(e("backgroundColor")),
            type: ["color", "any"]
          });
        },
        backgroundOpacity: P("backgroundOpacity", [["bg-opacity", ["--tw-bg-opacity"]]]),
        backgroundImage: P("backgroundImage", [["bg", ["background-image"]]], {
          type: ["lookup", "image", "url"]
        }),
        gradientColorStops: function () {
          function i(e) {
            return Ie(e, 0, "rgb(255 255 255 / 0)");
          }
          return function (_ref184) {
            var e = _ref184.matchUtilities,
              t = _ref184.theme,
              r = _ref184.addDefaults;
            r("gradient-color-stops", {
              "--tw-gradient-from-position": " ",
              "--tw-gradient-via-position": " ",
              "--tw-gradient-to-position": " "
            });
            var n = {
                values: re(t("gradientColorStops")),
                type: ["color", "any"]
              },
              a = {
                values: t("gradientColorStopPositions"),
                type: ["length", "percentage"]
              };
            e({
              from: function from(s) {
                var o = i(s);
                return {
                  "@defaults gradient-color-stops": {},
                  "--tw-gradient-from": "".concat(L(s), " var(--tw-gradient-from-position)"),
                  "--tw-gradient-to": "".concat(o, " var(--tw-gradient-to-position)"),
                  "--tw-gradient-stops": "var(--tw-gradient-from), var(--tw-gradient-to)"
                };
              }
            }, n), e({
              from: function from(s) {
                return {
                  "--tw-gradient-from-position": s
                };
              }
            }, a), e({
              via: function via(s) {
                var o = i(s);
                return {
                  "@defaults gradient-color-stops": {},
                  "--tw-gradient-to": "".concat(o, "  var(--tw-gradient-to-position)"),
                  "--tw-gradient-stops": "var(--tw-gradient-from), ".concat(L(s), " var(--tw-gradient-via-position), var(--tw-gradient-to)")
                };
              }
            }, n), e({
              via: function via(s) {
                return {
                  "--tw-gradient-via-position": s
                };
              }
            }, a), e({
              to: function to(s) {
                return {
                  "@defaults gradient-color-stops": {},
                  "--tw-gradient-to": "".concat(L(s), " var(--tw-gradient-to-position)")
                };
              }
            }, n), e({
              to: function to(s) {
                return {
                  "--tw-gradient-to-position": s
                };
              }
            }, a);
          };
        }(),
        boxDecorationBreak: function boxDecorationBreak(_ref185) {
          var i = _ref185.addUtilities;
          i({
            ".decoration-slice": {
              "box-decoration-break": "slice"
            },
            ".decoration-clone": {
              "box-decoration-break": "clone"
            },
            ".box-decoration-slice": {
              "box-decoration-break": "slice"
            },
            ".box-decoration-clone": {
              "box-decoration-break": "clone"
            }
          });
        },
        backgroundSize: P("backgroundSize", [["bg", ["background-size"]]], {
          type: ["lookup", "length", "percentage", "size"]
        }),
        backgroundAttachment: function backgroundAttachment(_ref186) {
          var i = _ref186.addUtilities;
          i({
            ".bg-fixed": {
              "background-attachment": "fixed"
            },
            ".bg-local": {
              "background-attachment": "local"
            },
            ".bg-scroll": {
              "background-attachment": "scroll"
            }
          });
        },
        backgroundClip: function backgroundClip(_ref187) {
          var i = _ref187.addUtilities;
          i({
            ".bg-clip-border": {
              "background-clip": "border-box"
            },
            ".bg-clip-padding": {
              "background-clip": "padding-box"
            },
            ".bg-clip-content": {
              "background-clip": "content-box"
            },
            ".bg-clip-text": {
              "background-clip": "text"
            }
          });
        },
        backgroundPosition: P("backgroundPosition", [["bg", ["background-position"]]], {
          type: ["lookup", ["position", {
            preferOnConflict: !0
          }]]
        }),
        backgroundRepeat: function backgroundRepeat(_ref188) {
          var i = _ref188.addUtilities;
          i({
            ".bg-repeat": {
              "background-repeat": "repeat"
            },
            ".bg-no-repeat": {
              "background-repeat": "no-repeat"
            },
            ".bg-repeat-x": {
              "background-repeat": "repeat-x"
            },
            ".bg-repeat-y": {
              "background-repeat": "repeat-y"
            },
            ".bg-repeat-round": {
              "background-repeat": "round"
            },
            ".bg-repeat-space": {
              "background-repeat": "space"
            }
          });
        },
        backgroundOrigin: function backgroundOrigin(_ref189) {
          var i = _ref189.addUtilities;
          i({
            ".bg-origin-border": {
              "background-origin": "border-box"
            },
            ".bg-origin-padding": {
              "background-origin": "padding-box"
            },
            ".bg-origin-content": {
              "background-origin": "content-box"
            }
          });
        },
        fill: function fill(_ref190) {
          var i = _ref190.matchUtilities,
            e = _ref190.theme;
          i({
            fill: function fill(t) {
              return {
                fill: L(t)
              };
            }
          }, {
            values: re(e("fill")),
            type: ["color", "any"]
          });
        },
        stroke: function stroke(_ref191) {
          var i = _ref191.matchUtilities,
            e = _ref191.theme;
          i({
            stroke: function stroke(t) {
              return {
                stroke: L(t)
              };
            }
          }, {
            values: re(e("stroke")),
            type: ["color", "url", "any"]
          });
        },
        strokeWidth: P("strokeWidth", [["stroke", ["stroke-width"]]], {
          type: ["length", "number", "percentage"]
        }),
        objectFit: function objectFit(_ref192) {
          var i = _ref192.addUtilities;
          i({
            ".object-contain": {
              "object-fit": "contain"
            },
            ".object-cover": {
              "object-fit": "cover"
            },
            ".object-fill": {
              "object-fit": "fill"
            },
            ".object-none": {
              "object-fit": "none"
            },
            ".object-scale-down": {
              "object-fit": "scale-down"
            }
          });
        },
        objectPosition: P("objectPosition", [["object", ["object-position"]]]),
        padding: P("padding", [["p", ["padding"]], [["px", ["padding-left", "padding-right"]], ["py", ["padding-top", "padding-bottom"]]], [["ps", ["padding-inline-start"]], ["pe", ["padding-inline-end"]], ["pt", ["padding-top"]], ["pr", ["padding-right"]], ["pb", ["padding-bottom"]], ["pl", ["padding-left"]]]]),
        textAlign: function textAlign(_ref193) {
          var i = _ref193.addUtilities;
          i({
            ".text-left": {
              "text-align": "left"
            },
            ".text-center": {
              "text-align": "center"
            },
            ".text-right": {
              "text-align": "right"
            },
            ".text-justify": {
              "text-align": "justify"
            },
            ".text-start": {
              "text-align": "start"
            },
            ".text-end": {
              "text-align": "end"
            }
          });
        },
        textIndent: P("textIndent", [["indent", ["text-indent"]]], {
          supportsNegativeValues: !0
        }),
        verticalAlign: function verticalAlign(_ref194) {
          var i = _ref194.addUtilities,
            e = _ref194.matchUtilities;
          i({
            ".align-baseline": {
              "vertical-align": "baseline"
            },
            ".align-top": {
              "vertical-align": "top"
            },
            ".align-middle": {
              "vertical-align": "middle"
            },
            ".align-bottom": {
              "vertical-align": "bottom"
            },
            ".align-text-top": {
              "vertical-align": "text-top"
            },
            ".align-text-bottom": {
              "vertical-align": "text-bottom"
            },
            ".align-sub": {
              "vertical-align": "sub"
            },
            ".align-super": {
              "vertical-align": "super"
            }
          }), e({
            align: function align(t) {
              return {
                "vertical-align": t
              };
            }
          });
        },
        fontFamily: function fontFamily(_ref195) {
          var i = _ref195.matchUtilities,
            e = _ref195.theme;
          i({
            font: function font(t) {
              var _ref196 = Array.isArray(t) && ie(t[1]) ? t : [t],
                _ref197 = _slicedToArray(_ref196, 2),
                r = _ref197[0],
                _ref197$ = _ref197[1],
                n = _ref197$ === void 0 ? {} : _ref197$,
                a = n.fontFeatureSettings,
                s = n.fontVariationSettings;
              return _objectSpread(_objectSpread({
                "font-family": Array.isArray(r) ? r.join(", ") : r
              }, a === void 0 ? {} : {
                "font-feature-settings": a
              }), s === void 0 ? {} : {
                "font-variation-settings": s
              });
            }
          }, {
            values: e("fontFamily"),
            type: ["lookup", "generic-name", "family-name"]
          });
        },
        fontSize: function fontSize(_ref198) {
          var i = _ref198.matchUtilities,
            e = _ref198.theme;
          i({
            text: function text(t, _ref199) {
              var r = _ref199.modifier;
              var _ref200 = Array.isArray(t) ? t : [t],
                _ref201 = _slicedToArray(_ref200, 2),
                n = _ref201[0],
                a = _ref201[1];
              if (r) return {
                "font-size": n,
                "line-height": r
              };
              var _ref202 = ie(a) ? a : {
                  lineHeight: a
                },
                s = _ref202.lineHeight,
                o = _ref202.letterSpacing,
                u = _ref202.fontWeight;
              return _objectSpread(_objectSpread(_objectSpread({
                "font-size": n
              }, s === void 0 ? {} : {
                "line-height": s
              }), o === void 0 ? {} : {
                "letter-spacing": o
              }), u === void 0 ? {} : {
                "font-weight": u
              });
            }
          }, {
            values: e("fontSize"),
            modifiers: e("lineHeight"),
            type: ["absolute-size", "relative-size", "length", "percentage"]
          });
        },
        fontWeight: P("fontWeight", [["font", ["fontWeight"]]], {
          type: ["lookup", "number", "any"]
        }),
        textTransform: function textTransform(_ref203) {
          var i = _ref203.addUtilities;
          i({
            ".uppercase": {
              "text-transform": "uppercase"
            },
            ".lowercase": {
              "text-transform": "lowercase"
            },
            ".capitalize": {
              "text-transform": "capitalize"
            },
            ".normal-case": {
              "text-transform": "none"
            }
          });
        },
        fontStyle: function fontStyle(_ref204) {
          var i = _ref204.addUtilities;
          i({
            ".italic": {
              "font-style": "italic"
            },
            ".not-italic": {
              "font-style": "normal"
            }
          });
        },
        fontVariantNumeric: function fontVariantNumeric(_ref205) {
          var i = _ref205.addDefaults,
            e = _ref205.addUtilities;
          var t = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
          i("font-variant-numeric", {
            "--tw-ordinal": " ",
            "--tw-slashed-zero": " ",
            "--tw-numeric-figure": " ",
            "--tw-numeric-spacing": " ",
            "--tw-numeric-fraction": " "
          }), e({
            ".normal-nums": {
              "font-variant-numeric": "normal"
            },
            ".ordinal": {
              "@defaults font-variant-numeric": {},
              "--tw-ordinal": "ordinal",
              "font-variant-numeric": t
            },
            ".slashed-zero": {
              "@defaults font-variant-numeric": {},
              "--tw-slashed-zero": "slashed-zero",
              "font-variant-numeric": t
            },
            ".lining-nums": {
              "@defaults font-variant-numeric": {},
              "--tw-numeric-figure": "lining-nums",
              "font-variant-numeric": t
            },
            ".oldstyle-nums": {
              "@defaults font-variant-numeric": {},
              "--tw-numeric-figure": "oldstyle-nums",
              "font-variant-numeric": t
            },
            ".proportional-nums": {
              "@defaults font-variant-numeric": {},
              "--tw-numeric-spacing": "proportional-nums",
              "font-variant-numeric": t
            },
            ".tabular-nums": {
              "@defaults font-variant-numeric": {},
              "--tw-numeric-spacing": "tabular-nums",
              "font-variant-numeric": t
            },
            ".diagonal-fractions": {
              "@defaults font-variant-numeric": {},
              "--tw-numeric-fraction": "diagonal-fractions",
              "font-variant-numeric": t
            },
            ".stacked-fractions": {
              "@defaults font-variant-numeric": {},
              "--tw-numeric-fraction": "stacked-fractions",
              "font-variant-numeric": t
            }
          });
        },
        lineHeight: P("lineHeight", [["leading", ["lineHeight"]]]),
        letterSpacing: P("letterSpacing", [["tracking", ["letterSpacing"]]], {
          supportsNegativeValues: !0
        }),
        textColor: function textColor(_ref206) {
          var i = _ref206.matchUtilities,
            e = _ref206.theme,
            t = _ref206.corePlugins;
          i({
            text: function text(r) {
              return t("textOpacity") ? se({
                color: r,
                property: "color",
                variable: "--tw-text-opacity"
              }) : {
                color: L(r)
              };
            }
          }, {
            values: re(e("textColor")),
            type: ["color", "any"]
          });
        },
        textOpacity: P("textOpacity", [["text-opacity", ["--tw-text-opacity"]]]),
        textDecoration: function textDecoration(_ref207) {
          var i = _ref207.addUtilities;
          i({
            ".underline": {
              "text-decoration-line": "underline"
            },
            ".overline": {
              "text-decoration-line": "overline"
            },
            ".line-through": {
              "text-decoration-line": "line-through"
            },
            ".no-underline": {
              "text-decoration-line": "none"
            }
          });
        },
        textDecorationColor: function textDecorationColor(_ref208) {
          var i = _ref208.matchUtilities,
            e = _ref208.theme;
          i({
            decoration: function decoration(t) {
              return {
                "text-decoration-color": L(t)
              };
            }
          }, {
            values: re(e("textDecorationColor")),
            type: ["color", "any"]
          });
        },
        textDecorationStyle: function textDecorationStyle(_ref209) {
          var i = _ref209.addUtilities;
          i({
            ".decoration-solid": {
              "text-decoration-style": "solid"
            },
            ".decoration-double": {
              "text-decoration-style": "double"
            },
            ".decoration-dotted": {
              "text-decoration-style": "dotted"
            },
            ".decoration-dashed": {
              "text-decoration-style": "dashed"
            },
            ".decoration-wavy": {
              "text-decoration-style": "wavy"
            }
          });
        },
        textDecorationThickness: P("textDecorationThickness", [["decoration", ["text-decoration-thickness"]]], {
          type: ["length", "percentage"]
        }),
        textUnderlineOffset: P("textUnderlineOffset", [["underline-offset", ["text-underline-offset"]]], {
          type: ["length", "percentage", "any"]
        }),
        fontSmoothing: function fontSmoothing(_ref210) {
          var i = _ref210.addUtilities;
          i({
            ".antialiased": {
              "-webkit-font-smoothing": "antialiased",
              "-moz-osx-font-smoothing": "grayscale"
            },
            ".subpixel-antialiased": {
              "-webkit-font-smoothing": "auto",
              "-moz-osx-font-smoothing": "auto"
            }
          });
        },
        placeholderColor: function placeholderColor(_ref211) {
          var i = _ref211.matchUtilities,
            e = _ref211.theme,
            t = _ref211.corePlugins;
          i({
            placeholder: function placeholder(r) {
              return t("placeholderOpacity") ? {
                "&::placeholder": se({
                  color: r,
                  property: "color",
                  variable: "--tw-placeholder-opacity"
                })
              } : {
                "&::placeholder": {
                  color: L(r)
                }
              };
            }
          }, {
            values: re(e("placeholderColor")),
            type: ["color", "any"]
          });
        },
        placeholderOpacity: function placeholderOpacity(_ref212) {
          var i = _ref212.matchUtilities,
            e = _ref212.theme;
          i({
            "placeholder-opacity": function placeholderOpacity(t) {
              return _defineProperty({}, "&::placeholder", {
                "--tw-placeholder-opacity": t
              });
            }
          }, {
            values: e("placeholderOpacity")
          });
        },
        caretColor: function caretColor(_ref214) {
          var i = _ref214.matchUtilities,
            e = _ref214.theme;
          i({
            caret: function caret(t) {
              return {
                "caret-color": L(t)
              };
            }
          }, {
            values: re(e("caretColor")),
            type: ["color", "any"]
          });
        },
        accentColor: function accentColor(_ref215) {
          var i = _ref215.matchUtilities,
            e = _ref215.theme;
          i({
            accent: function accent(t) {
              return {
                "accent-color": L(t)
              };
            }
          }, {
            values: re(e("accentColor")),
            type: ["color", "any"]
          });
        },
        opacity: P("opacity", [["opacity", ["opacity"]]]),
        backgroundBlendMode: function backgroundBlendMode(_ref216) {
          var i = _ref216.addUtilities;
          i({
            ".bg-blend-normal": {
              "background-blend-mode": "normal"
            },
            ".bg-blend-multiply": {
              "background-blend-mode": "multiply"
            },
            ".bg-blend-screen": {
              "background-blend-mode": "screen"
            },
            ".bg-blend-overlay": {
              "background-blend-mode": "overlay"
            },
            ".bg-blend-darken": {
              "background-blend-mode": "darken"
            },
            ".bg-blend-lighten": {
              "background-blend-mode": "lighten"
            },
            ".bg-blend-color-dodge": {
              "background-blend-mode": "color-dodge"
            },
            ".bg-blend-color-burn": {
              "background-blend-mode": "color-burn"
            },
            ".bg-blend-hard-light": {
              "background-blend-mode": "hard-light"
            },
            ".bg-blend-soft-light": {
              "background-blend-mode": "soft-light"
            },
            ".bg-blend-difference": {
              "background-blend-mode": "difference"
            },
            ".bg-blend-exclusion": {
              "background-blend-mode": "exclusion"
            },
            ".bg-blend-hue": {
              "background-blend-mode": "hue"
            },
            ".bg-blend-saturation": {
              "background-blend-mode": "saturation"
            },
            ".bg-blend-color": {
              "background-blend-mode": "color"
            },
            ".bg-blend-luminosity": {
              "background-blend-mode": "luminosity"
            }
          });
        },
        mixBlendMode: function mixBlendMode(_ref217) {
          var i = _ref217.addUtilities;
          i({
            ".mix-blend-normal": {
              "mix-blend-mode": "normal"
            },
            ".mix-blend-multiply": {
              "mix-blend-mode": "multiply"
            },
            ".mix-blend-screen": {
              "mix-blend-mode": "screen"
            },
            ".mix-blend-overlay": {
              "mix-blend-mode": "overlay"
            },
            ".mix-blend-darken": {
              "mix-blend-mode": "darken"
            },
            ".mix-blend-lighten": {
              "mix-blend-mode": "lighten"
            },
            ".mix-blend-color-dodge": {
              "mix-blend-mode": "color-dodge"
            },
            ".mix-blend-color-burn": {
              "mix-blend-mode": "color-burn"
            },
            ".mix-blend-hard-light": {
              "mix-blend-mode": "hard-light"
            },
            ".mix-blend-soft-light": {
              "mix-blend-mode": "soft-light"
            },
            ".mix-blend-difference": {
              "mix-blend-mode": "difference"
            },
            ".mix-blend-exclusion": {
              "mix-blend-mode": "exclusion"
            },
            ".mix-blend-hue": {
              "mix-blend-mode": "hue"
            },
            ".mix-blend-saturation": {
              "mix-blend-mode": "saturation"
            },
            ".mix-blend-color": {
              "mix-blend-mode": "color"
            },
            ".mix-blend-luminosity": {
              "mix-blend-mode": "luminosity"
            },
            ".mix-blend-plus-darker": {
              "mix-blend-mode": "plus-darker"
            },
            ".mix-blend-plus-lighter": {
              "mix-blend-mode": "plus-lighter"
            }
          });
        },
        boxShadow: function () {
          var i = Ge("boxShadow"),
            e = ["var(--tw-ring-offset-shadow, 0 0 #0000)", "var(--tw-ring-shadow, 0 0 #0000)", "var(--tw-shadow)"].join(", ");
          return function (_ref218) {
            var t = _ref218.matchUtilities,
              r = _ref218.addDefaults,
              n = _ref218.theme;
            r("box-shadow", {
              "--tw-ring-offset-shadow": "0 0 #0000",
              "--tw-ring-shadow": "0 0 #0000",
              "--tw-shadow": "0 0 #0000",
              "--tw-shadow-colored": "0 0 #0000"
            }), t({
              shadow: function shadow(a) {
                a = i(a);
                var s = yi(a);
                var _iterator62 = _createForOfIteratorHelper(s),
                  _step62;
                try {
                  for (_iterator62.s(); !(_step62 = _iterator62.n()).done;) {
                    var o = _step62.value;
                    !o.valid || (o.color = "var(--tw-shadow-color)");
                  }
                } catch (err) {
                  _iterator62.e(err);
                } finally {
                  _iterator62.f();
                }
                return {
                  "@defaults box-shadow": {},
                  "--tw-shadow": a === "none" ? "0 0 #0000" : a,
                  "--tw-shadow-colored": a === "none" ? "0 0 #0000" : Tu(s),
                  "box-shadow": e
                };
              }
            }, {
              values: n("boxShadow"),
              type: ["shadow"]
            });
          };
        }(),
        boxShadowColor: function boxShadowColor(_ref219) {
          var i = _ref219.matchUtilities,
            e = _ref219.theme;
          i({
            shadow: function shadow(t) {
              return {
                "--tw-shadow-color": L(t),
                "--tw-shadow": "var(--tw-shadow-colored)"
              };
            }
          }, {
            values: re(e("boxShadowColor")),
            type: ["color", "any"]
          });
        },
        outlineStyle: function outlineStyle(_ref220) {
          var i = _ref220.addUtilities;
          i({
            ".outline-none": {
              outline: "2px solid transparent",
              "outline-offset": "2px"
            },
            ".outline": {
              "outline-style": "solid"
            },
            ".outline-dashed": {
              "outline-style": "dashed"
            },
            ".outline-dotted": {
              "outline-style": "dotted"
            },
            ".outline-double": {
              "outline-style": "double"
            }
          });
        },
        outlineWidth: P("outlineWidth", [["outline", ["outline-width"]]], {
          type: ["length", "number", "percentage"]
        }),
        outlineOffset: P("outlineOffset", [["outline-offset", ["outline-offset"]]], {
          type: ["length", "number", "percentage", "any"],
          supportsNegativeValues: !0
        }),
        outlineColor: function outlineColor(_ref221) {
          var i = _ref221.matchUtilities,
            e = _ref221.theme;
          i({
            outline: function outline(t) {
              return {
                "outline-color": L(t)
              };
            }
          }, {
            values: re(e("outlineColor")),
            type: ["color", "any"]
          });
        },
        ringWidth: function ringWidth(_ref222) {
          var i = _ref222.matchUtilities,
            e = _ref222.addDefaults,
            t = _ref222.addUtilities,
            r = _ref222.theme,
            n = _ref222.config;
          var a = function (_r12, _r13) {
            if (K(n(), "respectDefaultRingColorOpacity")) return r("ringColor.DEFAULT");
            var s = r("ringOpacity.DEFAULT", "0.5");
            return (_r12 = r("ringColor")) !== null && _r12 !== void 0 && _r12.DEFAULT ? Ie((_r13 = r("ringColor")) === null || _r13 === void 0 ? void 0 : _r13.DEFAULT, s, "rgb(147 197 253 / ".concat(s, ")")) : "rgb(147 197 253 / ".concat(s, ")");
          }();
          e("ring-width", {
            "--tw-ring-inset": " ",
            "--tw-ring-offset-width": r("ringOffsetWidth.DEFAULT", "0px"),
            "--tw-ring-offset-color": r("ringOffsetColor.DEFAULT", "#fff"),
            "--tw-ring-color": a,
            "--tw-ring-offset-shadow": "0 0 #0000",
            "--tw-ring-shadow": "0 0 #0000",
            "--tw-shadow": "0 0 #0000",
            "--tw-shadow-colored": "0 0 #0000"
          }), i({
            ring: function ring(s) {
              return {
                "@defaults ring-width": {},
                "--tw-ring-offset-shadow": "var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)",
                "--tw-ring-shadow": "var(--tw-ring-inset) 0 0 0 calc(".concat(s, " + var(--tw-ring-offset-width)) var(--tw-ring-color)"),
                "box-shadow": ["var(--tw-ring-offset-shadow)", "var(--tw-ring-shadow)", "var(--tw-shadow, 0 0 #0000)"].join(", ")
              };
            }
          }, {
            values: r("ringWidth"),
            type: "length"
          }), t({
            ".ring-inset": {
              "@defaults ring-width": {},
              "--tw-ring-inset": "inset"
            }
          });
        },
        ringColor: function ringColor(_ref223) {
          var i = _ref223.matchUtilities,
            e = _ref223.theme,
            t = _ref223.corePlugins;
          i({
            ring: function ring(r) {
              return t("ringOpacity") ? se({
                color: r,
                property: "--tw-ring-color",
                variable: "--tw-ring-opacity"
              }) : {
                "--tw-ring-color": L(r)
              };
            }
          }, {
            values: Object.fromEntries(Object.entries(re(e("ringColor"))).filter(function (_ref224) {
              var _ref225 = _slicedToArray(_ref224, 1),
                r = _ref225[0];
              return r !== "DEFAULT";
            })),
            type: ["color", "any"]
          });
        },
        ringOpacity: function ringOpacity(i) {
          var e = i.config;
          return P("ringOpacity", [["ring-opacity", ["--tw-ring-opacity"]]], {
            filterDefault: !K(e(), "respectDefaultRingColorOpacity")
          })(i);
        },
        ringOffsetWidth: P("ringOffsetWidth", [["ring-offset", ["--tw-ring-offset-width"]]], {
          type: "length"
        }),
        ringOffsetColor: function ringOffsetColor(_ref226) {
          var i = _ref226.matchUtilities,
            e = _ref226.theme;
          i({
            "ring-offset": function ringOffset(t) {
              return {
                "--tw-ring-offset-color": L(t)
              };
            }
          }, {
            values: re(e("ringOffsetColor")),
            type: ["color", "any"]
          });
        },
        blur: function blur(_ref227) {
          var i = _ref227.matchUtilities,
            e = _ref227.theme;
          i({
            blur: function blur(t) {
              return {
                "--tw-blur": "blur(".concat(t, ")"),
                "@defaults filter": {},
                filter: Be
              };
            }
          }, {
            values: e("blur")
          });
        },
        brightness: function brightness(_ref228) {
          var i = _ref228.matchUtilities,
            e = _ref228.theme;
          i({
            brightness: function brightness(t) {
              return {
                "--tw-brightness": "brightness(".concat(t, ")"),
                "@defaults filter": {},
                filter: Be
              };
            }
          }, {
            values: e("brightness")
          });
        },
        contrast: function contrast(_ref229) {
          var i = _ref229.matchUtilities,
            e = _ref229.theme;
          i({
            contrast: function contrast(t) {
              return {
                "--tw-contrast": "contrast(".concat(t, ")"),
                "@defaults filter": {},
                filter: Be
              };
            }
          }, {
            values: e("contrast")
          });
        },
        dropShadow: function dropShadow(_ref230) {
          var i = _ref230.matchUtilities,
            e = _ref230.theme;
          i({
            "drop-shadow": function dropShadow(t) {
              return {
                "--tw-drop-shadow": Array.isArray(t) ? t.map(function (r) {
                  return "drop-shadow(".concat(r, ")");
                }).join(" ") : "drop-shadow(".concat(t, ")"),
                "@defaults filter": {},
                filter: Be
              };
            }
          }, {
            values: e("dropShadow")
          });
        },
        grayscale: function grayscale(_ref231) {
          var i = _ref231.matchUtilities,
            e = _ref231.theme;
          i({
            grayscale: function grayscale(t) {
              return {
                "--tw-grayscale": "grayscale(".concat(t, ")"),
                "@defaults filter": {},
                filter: Be
              };
            }
          }, {
            values: e("grayscale")
          });
        },
        hueRotate: function hueRotate(_ref232) {
          var i = _ref232.matchUtilities,
            e = _ref232.theme;
          i({
            "hue-rotate": function hueRotate(t) {
              return {
                "--tw-hue-rotate": "hue-rotate(".concat(t, ")"),
                "@defaults filter": {},
                filter: Be
              };
            }
          }, {
            values: e("hueRotate"),
            supportsNegativeValues: !0
          });
        },
        invert: function invert(_ref233) {
          var i = _ref233.matchUtilities,
            e = _ref233.theme;
          i({
            invert: function invert(t) {
              return {
                "--tw-invert": "invert(".concat(t, ")"),
                "@defaults filter": {},
                filter: Be
              };
            }
          }, {
            values: e("invert")
          });
        },
        saturate: function saturate(_ref234) {
          var i = _ref234.matchUtilities,
            e = _ref234.theme;
          i({
            saturate: function saturate(t) {
              return {
                "--tw-saturate": "saturate(".concat(t, ")"),
                "@defaults filter": {},
                filter: Be
              };
            }
          }, {
            values: e("saturate")
          });
        },
        sepia: function sepia(_ref235) {
          var i = _ref235.matchUtilities,
            e = _ref235.theme;
          i({
            sepia: function sepia(t) {
              return {
                "--tw-sepia": "sepia(".concat(t, ")"),
                "@defaults filter": {},
                filter: Be
              };
            }
          }, {
            values: e("sepia")
          });
        },
        filter: function filter(_ref236) {
          var i = _ref236.addDefaults,
            e = _ref236.addUtilities;
          i("filter", {
            "--tw-blur": " ",
            "--tw-brightness": " ",
            "--tw-contrast": " ",
            "--tw-grayscale": " ",
            "--tw-hue-rotate": " ",
            "--tw-invert": " ",
            "--tw-saturate": " ",
            "--tw-sepia": " ",
            "--tw-drop-shadow": " "
          }), e({
            ".filter": {
              "@defaults filter": {},
              filter: Be
            },
            ".filter-none": {
              filter: "none"
            }
          });
        },
        backdropBlur: function backdropBlur(_ref237) {
          var i = _ref237.matchUtilities,
            e = _ref237.theme;
          i({
            "backdrop-blur": function backdropBlur(t) {
              return {
                "--tw-backdrop-blur": "blur(".concat(t, ")"),
                "@defaults backdrop-filter": {},
                "backdrop-filter": Fe
              };
            }
          }, {
            values: e("backdropBlur")
          });
        },
        backdropBrightness: function backdropBrightness(_ref238) {
          var i = _ref238.matchUtilities,
            e = _ref238.theme;
          i({
            "backdrop-brightness": function backdropBrightness(t) {
              return {
                "--tw-backdrop-brightness": "brightness(".concat(t, ")"),
                "@defaults backdrop-filter": {},
                "backdrop-filter": Fe
              };
            }
          }, {
            values: e("backdropBrightness")
          });
        },
        backdropContrast: function backdropContrast(_ref239) {
          var i = _ref239.matchUtilities,
            e = _ref239.theme;
          i({
            "backdrop-contrast": function backdropContrast(t) {
              return {
                "--tw-backdrop-contrast": "contrast(".concat(t, ")"),
                "@defaults backdrop-filter": {},
                "backdrop-filter": Fe
              };
            }
          }, {
            values: e("backdropContrast")
          });
        },
        backdropGrayscale: function backdropGrayscale(_ref240) {
          var i = _ref240.matchUtilities,
            e = _ref240.theme;
          i({
            "backdrop-grayscale": function backdropGrayscale(t) {
              return {
                "--tw-backdrop-grayscale": "grayscale(".concat(t, ")"),
                "@defaults backdrop-filter": {},
                "backdrop-filter": Fe
              };
            }
          }, {
            values: e("backdropGrayscale")
          });
        },
        backdropHueRotate: function backdropHueRotate(_ref241) {
          var i = _ref241.matchUtilities,
            e = _ref241.theme;
          i({
            "backdrop-hue-rotate": function backdropHueRotate(t) {
              return {
                "--tw-backdrop-hue-rotate": "hue-rotate(".concat(t, ")"),
                "@defaults backdrop-filter": {},
                "backdrop-filter": Fe
              };
            }
          }, {
            values: e("backdropHueRotate"),
            supportsNegativeValues: !0
          });
        },
        backdropInvert: function backdropInvert(_ref242) {
          var i = _ref242.matchUtilities,
            e = _ref242.theme;
          i({
            "backdrop-invert": function backdropInvert(t) {
              return {
                "--tw-backdrop-invert": "invert(".concat(t, ")"),
                "@defaults backdrop-filter": {},
                "backdrop-filter": Fe
              };
            }
          }, {
            values: e("backdropInvert")
          });
        },
        backdropOpacity: function backdropOpacity(_ref243) {
          var i = _ref243.matchUtilities,
            e = _ref243.theme;
          i({
            "backdrop-opacity": function backdropOpacity(t) {
              return {
                "--tw-backdrop-opacity": "opacity(".concat(t, ")"),
                "@defaults backdrop-filter": {},
                "backdrop-filter": Fe
              };
            }
          }, {
            values: e("backdropOpacity")
          });
        },
        backdropSaturate: function backdropSaturate(_ref244) {
          var i = _ref244.matchUtilities,
            e = _ref244.theme;
          i({
            "backdrop-saturate": function backdropSaturate(t) {
              return {
                "--tw-backdrop-saturate": "saturate(".concat(t, ")"),
                "@defaults backdrop-filter": {},
                "backdrop-filter": Fe
              };
            }
          }, {
            values: e("backdropSaturate")
          });
        },
        backdropSepia: function backdropSepia(_ref245) {
          var i = _ref245.matchUtilities,
            e = _ref245.theme;
          i({
            "backdrop-sepia": function backdropSepia(t) {
              return {
                "--tw-backdrop-sepia": "sepia(".concat(t, ")"),
                "@defaults backdrop-filter": {},
                "backdrop-filter": Fe
              };
            }
          }, {
            values: e("backdropSepia")
          });
        },
        backdropFilter: function backdropFilter(_ref246) {
          var i = _ref246.addDefaults,
            e = _ref246.addUtilities;
          i("backdrop-filter", {
            "--tw-backdrop-blur": " ",
            "--tw-backdrop-brightness": " ",
            "--tw-backdrop-contrast": " ",
            "--tw-backdrop-grayscale": " ",
            "--tw-backdrop-hue-rotate": " ",
            "--tw-backdrop-invert": " ",
            "--tw-backdrop-opacity": " ",
            "--tw-backdrop-saturate": " ",
            "--tw-backdrop-sepia": " "
          }), e({
            ".backdrop-filter": {
              "@defaults backdrop-filter": {},
              "backdrop-filter": Fe
            },
            ".backdrop-filter-none": {
              "backdrop-filter": "none"
            }
          });
        },
        transitionProperty: function transitionProperty(_ref247) {
          var i = _ref247.matchUtilities,
            e = _ref247.theme;
          var t = e("transitionTimingFunction.DEFAULT"),
            r = e("transitionDuration.DEFAULT");
          i({
            transition: function transition(n) {
              return _objectSpread({
                "transition-property": n
              }, n === "none" ? {} : {
                "transition-timing-function": t,
                "transition-duration": r
              });
            }
          }, {
            values: e("transitionProperty")
          });
        },
        transitionDelay: P("transitionDelay", [["delay", ["transitionDelay"]]]),
        transitionDuration: P("transitionDuration", [["duration", ["transitionDuration"]]], {
          filterDefault: !0
        }),
        transitionTimingFunction: P("transitionTimingFunction", [["ease", ["transitionTimingFunction"]]], {
          filterDefault: !0
        }),
        willChange: P("willChange", [["will-change", ["will-change"]]]),
        contain: function contain(_ref248) {
          var i = _ref248.addDefaults,
            e = _ref248.addUtilities;
          var t = "var(--tw-contain-size) var(--tw-contain-layout) var(--tw-contain-paint) var(--tw-contain-style)";
          i("contain", {
            "--tw-contain-size": " ",
            "--tw-contain-layout": " ",
            "--tw-contain-paint": " ",
            "--tw-contain-style": " "
          }), e({
            ".contain-none": {
              contain: "none"
            },
            ".contain-content": {
              contain: "content"
            },
            ".contain-strict": {
              contain: "strict"
            },
            ".contain-size": {
              "@defaults contain": {},
              "--tw-contain-size": "size",
              contain: t
            },
            ".contain-inline-size": {
              "@defaults contain": {},
              "--tw-contain-size": "inline-size",
              contain: t
            },
            ".contain-layout": {
              "@defaults contain": {},
              "--tw-contain-layout": "layout",
              contain: t
            },
            ".contain-paint": {
              "@defaults contain": {},
              "--tw-contain-paint": "paint",
              contain: t
            },
            ".contain-style": {
              "@defaults contain": {},
              "--tw-contain-style": "style",
              contain: t
            }
          });
        },
        content: P("content", [["content", ["--tw-content", ["content", "var(--tw-content)"]]]]),
        forcedColorAdjust: function forcedColorAdjust(_ref249) {
          var i = _ref249.addUtilities;
          i({
            ".forced-color-adjust-auto": {
              "forced-color-adjust": "auto"
            },
            ".forced-color-adjust-none": {
              "forced-color-adjust": "none"
            }
          });
        }
      };
    });
  function KS(i) {
    if (i === void 0) return !1;
    if (i === "true" || i === "1") return !0;
    if (i === "false" || i === "0") return !1;
    if (i === "*") return !0;
    var e = i.split(",").map(function (t) {
      return t.split(":")[0];
    });
    return e.includes("-tailwindcss") ? !1 : !!e.includes("tailwindcss");
  }
  var Pe,
    gd,
    yd,
    gn,
    Ga,
    He,
    Kr,
    lt = C(function () {
      l();
      Pe = typeof h != "undefined" ? {
        NODE_ENV: "production",
        DEBUG: KS(h.env.DEBUG)
      } : {
        NODE_ENV: "production",
        DEBUG: !1
      }, gd = new Map(), yd = new Map(), gn = new Map(), Ga = new Map(), He = new String("*"), Kr = Symbol("__NONE__");
    });
  function Lt(i) {
    var e = [],
      t = !1;
    for (var r = 0; r < i.length; r++) {
      var n = i[r];
      if (n === ":" && !t && e.length === 0) return !1;
      if (ZS.has(n) && i[r - 1] !== "\\" && (t = !t), !t && i[r - 1] !== "\\") {
        if (wd.has(n)) e.push(n);else if (bd.has(n)) {
          var a = bd.get(n);
          if (e.length <= 0 || e.pop() !== a) return !1;
        }
      }
    }
    return !(e.length > 0);
  }
  var wd,
    bd,
    ZS,
    Ha = C(function () {
      l();
      wd = new Map([["{", "}"], ["[", "]"], ["(", ")"]]), bd = new Map(Array.from(wd.entries()).map(function (_ref250) {
        var _ref251 = _slicedToArray(_ref250, 2),
          i = _ref251[0],
          e = _ref251[1];
        return [e, i];
      })), ZS = new Set(['"', "'", "`"]);
    });
  function $t(i) {
    var _i$nodes;
    var _vd = vd(i),
      _vd2 = _slicedToArray(_vd, 1),
      e = _vd2[0];
    return e.forEach(function (_ref252) {
      var _ref253 = _slicedToArray(_ref252, 2),
        t = _ref253[0],
        r = _ref253[1];
      return t.removeChild(r);
    }), (_i$nodes = i.nodes).push.apply(_i$nodes, _toConsumableArray(e.map(function (_ref254) {
      var _ref255 = _slicedToArray(_ref254, 2),
        t = _ref255[1];
      return t;
    }))), i;
  }
  function vd(i) {
    var e = [],
      t = null;
    var _iterator63 = _createForOfIteratorHelper(i.nodes),
      _step63;
    try {
      for (_iterator63.s(); !(_step63 = _iterator63.n()).done;) {
        var r = _step63.value;
        if (r.type === "combinator") e = e.filter(function (_ref256) {
          var _ref257 = _slicedToArray(_ref256, 2),
            n = _ref257[1];
          return Qa(n).includes("jumpable");
        }), t = null;else if (r.type === "pseudo") {
          var _r$nodes;
          eC(r) ? (t = r, e.push([i, r, null])) : t && tC(r, t) ? e.push([i, r, t]) : t = null;
          var _iterator64 = _createForOfIteratorHelper((_r$nodes = r.nodes) !== null && _r$nodes !== void 0 ? _r$nodes : []),
            _step64;
          try {
            for (_iterator64.s(); !(_step64 = _iterator64.n()).done;) {
              var _e24;
              var n = _step64.value;
              var _vd3 = vd(n),
                _vd4 = _slicedToArray(_vd3, 2),
                a = _vd4[0],
                s = _vd4[1];
              t = s || t, (_e24 = e).push.apply(_e24, _toConsumableArray(a));
            }
          } catch (err) {
            _iterator64.e(err);
          } finally {
            _iterator64.f();
          }
        }
      }
    } catch (err) {
      _iterator63.e(err);
    } finally {
      _iterator63.f();
    }
    return [e, t];
  }
  function xd(i) {
    return i.value.startsWith("::") || Ya[i.value] !== void 0;
  }
  function eC(i) {
    return xd(i) && Qa(i).includes("terminal");
  }
  function tC(i, e) {
    return i.type !== "pseudo" || xd(i) ? !1 : Qa(e).includes("actionable");
  }
  function Qa(i) {
    var _Ya$i$value;
    return (_Ya$i$value = Ya[i.value]) !== null && _Ya$i$value !== void 0 ? _Ya$i$value : Ya.__default__;
  }
  var Ya,
    yn = C(function () {
      l();
      Ya = {
        "::after": ["terminal", "jumpable"],
        "::backdrop": ["terminal", "jumpable"],
        "::before": ["terminal", "jumpable"],
        "::cue": ["terminal"],
        "::cue-region": ["terminal"],
        "::first-letter": ["terminal", "jumpable"],
        "::first-line": ["terminal", "jumpable"],
        "::grammar-error": ["terminal"],
        "::marker": ["terminal", "jumpable"],
        "::part": ["terminal", "actionable"],
        "::placeholder": ["terminal", "jumpable"],
        "::selection": ["terminal", "jumpable"],
        "::slotted": ["terminal"],
        "::spelling-error": ["terminal"],
        "::target-text": ["terminal"],
        "::file-selector-button": ["terminal", "actionable"],
        "::deep": ["actionable"],
        "::v-deep": ["actionable"],
        "::ng-deep": ["actionable"],
        ":after": ["terminal", "jumpable"],
        ":before": ["terminal", "jumpable"],
        ":first-letter": ["terminal", "jumpable"],
        ":first-line": ["terminal", "jumpable"],
        ":where": [],
        ":is": [],
        ":has": [],
        __default__: ["terminal", "actionable"]
      };
    });
  function jt(i, _ref258) {
    var _e$tailwindConfig$pre;
    var e = _ref258.context,
      t = _ref258.candidate;
    var r = (_e$tailwindConfig$pre = e === null || e === void 0 ? void 0 : e.tailwindConfig.prefix) !== null && _e$tailwindConfig$pre !== void 0 ? _e$tailwindConfig$pre : "",
      n = i.map(function (s) {
        var o = (0, Ne["default"])().astSync(s.format);
        return _objectSpread(_objectSpread({}, s), {}, {
          ast: s.respectPrefix ? Ft(r, o) : o
        });
      }),
      a = Ne["default"].root({
        nodes: [Ne["default"].selector({
          nodes: [Ne["default"].className({
            value: ce(t)
          })]
        })]
      });
    var _iterator65 = _createForOfIteratorHelper(n),
      _step65;
    try {
      for (_iterator65.s(); !(_step65 = _iterator65.n()).done;) {
        var _iC, _iC2;
        var s = _step65.value.ast;
        (_iC = iC(a, s), _iC2 = _slicedToArray(_iC, 2), a = _iC2[0], s = _iC2[1]), s.walkNesting(function (o) {
          return o.replaceWith.apply(o, _toConsumableArray(a.nodes[0].nodes));
        }), a = s;
      }
    } catch (err) {
      _iterator65.e(err);
    } finally {
      _iterator65.f();
    }
    return a;
  }
  function Sd(i) {
    var e = [];
    for (; i.prev() && i.prev().type !== "combinator";) i = i.prev();
    for (; i && i.type !== "combinator";) e.push(i), i = i.next();
    return e;
  }
  function rC(i) {
    return i.sort(function (e, t) {
      return e.type === "tag" && t.type === "class" ? -1 : e.type === "class" && t.type === "tag" ? 1 : e.type === "class" && t.type === "pseudo" && t.value.startsWith("::") ? -1 : e.type === "pseudo" && e.value.startsWith("::") && t.type === "class" ? 1 : i.index(e) - i.index(t);
    }), i;
  }
  function Xa(i, e) {
    var t = !1;
    i.walk(function (r) {
      if (r.type === "class" && r.value === e) return t = !0, !1;
    }), t || i.remove();
  }
  function wn(i, e, _ref259) {
    var _t$tailwindConfig$sep, _t$tailwindConfig, _n8;
    var t = _ref259.context,
      r = _ref259.candidate,
      n = _ref259.base;
    var a = (_t$tailwindConfig$sep = t === null || t === void 0 || (_t$tailwindConfig = t.tailwindConfig) === null || _t$tailwindConfig === void 0 ? void 0 : _t$tailwindConfig.separator) !== null && _t$tailwindConfig$sep !== void 0 ? _t$tailwindConfig$sep : ":";
    n = (_n8 = n) !== null && _n8 !== void 0 ? _n8 : ae(r, a).pop();
    var s = (0, Ne["default"])().astSync(i);
    if (s.walkClasses(function (f) {
      f.raws && f.value.includes(n) && (f.raws.value = ce((0, kd["default"])(f.raws.value)));
    }), s.each(function (f) {
      return Xa(f, n);
    }), s.length === 0) return null;
    var o = Array.isArray(e) ? jt(e, {
      context: t,
      candidate: r
    }) : e;
    if (o === null) return s.toString();
    var u = Ne["default"].comment({
        value: "/*__simple__*/"
      }),
      c = Ne["default"].comment({
        value: "/*__simple__*/"
      });
    return s.walkClasses(function (f) {
      var _d$nodes;
      if (f.value !== n) return;
      var d = f.parent,
        p = o.nodes[0].nodes;
      if (d.nodes.length === 1) {
        f.replaceWith.apply(f, _toConsumableArray(p));
        return;
      }
      var m = Sd(f);
      d.insertBefore(m[0], u), d.insertAfter(m[m.length - 1], c);
      var _iterator66 = _createForOfIteratorHelper(p),
        _step66;
      try {
        for (_iterator66.s(); !(_step66 = _iterator66.n()).done;) {
          var x = _step66.value;
          d.insertBefore(m[0], x.clone());
        }
      } catch (err) {
        _iterator66.e(err);
      } finally {
        _iterator66.f();
      }
      f.remove(), m = Sd(u);
      var b = d.index(u);
      (_d$nodes = d.nodes).splice.apply(_d$nodes, [b, m.length].concat(_toConsumableArray(rC(Ne["default"].selector({
        nodes: m
      })).nodes))), u.remove(), c.remove();
    }), s.walkPseudos(function (f) {
      f.value === Ja && f.replaceWith(f.nodes);
    }), s.each(function (f) {
      return $t(f);
    }), s.toString();
  }
  function iC(i, e) {
    var t = [];
    return i.walkPseudos(function (r) {
      r.value === Ja && t.push({
        pseudo: r,
        value: r.nodes[0].toString()
      });
    }), e.walkPseudos(function (r) {
      if (r.value !== Ja) return;
      var n = r.nodes[0].toString(),
        a = t.find(function (c) {
          return c.value === n;
        });
      if (!a) return;
      var s = [],
        o = r.next();
      for (; o && o.type !== "combinator";) s.push(o), o = o.next();
      var u = o;
      a.pseudo.parent.insertAfter(a.pseudo, Ne["default"].selector({
        nodes: s.map(function (c) {
          return c.clone();
        })
      })), r.remove(), s.forEach(function (c) {
        return c.remove();
      }), u && u.type === "combinator" && u.remove();
    }), [i, e];
  }
  var Ne,
    kd,
    Ja,
    Ka = C(function () {
      l();
      Ne = X(Me()), kd = X(Yi());
      Nt();
      un();
      yn();
      Ct();
      Ja = ":merge";
    });
  function bn(i, e) {
    var t = (0, Za["default"])().astSync(i);
    return t.each(function (r) {
      r.nodes[0].type === "pseudo" && r.nodes[0].value === ":is" && r.nodes.every(function (a) {
        return a.type !== "combinator";
      }) || (r.nodes = [Za["default"].pseudo({
        value: ":is",
        nodes: [r.clone()]
      })]), $t(r);
    }), "".concat(e, " ").concat(t.toString());
  }
  var Za,
    eo = C(function () {
      l();
      Za = X(Me());
      yn();
    });
  function to(i) {
    return nC.transformSync(i);
  }
  function sC(i) {
    var e, t, r, s, n, a;
    return _regeneratorRuntime().wrap(function sC$(_context12) {
      while (1) switch (_context12.prev = _context12.next) {
        case 0:
          e = 1 / 0;
        case 1:
          if (!(e >= 0)) {
            _context12.next = 14;
            break;
          }
          t = void 0, r = !1;
          if (e === 1 / 0 && i.endsWith("]")) {
            s = i.indexOf("[");
            i[s - 1] === "-" ? t = s - 1 : i[s - 1] === "/" ? (t = s - 1, r = !0) : t = -1;
          } else e === 1 / 0 && i.includes("/") ? (t = i.lastIndexOf("/"), r = !0) : t = i.lastIndexOf("-", e);
          if (!(t < 0)) {
            _context12.next = 6;
            break;
          }
          return _context12.abrupt("break", 14);
        case 6:
          n = i.slice(0, t), a = i.slice(r ? t : t + 1);
          e = t - 1;
          _context12.t0 = !(n === "" || a === "/");
          if (!_context12.t0) {
            _context12.next = 12;
            break;
          }
          _context12.next = 12;
          return [n, a];
        case 12:
          _context12.next = 1;
          break;
        case 14:
        case "end":
          return _context12.stop();
      }
    }, _marked3);
  }
  function aC(i, e) {
    if (i.length === 0 || e.tailwindConfig.prefix === "") return i;
    var _iterator67 = _createForOfIteratorHelper(i),
      _step67;
    try {
      var _loop7 = function _loop7() {
        var t = _step67.value;
        var _t10 = _slicedToArray(t, 1),
          r = _t10[0];
        if (r.options.respectPrefix) {
          var n = z.root({
              nodes: [t[1].clone()]
            }),
            a = t[1].raws.tailwind.classCandidate;
          n.walkRules(function (s) {
            var o = a.startsWith("-");
            s.selector = Ft(e.tailwindConfig.prefix, s.selector, o);
          }), t[1] = n.nodes[0];
        }
      };
      for (_iterator67.s(); !(_step67 = _iterator67.n()).done;) {
        _loop7();
      }
    } catch (err) {
      _iterator67.e(err);
    } finally {
      _iterator67.f();
    }
    return i;
  }
  function oC(i, e) {
    if (i.length === 0) return i;
    var t = [];
    function r(n) {
      return n.parent && n.parent.type === "atrule" && n.parent.name === "keyframes";
    }
    var _iterator68 = _createForOfIteratorHelper(i),
      _step68;
    try {
      for (_iterator68.s(); !(_step68 = _iterator68.n()).done;) {
        var _step68$value = _slicedToArray(_step68.value, 2),
          n = _step68$value[0],
          a = _step68$value[1];
        var s = z.root({
          nodes: [a.clone()]
        });
        s.walkRules(function (o) {
          if (r(o)) return;
          var u = (0, vn["default"])().astSync(o.selector);
          u.each(function (c) {
            return Xa(c, e);
          }), ju(u, function (c) {
            return c === e ? "!".concat(c) : c;
          }), o.selector = u.toString(), o.walkDecls(function (c) {
            return c.important = !0;
          });
        }), t.push([_objectSpread(_objectSpread({}, n), {}, {
          important: !0
        }), s.nodes[0]]);
      }
    } catch (err) {
      _iterator68.e(err);
    } finally {
      _iterator68.f();
    }
    return t;
  }
  function lC(i, e, t) {
    if (e.length === 0) return e;
    var r = {
      modifier: null,
      value: Kr
    };
    {
      var _ae = ae(i, "/"),
        _ae2 = _toArray(_ae),
        n = _ae2[0],
        a = _ae2.slice(1);
      if (a.length > 1 && (n = n + "/" + a.slice(0, -1).join("/"), a = a.slice(-1)), a.length && !t.variantMap.has(i) && (i = n, r.modifier = a[0], !K(t.tailwindConfig, "generalizedModifiers"))) return [];
    }
    if (i.endsWith("]") && !i.startsWith("[")) {
      var _n9 = /(.)(-?)\[(.*)\]/g.exec(i);
      if (_n9) {
        var _n10 = _slicedToArray(_n9, 4),
          _a8 = _n10[1],
          s = _n10[2],
          o = _n10[3];
        if (_a8 === "@" && s === "-") return [];
        if (_a8 !== "@" && s === "") return [];
        i = i.replace("".concat(s, "[").concat(o, "]"), ""), r.value = o;
      }
    }
    if (no(i) && !t.variantMap.has(i)) {
      var _n11 = t.offsets.recordVariant(i),
        _a9 = N(i.slice(1, -1)),
        _s10 = ae(_a9, ",");
      if (_s10.length > 1) return [];
      if (!_s10.every(Cn)) return [];
      var _o6 = _s10.map(function (u, c) {
        return [t.offsets.applyParallelOffset(_n11, c), Zr(u.trim())];
      });
      t.variantMap.set(i, _o6);
    }
    if (t.variantMap.has(i)) {
      var _t$variantOptions$get, _t$variantOptions$get2;
      var _n12 = no(i),
        _a10 = (_t$variantOptions$get = (_t$variantOptions$get2 = t.variantOptions.get(i)) === null || _t$variantOptions$get2 === void 0 ? void 0 : _t$variantOptions$get2[ot]) !== null && _t$variantOptions$get !== void 0 ? _t$variantOptions$get : {},
        _s11 = t.variantMap.get(i).slice(),
        _o7 = [],
        u = function () {
          return !(_n12 || _a10.respectPrefix === !1);
        }();
      var _iterator69 = _createForOfIteratorHelper(e),
        _step69;
      try {
        for (_iterator69.s(); !(_step69 = _iterator69.n()).done;) {
          var _step69$value = _slicedToArray(_step69.value, 2),
            c = _step69$value[0],
            f = _step69$value[1];
          if (c.layer === "user") continue;
          var d = z.root({
            nodes: [f.clone()]
          });
          var _iterator70 = _createForOfIteratorHelper(_s11),
            _step70;
          try {
            var _loop8 = function _loop8() {
                var _c$collectedFormats;
                var _step70$value = _slicedToArray(_step70.value, 3),
                  p = _step70$value[0],
                  m = _step70$value[1],
                  b = _step70$value[2];
                var w = function w() {
                    x.raws.neededBackup || (x.raws.neededBackup = !0, x.walkRules(function (E) {
                      return E.raws.originalSelector = E.selector;
                    }));
                  },
                  k = function k(E) {
                    return w(), x.each(function (I) {
                      I.type === "rule" && (I.selectors = I.selectors.map(function (q) {
                        return E({
                          get className() {
                            return to(q);
                          },
                          selector: q
                        });
                      }));
                    }), x;
                  },
                  x = (b !== null && b !== void 0 ? b : d).clone(),
                  y = [],
                  S = m({
                    get container() {
                      return w(), x;
                    },
                    separator: t.tailwindConfig.separator,
                    modifySelectors: k,
                    wrap: function wrap(E) {
                      var I = x.nodes;
                      x.removeAll(), E.append(I), x.append(E);
                    },
                    format: function format(E) {
                      y.push({
                        format: E,
                        respectPrefix: u
                      });
                    },
                    args: r
                  });
                if (Array.isArray(S)) {
                  var _iterator71 = _createForOfIteratorHelper(S.entries()),
                    _step71;
                  try {
                    for (_iterator71.s(); !(_step71 = _iterator71.n()).done;) {
                      var _step71$value = _slicedToArray(_step71.value, 2),
                        E = _step71$value[0],
                        I = _step71$value[1];
                      _s11.push([t.offsets.applyParallelOffset(p, E), I, x.clone()]);
                    }
                  } catch (err) {
                    _iterator71.e(err);
                  } finally {
                    _iterator71.f();
                  }
                  return 0; // continue
                }
                if (typeof S == "string" && y.push({
                  format: S,
                  respectPrefix: u
                }), S === null) return 0; // continue
                x.raws.neededBackup && (delete x.raws.neededBackup, x.walkRules(function (E) {
                  var I = E.raws.originalSelector;
                  if (!I || (delete E.raws.originalSelector, I === E.selector)) return;
                  var q = E.selector,
                    R = (0, vn["default"])(function (J) {
                      J.walkClasses(function (ue) {
                        ue.value = "".concat(i).concat(t.tailwindConfig.separator).concat(ue.value);
                      });
                    }).processSync(I);
                  y.push({
                    format: q.replace(R, "&"),
                    respectPrefix: u
                  }), E.selector = I;
                })), x.nodes[0].raws.tailwind = _objectSpread(_objectSpread({}, x.nodes[0].raws.tailwind), {}, {
                  parentLayer: c.layer
                });
                var _ = [_objectSpread(_objectSpread({}, c), {}, {
                  sort: t.offsets.applyVariantOffset(c.sort, p, Object.assign(r, t.variantOptions.get(i))),
                  collectedFormats: ((_c$collectedFormats = c.collectedFormats) !== null && _c$collectedFormats !== void 0 ? _c$collectedFormats : []).concat(y)
                }), x.nodes[0]];
                _o7.push(_);
              },
              _ret;
            for (_iterator70.s(); !(_step70 = _iterator70.n()).done;) {
              _ret = _loop8();
              if (_ret === 0) continue;
            }
          } catch (err) {
            _iterator70.e(err);
          } finally {
            _iterator70.f();
          }
        }
      } catch (err) {
        _iterator69.e(err);
      } finally {
        _iterator69.f();
      }
      return _o7;
    }
    return [];
  }
  function ro(i, e) {
    var t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return !ie(i) && !Array.isArray(i) ? [[i], t] : Array.isArray(i) ? ro(i[0], e, i[1]) : (e.has(i) || e.set(i, Bt(i)), [e.get(i), t]);
  }
  function fC(i) {
    return uC.test(i);
  }
  function cC(i) {
    if (!i.includes("://")) return !1;
    try {
      var e = new URL(i);
      return e.scheme !== "" && e.host !== "";
    } catch (e) {
      return !1;
    }
  }
  function Cd(i) {
    var e = !0;
    return i.walkDecls(function (t) {
      if (!Ad(t.prop, t.value)) return e = !1, !1;
    }), e;
  }
  function Ad(i, e) {
    if (cC("".concat(i, ":").concat(e))) return !1;
    try {
      return z.parse("a{".concat(i, ":").concat(e, "}")).toResult(), !0;
    } catch (t) {
      return !1;
    }
  }
  function pC(i, e) {
    var _i$match2;
    var _ref260 = (_i$match2 = i.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/)) !== null && _i$match2 !== void 0 ? _i$match2 : [],
      _ref261 = _slicedToArray(_ref260, 3),
      t = _ref261[1],
      r = _ref261[2];
    if (r === void 0 || !fC(t) || !Lt(r)) return null;
    var n = N(r, {
      property: t
    });
    return Ad(t, n) ? [[{
      sort: e.offsets.arbitraryProperty(i),
      layer: "utilities",
      options: {
        respectImportant: !0
      }
    }, function () {
      return _defineProperty({}, Va(i), _defineProperty({}, t, n));
    }]] : null;
  }
  function dC(i, e) {
    var t, r, n, a, s, _iterator72, _step72, _step72$value, o, u;
    return _regeneratorRuntime().wrap(function dC$(_context14) {
      while (1) switch (_context14.prev = _context14.next) {
        case 0:
          _context14.t0 = e.candidateRuleMap.has(i);
          if (!_context14.t0) {
            _context14.next = 4;
            break;
          }
          _context14.next = 4;
          return [e.candidateRuleMap.get(i), "DEFAULT"];
        case 4:
          return _context14.delegateYield( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(o) {
            return _regeneratorRuntime().wrap(function _callee3$(_context13) {
              while (1) switch (_context13.prev = _context13.next) {
                case 0:
                  _context13.t0 = o !== null;
                  if (!_context13.t0) {
                    _context13.next = 4;
                    break;
                  }
                  _context13.next = 4;
                  return [o, "DEFAULT"];
                case 4:
                case "end":
                  return _context13.stop();
              }
            }, _callee3);
          })(pC(i, e)), "t1", 5);
        case 5:
          t = i, r = !1, n = e.tailwindConfig.prefix, a = n.length, s = t.startsWith(n) || t.startsWith("-".concat(n));
          t[a] === "-" && s && (r = !0, t = n + t.slice(a + 1));
          _context14.t2 = r && e.candidateRuleMap.has(t);
          if (!_context14.t2) {
            _context14.next = 11;
            break;
          }
          _context14.next = 11;
          return [e.candidateRuleMap.get(t), "-DEFAULT"];
        case 11:
          _iterator72 = _createForOfIteratorHelper(sC(t));
          _context14.prev = 12;
          _iterator72.s();
        case 14:
          if ((_step72 = _iterator72.n()).done) {
            _context14.next = 22;
            break;
          }
          _step72$value = _slicedToArray(_step72.value, 2), o = _step72$value[0], u = _step72$value[1];
          _context14.t3 = e.candidateRuleMap.has(o);
          if (!_context14.t3) {
            _context14.next = 20;
            break;
          }
          _context14.next = 20;
          return [e.candidateRuleMap.get(o), r ? "-".concat(u) : u];
        case 20:
          _context14.next = 14;
          break;
        case 22:
          _context14.next = 27;
          break;
        case 24:
          _context14.prev = 24;
          _context14.t4 = _context14["catch"](12);
          _iterator72.e(_context14.t4);
        case 27:
          _context14.prev = 27;
          _iterator72.f();
          return _context14.finish(27);
        case 30:
        case "end":
          return _context14.stop();
      }
    }, _marked4, null, [[12, 24, 27, 30]]);
  }
  function hC(i, e) {
    return i === He ? [He] : ae(i, e);
  }
  function mC(i, e) {
    var _iterator73, _step73, _t$0$options$preserve, _t$0$options, t;
    return _regeneratorRuntime().wrap(function mC$(_context15) {
      while (1) switch (_context15.prev = _context15.next) {
        case 0:
          _iterator73 = _createForOfIteratorHelper(i);
          _context15.prev = 1;
          _iterator73.s();
        case 3:
          if ((_step73 = _iterator73.n()).done) {
            _context15.next = 10;
            break;
          }
          t = _step73.value;
          t[1].raws.tailwind = _objectSpread(_objectSpread({}, t[1].raws.tailwind), {}, {
            classCandidate: e,
            preserveSource: (_t$0$options$preserve = (_t$0$options = t[0].options) === null || _t$0$options === void 0 ? void 0 : _t$0$options.preserveSource) !== null && _t$0$options$preserve !== void 0 ? _t$0$options$preserve : !1
          });
          _context15.next = 8;
          return t;
        case 8:
          _context15.next = 3;
          break;
        case 10:
          _context15.next = 15;
          break;
        case 12:
          _context15.prev = 12;
          _context15.t0 = _context15["catch"](1);
          _iterator73.e(_context15.t0);
        case 15:
          _context15.prev = 15;
          _iterator73.f();
          return _context15.finish(15);
        case 18:
        case "end":
          return _context15.stop();
      }
    }, _marked5, null, [[1, 12, 15, 18]]);
  }
  function io(i, e) {
    var t, _hC$reverse, _hC$reverse2, r, n, a, _iterator74, _step74, _loop9;
    return _regeneratorRuntime().wrap(function io$(_context17) {
      while (1) switch (_context17.prev = _context17.next) {
        case 0:
          t = e.tailwindConfig.separator, _hC$reverse = hC(i, t).reverse(), _hC$reverse2 = _toArray(_hC$reverse), r = _hC$reverse2[0], n = _hC$reverse2.slice(1), a = !1;
          r.startsWith("!") && (a = !0, r = r.slice(1));
          _iterator74 = _createForOfIteratorHelper(dC(r, e));
          _context17.prev = 3;
          _loop9 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop9() {
            var s, o, u, _s12, c, f, d, _iterator75, _step75, _step75$value, _p4, _m2, _b3, _iterator83, _step83, _x3, _ro, _ro2, _y2, _w3, _iterator84, _step84, _k3, _x4, _ro3, _ro4, _y3, _w4, _iterator85, _step85, _k4, _p4$options$types, _p4$options, _p4$options2, _x5, _b2, b, _o$reduce, _o$reduce2, p, m, x, y, _iterator76, _step76, k, _iterator78, _step78, S, _, _iterator79, _step79, E, w, _iterator77, _step77, _step77$value, _k2, _S2, _iterator80, _step80, _3, _E, _iterator81, _step81, _p5, _iterator82, _step82, _p6;
            return _regeneratorRuntime().wrap(function _loop9$(_context16) {
              while (1) switch (_context16.prev = _context16.next) {
                case 0:
                  s = _step74.value;
                  o = [], u = new Map(), _s12 = _slicedToArray(s, 2), c = _s12[0], f = _s12[1], d = c.length === 1;
                  _iterator75 = _createForOfIteratorHelper(c);
                  try {
                    for (_iterator75.s(); !(_step75 = _iterator75.n()).done;) {
                      _step75$value = _slicedToArray(_step75.value, 2), _p4 = _step75$value[0], _m2 = _step75$value[1];
                      _b3 = [];
                      if (typeof _m2 == "function") {
                        _iterator83 = _createForOfIteratorHelper([].concat(_m2(f, {
                          isOnlyPlugin: d
                        })));
                        try {
                          for (_iterator83.s(); !(_step83 = _iterator83.n()).done;) {
                            _x3 = _step83.value;
                            _ro = ro(_x3, e.postCssNodeCache), _ro2 = _slicedToArray(_ro, 2), _y2 = _ro2[0], _w3 = _ro2[1];
                            _iterator84 = _createForOfIteratorHelper(_y2);
                            try {
                              for (_iterator84.s(); !(_step84 = _iterator84.n()).done;) {
                                _k3 = _step84.value;
                                _b3.push([_objectSpread(_objectSpread({}, _p4), {}, {
                                  options: _objectSpread(_objectSpread({}, _p4.options), _w3)
                                }), _k3]);
                              }
                            } catch (err) {
                              _iterator84.e(err);
                            } finally {
                              _iterator84.f();
                            }
                          }
                        } catch (err) {
                          _iterator83.e(err);
                        } finally {
                          _iterator83.f();
                        }
                      } else if (f === "DEFAULT" || f === "-DEFAULT") {
                        _x4 = _m2, _ro3 = ro(_x4, e.postCssNodeCache), _ro4 = _slicedToArray(_ro3, 2), _y3 = _ro4[0], _w4 = _ro4[1];
                        _iterator85 = _createForOfIteratorHelper(_y3);
                        try {
                          for (_iterator85.s(); !(_step85 = _iterator85.n()).done;) {
                            _k4 = _step85.value;
                            _b3.push([_objectSpread(_objectSpread({}, _p4), {}, {
                              options: _objectSpread(_objectSpread({}, _p4.options), _w4)
                            }), _k4]);
                          }
                        } catch (err) {
                          _iterator85.e(err);
                        } finally {
                          _iterator85.f();
                        }
                      }
                      if (_b3.length > 0) {
                        _x5 = Array.from(fs((_p4$options$types = (_p4$options = _p4.options) === null || _p4$options === void 0 ? void 0 : _p4$options.types) !== null && _p4$options$types !== void 0 ? _p4$options$types : [], f, (_p4$options2 = _p4.options) !== null && _p4$options2 !== void 0 ? _p4$options2 : {}, e.tailwindConfig)).map(function (_ref271) {
                          var _ref272 = _slicedToArray(_ref271, 2),
                            y = _ref272[0],
                            w = _ref272[1];
                          return w;
                        });
                        _x5.length > 0 && u.set(_b3, _x5), o.push(_b3);
                      }
                    }
                  } catch (err) {
                    _iterator75.e(err);
                  } finally {
                    _iterator75.f();
                  }
                  if (!no(f)) {
                    _context16.next = 51;
                    break;
                  }
                  if (!(o.length > 1)) {
                    _context16.next = 50;
                    break;
                  }
                  b = function b(y) {
                    return y.length === 1 ? y[0] : y.find(function (w) {
                      var k = u.get(w);
                      return w.some(function (_ref263) {
                        var _ref264 = _slicedToArray(_ref263, 2),
                          S = _ref264[0].options,
                          _ = _ref264[1];
                        return Cd(_) ? S.types.some(function (_ref265) {
                          var E = _ref265.type,
                            I = _ref265.preferOnConflict;
                          return k.includes(E) && I;
                        }) : !1;
                      });
                    });
                  }, _o$reduce = o.reduce(function (y, w) {
                    return w.some(function (_ref266) {
                      var _ref267 = _slicedToArray(_ref266, 1),
                        S = _ref267[0].options;
                      return S.types.some(function (_ref268) {
                        var _ = _ref268.type;
                        return _ === "any";
                      });
                    }) ? y[0].push(w) : y[1].push(w), y;
                  }, [[], []]), _o$reduce2 = _slicedToArray(_o$reduce, 2), p = _o$reduce2[0], m = _o$reduce2[1], x = (_b2 = b(m)) !== null && _b2 !== void 0 ? _b2 : b(p);
                  if (!x) {
                    _context16.next = 11;
                    break;
                  }
                  o = [x];
                  _context16.next = 50;
                  break;
                case 11:
                  y = o.map(function (k) {
                    var _u$get;
                    return new Set(_toConsumableArray((_u$get = u.get(k)) !== null && _u$get !== void 0 ? _u$get : []));
                  });
                  _iterator76 = _createForOfIteratorHelper(y);
                  try {
                    for (_iterator76.s(); !(_step76 = _iterator76.n()).done;) {
                      k = _step76.value;
                      _iterator78 = _createForOfIteratorHelper(k);
                      try {
                        for (_iterator78.s(); !(_step78 = _iterator78.n()).done;) {
                          S = _step78.value;
                          _ = !1;
                          _iterator79 = _createForOfIteratorHelper(y);
                          try {
                            for (_iterator79.s(); !(_step79 = _iterator79.n()).done;) {
                              E = _step79.value;
                              k !== E && E.has(S) && (E["delete"](S), _ = !0);
                            }
                          } catch (err) {
                            _iterator79.e(err);
                          } finally {
                            _iterator79.f();
                          }
                          _ && k["delete"](S);
                        }
                      } catch (err) {
                        _iterator78.e(err);
                      } finally {
                        _iterator78.f();
                      }
                    }
                  } catch (err) {
                    _iterator76.e(err);
                  } finally {
                    _iterator76.f();
                  }
                  w = [];
                  _iterator77 = _createForOfIteratorHelper(y.entries());
                  _context16.prev = 16;
                  _iterator77.s();
                case 18:
                  if ((_step77 = _iterator77.n()).done) {
                    _context16.next = 40;
                    break;
                  }
                  _step77$value = _slicedToArray(_step77.value, 2), _k2 = _step77$value[0], _S2 = _step77$value[1];
                  _iterator80 = _createForOfIteratorHelper(_S2);
                  _context16.prev = 21;
                  _iterator80.s();
                case 23:
                  if ((_step80 = _iterator80.n()).done) {
                    _context16.next = 30;
                    break;
                  }
                  _3 = _step80.value;
                  _E = o[_k2].map(function (_ref269) {
                    var _ref270 = _slicedToArray(_ref269, 2),
                      I = _ref270[1];
                    return I;
                  }).flat().map(function (I) {
                    return I.toString().split("\n").slice(1, -1).map(function (q) {
                      return q.trim();
                    }).map(function (q) {
                      return "      ".concat(q);
                    }).join("\n");
                  }).join("\n\n");
                  w.push("  Use `".concat(i.replace("[", "[".concat(_3, ":")), "` for `").concat(_E.trim(), "`"));
                  return _context16.abrupt("break", 30);
                case 28:
                  _context16.next = 23;
                  break;
                case 30:
                  _context16.next = 35;
                  break;
                case 32:
                  _context16.prev = 32;
                  _context16.t0 = _context16["catch"](21);
                  _iterator80.e(_context16.t0);
                case 35:
                  _context16.prev = 35;
                  _iterator80.f();
                  return _context16.finish(35);
                case 38:
                  _context16.next = 18;
                  break;
                case 40:
                  _context16.next = 45;
                  break;
                case 42:
                  _context16.prev = 42;
                  _context16.t1 = _context16["catch"](16);
                  _iterator77.e(_context16.t1);
                case 45:
                  _context16.prev = 45;
                  _iterator77.f();
                  return _context16.finish(45);
                case 48:
                  F.warn(["The class `".concat(i, "` is ambiguous and matches multiple utilities.")].concat(w, ["If this is content and not a class, replace it with `".concat(i.replace("[", "&lsqb;").replace("]", "&rsqb;"), "` to silence this warning.")]));
                  return _context16.abrupt("return", 1);
                case 50:
                  o = o.map(function (p) {
                    return p.filter(function (m) {
                      return Cd(m[1]);
                    });
                  });
                case 51:
                  o = o.flat(), o = Array.from(mC(o, r)), o = aC(o, e), a && (o = oC(o, r));
                  _iterator81 = _createForOfIteratorHelper(n);
                  try {
                    for (_iterator81.s(); !(_step81 = _iterator81.n()).done;) {
                      _p5 = _step81.value;
                      o = lC(_p5, o, e);
                    }
                  } catch (err) {
                    _iterator81.e(err);
                  } finally {
                    _iterator81.f();
                  }
                  _iterator82 = _createForOfIteratorHelper(o);
                  _context16.prev = 55;
                  _iterator82.s();
                case 57:
                  if ((_step82 = _iterator82.n()).done) {
                    _context16.next = 67;
                    break;
                  }
                  _p6 = _step82.value;
                  _p6[1].raws.tailwind = _objectSpread(_objectSpread({}, _p6[1].raws.tailwind), {}, {
                    candidate: i
                  });
                  _p6 = gC(_p6, {
                    context: e,
                    candidate: i
                  });
                  _context16.t2 = _p6 !== null;
                  if (!_context16.t2) {
                    _context16.next = 65;
                    break;
                  }
                  _context16.next = 65;
                  return _p6;
                case 65:
                  _context16.next = 57;
                  break;
                case 67:
                  _context16.next = 72;
                  break;
                case 69:
                  _context16.prev = 69;
                  _context16.t3 = _context16["catch"](55);
                  _iterator82.e(_context16.t3);
                case 72:
                  _context16.prev = 72;
                  _iterator82.f();
                  return _context16.finish(72);
                case 75:
                case "end":
                  return _context16.stop();
              }
            }, _loop9, null, [[16, 42, 45, 48], [21, 32, 35, 38], [55, 69, 72, 75]]);
          });
          _iterator74.s();
        case 6:
          if ((_step74 = _iterator74.n()).done) {
            _context17.next = 12;
            break;
          }
          return _context17.delegateYield(_loop9(), "t0", 8);
        case 8:
          if (!_context17.t0) {
            _context17.next = 10;
            break;
          }
          return _context17.abrupt("continue", 10);
        case 10:
          _context17.next = 6;
          break;
        case 12:
          _context17.next = 17;
          break;
        case 14:
          _context17.prev = 14;
          _context17.t1 = _context17["catch"](3);
          _iterator74.e(_context17.t1);
        case 17:
          _context17.prev = 17;
          _iterator74.f();
          return _context17.finish(17);
        case 20:
        case "end":
          return _context17.stop();
      }
    }, _marked6, null, [[3, 14, 17, 20]]);
  }
  function gC(i, _ref273) {
    var e = _ref273.context,
      t = _ref273.candidate;
    if (!i[0].collectedFormats) return i;
    var r = !0,
      n;
    try {
      n = jt(i[0].collectedFormats, {
        context: e,
        candidate: t
      });
    } catch (_unused) {
      return null;
    }
    var a = z.root({
      nodes: [i[1].clone()]
    });
    return a.walkRules(function (s) {
      if (!xn(s)) try {
        var o = wn(s.selector, n, {
          candidate: t,
          context: e
        });
        if (o === null) {
          s.remove();
          return;
        }
        s.selector = o;
      } catch (_unused2) {
        return r = !1, !1;
      }
    }), !r || a.nodes.length === 0 ? null : (i[1] = a.nodes[0], i);
  }
  function xn(i) {
    return i.parent && i.parent.type === "atrule" && i.parent.name === "keyframes";
  }
  function yC(i) {
    if (i === !0) return function (e) {
      xn(e) || e.walkDecls(function (t) {
        t.parent.type === "rule" && !xn(t.parent) && (t.important = !0);
      });
    };
    if (typeof i == "string") return function (e) {
      xn(e) || (e.selectors = e.selectors.map(function (t) {
        return bn(t, i);
      }));
    };
  }
  function kn(i, e) {
    var t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var r = [],
      n = yC(e.tailwindConfig.important);
    var _iterator86 = _createForOfIteratorHelper(i),
      _step86;
    try {
      for (_iterator86.s(); !(_step86 = _iterator86.n()).done;) {
        var _e$candidateRuleCache;
        var a = _step86.value;
        if (e.notClassCache.has(a)) continue;
        if (e.candidateRuleCache.has(a)) {
          r = r.concat(Array.from(e.candidateRuleCache.get(a)));
          continue;
        }
        var s = Array.from(io(a, e));
        if (s.length === 0) {
          e.notClassCache.add(a);
          continue;
        }
        e.classCache.set(a, s);
        var o = (_e$candidateRuleCache = e.candidateRuleCache.get(a)) !== null && _e$candidateRuleCache !== void 0 ? _e$candidateRuleCache : new Set();
        e.candidateRuleCache.set(a, o);
        for (var _i15 = 0, _s13 = s; _i15 < _s13.length; _i15++) {
          var _u3 = _s13[_i15];
          var _u4 = _slicedToArray(_u3, 2),
            _u4$ = _u4[0],
            c = _u4$.sort,
            f = _u4$.options,
            d = _u4[1];
          if (f.respectImportant && n) {
            var m = z.root({
              nodes: [d.clone()]
            });
            m.walkRules(n), d = m.nodes[0];
          }
          var p = [c, t ? d.clone() : d];
          o.add(p), e.ruleCache.add(p), r.push(p);
        }
      }
    } catch (err) {
      _iterator86.e(err);
    } finally {
      _iterator86.f();
    }
    return r;
  }
  function no(i) {
    return i.startsWith("[") && i.endsWith("]");
  }
  var vn,
    nC,
    uC,
    Sn = C(function () {
      l();
      nt();
      vn = X(Me());
      za();
      St();
      un();
      pr();
      Oe();
      lt();
      Ka();
      Ua();
      cr();
      Xr();
      Ha();
      Ct();
      ze();
      eo();
      nC = (0, vn["default"])(function (i) {
        return i.first.filter(function (_ref274) {
          var e = _ref274.type;
          return e === "class";
        }).pop().value;
      });
      uC = /^[a-z_-]/;
    });
  var _d,
    Od = C(function () {
      l();
      _d = {};
    });
  function wC(i) {
    try {
      return _d.createHash("md5").update(i, "utf-8").digest("binary");
    } catch (e) {
      return "";
    }
  }
  function Ed(i, e) {
    var t = e.toString();
    if (!t.includes("@tailwind")) return !1;
    var r = Ga.get(i),
      n = wC(t),
      a = r !== n;
    return Ga.set(i, n), a;
  }
  var Td = C(function () {
    l();
    Od();
    lt();
  });
  function An(i) {
    return (i > 0n) - (i < 0n);
  }
  var Pd = C(function () {
    l();
  });
  function Dd(i, e) {
    var t = 0n,
      r = 0n;
    var _iterator87 = _createForOfIteratorHelper(e),
      _step87;
    try {
      for (_iterator87.s(); !(_step87 = _iterator87.n()).done;) {
        var _step87$value = _slicedToArray(_step87.value, 2),
          n = _step87$value[0],
          a = _step87$value[1];
        i & n && (t = t | n, r = r | a);
      }
    } catch (err) {
      _iterator87.e(err);
    } finally {
      _iterator87.f();
    }
    return i & ~t | r;
  }
  var Id = C(function () {
    l();
  });
  function qd(i) {
    var e = null;
    var _iterator88 = _createForOfIteratorHelper(i),
      _step88;
    try {
      for (_iterator88.s(); !(_step88 = _iterator88.n()).done;) {
        var _e25;
        var t = _step88.value;
        e = (_e25 = e) !== null && _e25 !== void 0 ? _e25 : t, e = e > t ? e : t;
      }
    } catch (err) {
      _iterator88.e(err);
    } finally {
      _iterator88.f();
    }
    return e;
  }
  function bC(i, e) {
    var t = i.length,
      r = e.length,
      n = t < r ? t : r;
    for (var a = 0; a < n; a++) {
      var s = i.charCodeAt(a) - e.charCodeAt(a);
      if (s !== 0) return s;
    }
    return t - r;
  }
  var so,
    Rd = C(function () {
      l();
      Pd();
      Id();
      so = /*#__PURE__*/function () {
        function so() {
          _classCallCheck(this, so);
          this.offsets = {
            defaults: 0n,
            base: 0n,
            components: 0n,
            utilities: 0n,
            variants: 0n,
            user: 0n
          }, this.layerPositions = {
            defaults: 0n,
            base: 1n,
            components: 2n,
            utilities: 3n,
            user: 4n,
            variants: 5n
          }, this.reservedVariantBits = 0n, this.variantOffsets = new Map();
        }
        return _createClass(so, [{
          key: "create",
          value: function create(e) {
            return {
              layer: e,
              parentLayer: e,
              arbitrary: 0n,
              variants: 0n,
              parallelIndex: 0n,
              index: this.offsets[e]++,
              propertyOffset: 0n,
              property: "",
              options: []
            };
          }
        }, {
          key: "arbitraryProperty",
          value: function arbitraryProperty(e) {
            return _objectSpread(_objectSpread({}, this.create("utilities")), {}, {
              arbitrary: 1n,
              property: e
            });
          }
        }, {
          key: "forVariant",
          value: function forVariant(e) {
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var r = this.variantOffsets.get(e);
            if (r === void 0) throw new Error("Cannot find offset for unknown variant ".concat(e));
            return _objectSpread(_objectSpread({}, this.create("variants")), {}, {
              variants: r << BigInt(t)
            });
          }
        }, {
          key: "applyVariantOffset",
          value: function applyVariantOffset(e, t, r) {
            return r.variant = t.variants, _objectSpread(_objectSpread({}, e), {}, {
              layer: "variants",
              parentLayer: e.layer === "variants" ? e.parentLayer : e.layer,
              variants: e.variants | t.variants,
              options: r.sort ? [].concat(r, e.options) : e.options,
              parallelIndex: qd([e.parallelIndex, t.parallelIndex])
            });
          }
        }, {
          key: "applyParallelOffset",
          value: function applyParallelOffset(e, t) {
            return _objectSpread(_objectSpread({}, e), {}, {
              parallelIndex: BigInt(t)
            });
          }
        }, {
          key: "recordVariants",
          value: function recordVariants(e, t) {
            var _iterator89 = _createForOfIteratorHelper(e),
              _step89;
            try {
              for (_iterator89.s(); !(_step89 = _iterator89.n()).done;) {
                var r = _step89.value;
                this.recordVariant(r, t(r));
              }
            } catch (err) {
              _iterator89.e(err);
            } finally {
              _iterator89.f();
            }
          }
        }, {
          key: "recordVariant",
          value: function recordVariant(e) {
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            return this.variantOffsets.set(e, 1n << this.reservedVariantBits), this.reservedVariantBits += BigInt(t), _objectSpread(_objectSpread({}, this.create("variants")), {}, {
              variants: this.variantOffsets.get(e)
            });
          }
        }, {
          key: "compare",
          value: function compare(e, t) {
            if (e.layer !== t.layer) return this.layerPositions[e.layer] - this.layerPositions[t.layer];
            if (e.parentLayer !== t.parentLayer) return this.layerPositions[e.parentLayer] - this.layerPositions[t.parentLayer];
            var _iterator90 = _createForOfIteratorHelper(e.options),
              _step90;
            try {
              for (_iterator90.s(); !(_step90 = _iterator90.n()).done;) {
                var r = _step90.value;
                var _iterator91 = _createForOfIteratorHelper(t.options),
                  _step91;
                try {
                  for (_iterator91.s(); !(_step91 = _iterator91.n()).done;) {
                    var _qd;
                    var n = _step91.value;
                    if (r.id !== n.id || !r.sort || !n.sort) continue;
                    var a = (_qd = qd([r.variant, n.variant])) !== null && _qd !== void 0 ? _qd : 0n,
                      s = ~(a | a - 1n),
                      o = e.variants & s,
                      _u5 = t.variants & s;
                    if (o !== _u5) continue;
                    var c = r.sort({
                      value: r.value,
                      modifier: r.modifier
                    }, {
                      value: n.value,
                      modifier: n.modifier
                    });
                    if (c !== 0) return c;
                  }
                } catch (err) {
                  _iterator91.e(err);
                } finally {
                  _iterator91.f();
                }
              }
            } catch (err) {
              _iterator90.e(err);
            } finally {
              _iterator90.f();
            }
            return e.variants !== t.variants ? e.variants - t.variants : e.parallelIndex !== t.parallelIndex ? e.parallelIndex - t.parallelIndex : e.arbitrary !== t.arbitrary ? e.arbitrary - t.arbitrary : e.propertyOffset !== t.propertyOffset ? e.propertyOffset - t.propertyOffset : e.index - t.index;
          }
        }, {
          key: "recalculateVariantOffsets",
          value: function recalculateVariantOffsets() {
            var e = Array.from(this.variantOffsets.entries()).filter(function (_ref275) {
                var _ref276 = _slicedToArray(_ref275, 1),
                  n = _ref276[0];
                return n.startsWith("[");
              }).sort(function (_ref277, _ref278) {
                var _ref279 = _slicedToArray(_ref277, 1),
                  n = _ref279[0];
                var _ref280 = _slicedToArray(_ref278, 1),
                  a = _ref280[0];
                return bC(n, a);
              }),
              t = e.map(function (_ref281) {
                var _ref282 = _slicedToArray(_ref281, 2),
                  n = _ref282[1];
                return n;
              }).sort(function (n, a) {
                return An(n - a);
              });
            return e.map(function (_ref283, a) {
              var _ref284 = _slicedToArray(_ref283, 2),
                n = _ref284[1];
              return [n, t[a]];
            }).filter(function (_ref285) {
              var _ref286 = _slicedToArray(_ref285, 2),
                n = _ref286[0],
                a = _ref286[1];
              return n !== a;
            });
          }
        }, {
          key: "remapArbitraryVariantOffsets",
          value: function remapArbitraryVariantOffsets(e) {
            var t = this.recalculateVariantOffsets();
            return t.length === 0 ? e : e.map(function (r) {
              var _r14 = _slicedToArray(r, 2),
                n = _r14[0],
                a = _r14[1];
              return n = _objectSpread(_objectSpread({}, n), {}, {
                variants: Dd(n.variants, t)
              }), [n, a];
            });
          }
        }, {
          key: "sortArbitraryProperties",
          value: function sortArbitraryProperties(e) {
            var t = new Set();
            var _iterator92 = _createForOfIteratorHelper(e),
              _step92;
            try {
              for (_iterator92.s(); !(_step92 = _iterator92.n()).done;) {
                var _step92$value = _slicedToArray(_step92.value, 1),
                  s = _step92$value[0];
                s.arbitrary === 1n && t.add(s.property);
              }
            } catch (err) {
              _iterator92.e(err);
            } finally {
              _iterator92.f();
            }
            if (t.size === 0) return e;
            var r = Array.from(t).sort(),
              n = new Map(),
              a = 1n;
            var _iterator93 = _createForOfIteratorHelper(r),
              _step93;
            try {
              for (_iterator93.s(); !(_step93 = _iterator93.n()).done;) {
                var _s15 = _step93.value;
                n.set(_s15, a++);
              }
            } catch (err) {
              _iterator93.e(err);
            } finally {
              _iterator93.f();
            }
            return e.map(function (s) {
              var _n$get;
              var _s14 = _slicedToArray(s, 2),
                o = _s14[0],
                u = _s14[1];
              return o = _objectSpread(_objectSpread({}, o), {}, {
                propertyOffset: (_n$get = n.get(o.property)) !== null && _n$get !== void 0 ? _n$get : 0n
              }), [o, u];
            });
          }
        }, {
          key: "sort",
          value: function sort(e) {
            var _this15 = this;
            return e = this.remapArbitraryVariantOffsets(e), e = this.sortArbitraryProperties(e), e.sort(function (_ref287, _ref288) {
              var _ref289 = _slicedToArray(_ref287, 1),
                t = _ref289[0];
              var _ref290 = _slicedToArray(_ref288, 1),
                r = _ref290[0];
              return An(_this15.compare(t, r));
            });
          }
        }]);
      }();
    });
  function uo(i, e) {
    var t = i.tailwindConfig.prefix;
    return typeof t == "function" ? t(e) : t + e;
  }
  function Bd(_ref291) {
    var _ref291$type = _ref291.type,
      i = _ref291$type === void 0 ? "any" : _ref291$type,
      e = _objectWithoutProperties(_ref291, _excluded9);
    var t = [].concat(i);
    return _objectSpread(_objectSpread({}, e), {}, {
      types: t.map(function (r) {
        return Array.isArray(r) ? _objectSpread({
          type: r[0]
        }, r[1]) : {
          type: r,
          preferOnConflict: !1
        };
      })
    });
  }
  function vC(i) {
    var e = [],
      t = "",
      r = 0;
    for (var n = 0; n < i.length; n++) {
      var a = i[n];
      if (a === "\\") t += "\\" + i[++n];else if (a === "{") ++r, e.push(t.trim()), t = "";else if (a === "}") {
        if (--r < 0) throw new Error("Your { and } are unbalanced.");
        e.push(t.trim()), t = "";
      } else t += a;
    }
    return t.length > 0 && e.push(t.trim()), e = e.filter(function (n) {
      return n !== "";
    }), e;
  }
  function xC(i, e) {
    var _ref292 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref292$before = _ref292.before,
      t = _ref292$before === void 0 ? [] : _ref292$before;
    if (t = [].concat(t), t.length <= 0) {
      i.push(e);
      return;
    }
    var r = i.length - 1;
    var _iterator94 = _createForOfIteratorHelper(t),
      _step94;
    try {
      for (_iterator94.s(); !(_step94 = _iterator94.n()).done;) {
        var n = _step94.value;
        var a = i.indexOf(n);
        a !== -1 && (r = Math.min(r, a));
      }
    } catch (err) {
      _iterator94.e(err);
    } finally {
      _iterator94.f();
    }
    i.splice(r, 0, e);
  }
  function Fd(i) {
    return Array.isArray(i) ? i.flatMap(function (e) {
      return !Array.isArray(e) && !ie(e) ? e : Bt(e);
    }) : Fd([i]);
  }
  function kC(i, e) {
    return (0, ao["default"])(function (r) {
      var n = [];
      return e && e(r), r.walkClasses(function (a) {
        n.push(a.value);
      }), n;
    }).transformSync(i);
  }
  function SC(i) {
    i.walkPseudos(function (e) {
      e.value === ":not" && e.remove();
    });
  }
  function CC(i) {
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      containsNonOnDemandable: !1
    };
    var t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var r = [],
      n = [];
    i.type === "rule" ? n.push.apply(n, _toConsumableArray(i.selectors)) : i.type === "atrule" && i.walkRules(function (a) {
      return n.push.apply(n, _toConsumableArray(a.selectors));
    });
    for (var _i16 = 0, _n13 = n; _i16 < _n13.length; _i16++) {
      var a = _n13[_i16];
      var s = kC(a, SC);
      s.length === 0 && (e.containsNonOnDemandable = !0);
      var _iterator95 = _createForOfIteratorHelper(s),
        _step95;
      try {
        for (_iterator95.s(); !(_step95 = _iterator95.n()).done;) {
          var o = _step95.value;
          r.push(o);
        }
      } catch (err) {
        _iterator95.e(err);
      } finally {
        _iterator95.f();
      }
    }
    return t === 0 ? [e.containsNonOnDemandable || r.length === 0, r] : r;
  }
  function _n(i) {
    return Fd(i).flatMap(function (e) {
      var t = new Map(),
        _CC = CC(e),
        _CC2 = _slicedToArray(_CC, 2),
        r = _CC2[0],
        n = _CC2[1];
      return r && n.unshift(He), n.map(function (a) {
        return t.has(e) || t.set(e, e), [a, t.get(e)];
      });
    });
  }
  function Cn(i) {
    return i.startsWith("@") || i.includes("&");
  }
  function Zr(i) {
    i = i.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
    var e = vC(i).map(function (t) {
      if (!t.startsWith("@")) return function (_ref293) {
        var a = _ref293.format;
        return a(t);
      };
      var _exec = /@(\S*)( .+|[({].*)?/g.exec(t),
        _exec2 = _slicedToArray(_exec, 3),
        r = _exec2[1],
        n = _exec2[2];
      return function (_ref294) {
        var _n$trim;
        var a = _ref294.wrap;
        return a(z.atRule({
          name: r,
          params: (_n$trim = n === null || n === void 0 ? void 0 : n.trim()) !== null && _n$trim !== void 0 ? _n$trim : ""
        }));
      };
    }).reverse();
    return function (t) {
      var _iterator96 = _createForOfIteratorHelper(e),
        _step96;
      try {
        for (_iterator96.s(); !(_step96 = _iterator96.n()).done;) {
          var r = _step96.value;
          r(t);
        }
      } catch (err) {
        _iterator96.e(err);
      } finally {
        _iterator96.f();
      }
    };
  }
  function AC(i, e, _ref295) {
    var t = _ref295.variantList,
      r = _ref295.variantMap,
      n = _ref295.offsets,
      a = _ref295.classList;
    function s(p, m) {
      return p ? (0, Md["default"])(i, p, m) : i;
    }
    function o(p) {
      return Ft(i.prefix, p);
    }
    function u(p, m) {
      return p === He ? He : m.respectPrefix ? e.tailwindConfig.prefix + p : p;
    }
    function c(p, m) {
      var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var x = Ke(p),
        y = s(["theme"].concat(_toConsumableArray(x)), m);
      return Ge(x[0])(y, b);
    }
    var f = 0,
      d = {
        postcss: z,
        prefix: o,
        e: ce,
        config: s,
        theme: c,
        corePlugins: function corePlugins(p) {
          return Array.isArray(i.corePlugins) ? i.corePlugins.includes(p) : s(["corePlugins", p], !0);
        },
        variants: function variants() {
          return [];
        },
        addBase: function addBase(p) {
          var _iterator97 = _createForOfIteratorHelper(_n(p)),
            _step97;
          try {
            for (_iterator97.s(); !(_step97 = _iterator97.n()).done;) {
              var _step97$value = _slicedToArray(_step97.value, 2),
                m = _step97$value[0],
                b = _step97$value[1];
              var x = u(m, {}),
                y = n.create("base");
              e.candidateRuleMap.has(x) || e.candidateRuleMap.set(x, []), e.candidateRuleMap.get(x).push([{
                sort: y,
                layer: "base"
              }, b]);
            }
          } catch (err) {
            _iterator97.e(err);
          } finally {
            _iterator97.f();
          }
        },
        addDefaults: function addDefaults(p, m) {
          var b = _defineProperty({}, "@defaults ".concat(p), m);
          var _iterator98 = _createForOfIteratorHelper(_n(b)),
            _step98;
          try {
            for (_iterator98.s(); !(_step98 = _iterator98.n()).done;) {
              var _step98$value = _slicedToArray(_step98.value, 2),
                x = _step98$value[0],
                y = _step98$value[1];
              var w = u(x, {});
              e.candidateRuleMap.has(w) || e.candidateRuleMap.set(w, []), e.candidateRuleMap.get(w).push([{
                sort: n.create("defaults"),
                layer: "defaults"
              }, y]);
            }
          } catch (err) {
            _iterator98.e(err);
          } finally {
            _iterator98.f();
          }
        },
        addComponents: function addComponents(p, m) {
          m = Object.assign({}, {
            preserveSource: !1,
            respectPrefix: !0,
            respectImportant: !1
          }, Array.isArray(m) ? {} : m);
          var _iterator99 = _createForOfIteratorHelper(_n(p)),
            _step99;
          try {
            for (_iterator99.s(); !(_step99 = _iterator99.n()).done;) {
              var _step99$value = _slicedToArray(_step99.value, 2),
                x = _step99$value[0],
                y = _step99$value[1];
              var w = u(x, m);
              a.add(w), e.candidateRuleMap.has(w) || e.candidateRuleMap.set(w, []), e.candidateRuleMap.get(w).push([{
                sort: n.create("components"),
                layer: "components",
                options: m
              }, y]);
            }
          } catch (err) {
            _iterator99.e(err);
          } finally {
            _iterator99.f();
          }
        },
        addUtilities: function addUtilities(p, m) {
          m = Object.assign({}, {
            preserveSource: !1,
            respectPrefix: !0,
            respectImportant: !0
          }, Array.isArray(m) ? {} : m);
          var _iterator100 = _createForOfIteratorHelper(_n(p)),
            _step100;
          try {
            for (_iterator100.s(); !(_step100 = _iterator100.n()).done;) {
              var _step100$value = _slicedToArray(_step100.value, 2),
                x = _step100$value[0],
                y = _step100$value[1];
              var w = u(x, m);
              a.add(w), e.candidateRuleMap.has(w) || e.candidateRuleMap.set(w, []), e.candidateRuleMap.get(w).push([{
                sort: n.create("utilities"),
                layer: "utilities",
                options: m
              }, y]);
            }
          } catch (err) {
            _iterator100.e(err);
          } finally {
            _iterator100.f();
          }
        },
        matchUtilities: function matchUtilities(p, m) {
          m = Bd(_objectSpread(_objectSpread({}, {
            respectPrefix: !0,
            respectImportant: !0,
            modifiers: !1
          }), m));
          var x = n.create("utilities");
          var _loop10 = function _loop10(y) {
            var S = function S(E, _ref296) {
                var I = _ref296.isOnlyPlugin;
                var _us = us(m.types, E, m, i),
                  _us2 = _slicedToArray(_us, 3),
                  q = _us2[0],
                  R = _us2[1],
                  J = _us2[2];
                if (q === void 0) return [];
                if (!m.types.some(function (_ref297) {
                  var ee = _ref297.type;
                  return ee === R;
                })) if (I) F.warn(["Unnecessary typehint `".concat(R, "` in `").concat(y, "-").concat(E, "`."), "You can safely update it to `".concat(y, "-").concat(E.replace(R + ":", ""), "`.")]);else return [];
                if (!Lt(q)) return [];
                var ue = {
                    get modifier() {
                      return m.modifiers || F.warn("modifier-used-without-options-for-".concat(y), ["Your plugin must set `modifiers: true` in its options to support modifiers."]), J;
                    }
                  },
                  de = K(i, "generalizedModifiers");
                return [].concat(de ? k(q, ue) : k(q)).filter(Boolean).map(function (ee) {
                  return _defineProperty({}, fn(y, E), ee);
                });
              },
              w = u(y, m),
              k = p[y];
            a.add([w, m]);
            var _ = [{
              sort: x,
              layer: "utilities",
              options: m
            }, S];
            e.candidateRuleMap.has(w) || e.candidateRuleMap.set(w, []), e.candidateRuleMap.get(w).push(_);
          };
          for (var y in p) {
            _loop10(y);
          }
        },
        matchComponents: function matchComponents(p, m) {
          m = Bd(_objectSpread(_objectSpread({}, {
            respectPrefix: !0,
            respectImportant: !1,
            modifiers: !1
          }), m));
          var x = n.create("components");
          var _loop11 = function _loop11(y) {
            var S = function S(E, _ref299) {
                var I = _ref299.isOnlyPlugin;
                var _us3 = us(m.types, E, m, i),
                  _us4 = _slicedToArray(_us3, 3),
                  q = _us4[0],
                  R = _us4[1],
                  J = _us4[2];
                if (q === void 0) return [];
                if (!m.types.some(function (_ref300) {
                  var ee = _ref300.type;
                  return ee === R;
                })) if (I) F.warn(["Unnecessary typehint `".concat(R, "` in `").concat(y, "-").concat(E, "`."), "You can safely update it to `".concat(y, "-").concat(E.replace(R + ":", ""), "`.")]);else return [];
                if (!Lt(q)) return [];
                var ue = {
                    get modifier() {
                      return m.modifiers || F.warn("modifier-used-without-options-for-".concat(y), ["Your plugin must set `modifiers: true` in its options to support modifiers."]), J;
                    }
                  },
                  de = K(i, "generalizedModifiers");
                return [].concat(de ? k(q, ue) : k(q)).filter(Boolean).map(function (ee) {
                  return _defineProperty({}, fn(y, E), ee);
                });
              },
              w = u(y, m),
              k = p[y];
            a.add([w, m]);
            var _ = [{
              sort: x,
              layer: "components",
              options: m
            }, S];
            e.candidateRuleMap.has(w) || e.candidateRuleMap.set(w, []), e.candidateRuleMap.get(w).push(_);
          };
          for (var y in p) {
            _loop11(y);
          }
        },
        addVariant: function addVariant(p, m) {
          var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          m = [].concat(m).map(function (x) {
            if (typeof x != "string") return function () {
              var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              var w = y.args,
                k = y.modifySelectors,
                S = y.container,
                _ = y.separator,
                E = y.wrap,
                I = y.format,
                q = x(Object.assign({
                  modifySelectors: k,
                  container: S,
                  separator: _
                }, b.type === oo.MatchVariant && {
                  args: w,
                  wrap: E,
                  format: I
                }));
              if (typeof q == "string" && !Cn(q)) throw new Error("Your custom variant `".concat(p, "` has an invalid format string. Make sure it's an at-rule or contains a `&` placeholder."));
              return Array.isArray(q) ? q.filter(function (R) {
                return typeof R == "string";
              }).map(function (R) {
                return Zr(R);
              }) : q && typeof q == "string" && Zr(q)(y);
            };
            if (!Cn(x)) throw new Error("Your custom variant `".concat(p, "` has an invalid format string. Make sure it's an at-rule or contains a `&` placeholder."));
            return Zr(x);
          }), xC(t, p, b), r.set(p, m), e.variantOptions.set(p, b);
        },
        matchVariant: function matchVariant(p, m, b) {
          var _b$id, _b$values2;
          var x = (_b$id = b === null || b === void 0 ? void 0 : b.id) !== null && _b$id !== void 0 ? _b$id : ++f,
            y = p === "@",
            w = K(i, "generalizedModifiers");
          var _loop12 = function _loop12() {
            var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i17], 2),
              S = _Object$entries2$_i[0],
              _ = _Object$entries2$_i[1];
            S !== "DEFAULT" && d.addVariant(y ? "".concat(p).concat(S) : "".concat(p, "-").concat(S), function (_ref302) {
              var E = _ref302.args,
                I = _ref302.container;
              return m(_, w ? {
                modifier: E === null || E === void 0 ? void 0 : E.modifier,
                container: I
              } : {
                container: I
              });
            }, _objectSpread(_objectSpread({}, b), {}, {
              value: _,
              id: x,
              type: oo.MatchVariant,
              variantInfo: lo.Base
            }));
          };
          for (var _i17 = 0, _Object$entries2 = Object.entries((_b$values = b === null || b === void 0 ? void 0 : b.values) !== null && _b$values !== void 0 ? _b$values : {}); _i17 < _Object$entries2.length; _i17++) {
            var _b$values;
            _loop12();
          }
          var k = ("DEFAULT" in ((_b$values2 = b === null || b === void 0 ? void 0 : b.values) !== null && _b$values2 !== void 0 ? _b$values2 : {}));
          d.addVariant(p, function (_ref303) {
            var _S$value;
            var S = _ref303.args,
              _ = _ref303.container;
            return (S === null || S === void 0 ? void 0 : S.value) === Kr && !k ? null : m((S === null || S === void 0 ? void 0 : S.value) === Kr ? b.values.DEFAULT : (_S$value = S === null || S === void 0 ? void 0 : S.value) !== null && _S$value !== void 0 ? _S$value : typeof S == "string" ? S : "", w ? {
              modifier: S === null || S === void 0 ? void 0 : S.modifier,
              container: _
            } : {
              container: _
            });
          }, _objectSpread(_objectSpread({}, b), {}, {
            id: x,
            type: oo.MatchVariant,
            variantInfo: lo.Dynamic
          }));
        }
      };
    return d;
  }
  function On(i) {
    return fo.has(i) || fo.set(i, new Map()), fo.get(i);
  }
  function Nd(i, e) {
    var t = !1,
      r = new Map();
    var _iterator101 = _createForOfIteratorHelper(i),
      _step101;
    try {
      for (_iterator101.s(); !(_step101 = _iterator101.n()).done;) {
        var _te$statSync;
        var n = _step101.value;
        if (!n) continue;
        var a = gs.parse(n),
          s = a.hash ? a.href.replace(a.hash, "") : a.href;
        s = a.search ? s.replace(a.search, "") : s;
        var o = (_te$statSync = te.statSync(decodeURIComponent(s), {
          throwIfNoEntry: !1
        })) === null || _te$statSync === void 0 ? void 0 : _te$statSync.mtimeMs;
        !o || ((!e.has(n) || o > e.get(n)) && (t = !0), r.set(n, o));
      }
    } catch (err) {
      _iterator101.e(err);
    } finally {
      _iterator101.f();
    }
    return [t, r];
  }
  function Ld(i) {
    i.walkAtRules(function (e) {
      ["responsive", "variants"].includes(e.name) && (Ld(e), e.before(e.nodes), e.remove());
    });
  }
  function _C(i) {
    var e = [];
    return i.each(function (t) {
      t.type === "atrule" && ["responsive", "variants"].includes(t.name) && (t.name = "layer", t.params = "utilities");
    }), i.walkAtRules("layer", function (t) {
      if (Ld(t), t.params === "base") {
        var _iterator102 = _createForOfIteratorHelper(t.nodes),
          _step102;
        try {
          var _loop13 = function _loop13() {
            var r = _step102.value;
            e.push(function (_ref304) {
              var n = _ref304.addBase;
              n(r, {
                respectPrefix: !1
              });
            });
          };
          for (_iterator102.s(); !(_step102 = _iterator102.n()).done;) {
            _loop13();
          }
        } catch (err) {
          _iterator102.e(err);
        } finally {
          _iterator102.f();
        }
        t.remove();
      } else if (t.params === "components") {
        var _iterator103 = _createForOfIteratorHelper(t.nodes),
          _step103;
        try {
          var _loop14 = function _loop14() {
            var r = _step103.value;
            e.push(function (_ref305) {
              var n = _ref305.addComponents;
              n(r, {
                respectPrefix: !1,
                preserveSource: !0
              });
            });
          };
          for (_iterator103.s(); !(_step103 = _iterator103.n()).done;) {
            _loop14();
          }
        } catch (err) {
          _iterator103.e(err);
        } finally {
          _iterator103.f();
        }
        t.remove();
      } else if (t.params === "utilities") {
        var _iterator104 = _createForOfIteratorHelper(t.nodes),
          _step104;
        try {
          var _loop15 = function _loop15() {
            var r = _step104.value;
            e.push(function (_ref306) {
              var n = _ref306.addUtilities;
              n(r, {
                respectPrefix: !1,
                preserveSource: !0
              });
            });
          };
          for (_iterator104.s(); !(_step104 = _iterator104.n()).done;) {
            _loop15();
          }
        } catch (err) {
          _iterator104.e(err);
        } finally {
          _iterator104.f();
        }
        t.remove();
      }
    }), e;
  }
  function OC(i, e) {
    var t = Object.entries(_objectSpread(_objectSpread({}, H), hd)).map(function (_ref307) {
        var _ref308 = _slicedToArray(_ref307, 2),
          u = _ref308[0],
          c = _ref308[1];
        return i.tailwindConfig.corePlugins.includes(u) ? c : null;
      }).filter(Boolean),
      r = i.tailwindConfig.plugins.map(function (u) {
        return u.__isOptionsFunction && (u = u()), typeof u == "function" ? u : u.handler;
      }),
      n = _C(e),
      a = [H.childVariant, H.pseudoElementVariants, H.pseudoClassVariants, H.hasVariants, H.ariaVariants, H.dataVariants],
      s = [H.supportsVariants, H.reducedMotionVariants, H.prefersContrastVariants, H.screenVariants, H.orientationVariants, H.directionVariants, H.darkVariants, H.forcedColorsVariants, H.printVariant];
    return (i.tailwindConfig.darkMode === "class" || Array.isArray(i.tailwindConfig.darkMode) && i.tailwindConfig.darkMode[0] === "class") && (s = [H.supportsVariants, H.reducedMotionVariants, H.prefersContrastVariants, H.darkVariants, H.screenVariants, H.orientationVariants, H.directionVariants, H.forcedColorsVariants, H.printVariant]), [].concat(_toConsumableArray(t), a, _toConsumableArray(r), _toConsumableArray(s), _toConsumableArray(n));
  }
  function EC(i, e) {
    var _e$tailwindConfig$saf, _concat$, _e$tailwindConfig$dar;
    var t = [],
      r = new Map();
    e.variantMap = r;
    var n = new so();
    e.offsets = n;
    var a = new Set(),
      s = AC(e.tailwindConfig, e, {
        variantList: t,
        variantMap: r,
        offsets: n,
        classList: a
      });
    var _iterator105 = _createForOfIteratorHelper(i),
      _step105;
    try {
      for (_iterator105.s(); !(_step105 = _iterator105.n()).done;) {
        var _f4 = _step105.value;
        if (Array.isArray(_f4)) {
          var _iterator118 = _createForOfIteratorHelper(_f4),
            _step118;
          try {
            for (_iterator118.s(); !(_step118 = _iterator118.n()).done;) {
              var _d5 = _step118.value;
              _d5(s);
            }
          } catch (err) {
            _iterator118.e(err);
          } finally {
            _iterator118.f();
          }
        } else _f4 === null || _f4 === void 0 || _f4(s);
      }
    } catch (err) {
      _iterator105.e(err);
    } finally {
      _iterator105.f();
    }
    n.recordVariants(t, function (f) {
      return r.get(f).length;
    });
    var _iterator106 = _createForOfIteratorHelper(r.entries()),
      _step106;
    try {
      var _loop19 = function _loop19() {
        var _step106$value = _slicedToArray(_step106.value, 2),
          f = _step106$value[0],
          d = _step106$value[1];
        e.variantMap.set(f, d.map(function (p, m) {
          return [n.forVariant(f, m), p];
        }));
      };
      for (_iterator106.s(); !(_step106 = _iterator106.n()).done;) {
        _loop19();
      }
    } catch (err) {
      _iterator106.e(err);
    } finally {
      _iterator106.f();
    }
    var o = ((_e$tailwindConfig$saf = e.tailwindConfig.safelist) !== null && _e$tailwindConfig$saf !== void 0 ? _e$tailwindConfig$saf : []).filter(Boolean);
    if (o.length > 0) {
      var f = [];
      var _iterator107 = _createForOfIteratorHelper(o),
        _step107;
      try {
        for (_iterator107.s(); !(_step107 = _iterator107.n()).done;) {
          var _d4 = _step107.value;
          if (typeof _d4 == "string") {
            e.changedContent.push({
              content: _d4,
              extension: "html"
            });
            continue;
          }
          if (_d4 instanceof RegExp) {
            F.warn("root-regex", ["Regular expressions in `safelist` work differently in Tailwind CSS v3.0.", "Update your `safelist` configuration to eliminate this warning.", "https://tailwindcss.com/docs/content-configuration#safelisting-classes"]);
            continue;
          }
          f.push(_d4);
        }
      } catch (err) {
        _iterator107.e(err);
      } finally {
        _iterator107.f();
      }
      if (f.length > 0) {
        var d = new Map(),
          p = e.tailwindConfig.prefix.length,
          m = f.some(function (b) {
            return b.pattern.source.includes("!");
          });
        var _iterator108 = _createForOfIteratorHelper(a),
          _step108;
        try {
          var _loop16 = function _loop16() {
            var b = _step108.value;
            var x = Array.isArray(b) ? function (_w$values) {
              var _b5 = _slicedToArray(b, 2),
                y = _b5[0],
                w = _b5[1],
                S = Object.keys((_w$values = w === null || w === void 0 ? void 0 : w.values) !== null && _w$values !== void 0 ? _w$values : {}).map(function (_) {
                  return Jr(y, _);
                });
              return w !== null && w !== void 0 && w.supportsNegativeValues && (S = [].concat(_toConsumableArray(S), _toConsumableArray(S.map(function (_) {
                return "-" + _;
              }))), S = [].concat(_toConsumableArray(S), _toConsumableArray(S.map(function (_) {
                return _.slice(0, p) + "-" + _.slice(p);
              })))), w.types.some(function (_ref309) {
                var _ = _ref309.type;
                return _ === "color";
              }) && (S = [].concat(_toConsumableArray(S), _toConsumableArray(S.flatMap(function (_) {
                return Object.keys(e.tailwindConfig.theme.opacity).map(function (E) {
                  return "".concat(_, "/").concat(E);
                });
              })))), m && w !== null && w !== void 0 && w.respectImportant && (S = [].concat(_toConsumableArray(S), _toConsumableArray(S.map(function (_) {
                return "!" + _;
              })))), S;
            }() : [b];
            var _iterator110 = _createForOfIteratorHelper(x),
              _step110;
            try {
              for (_iterator110.s(); !(_step110 = _iterator110.n()).done;) {
                var y = _step110.value;
                var _iterator111 = _createForOfIteratorHelper(f),
                  _step111;
                try {
                  for (_iterator111.s(); !(_step111 = _iterator111.n()).done;) {
                    var _step111$value = _step111.value,
                      w = _step111$value.pattern,
                      _step111$value$varian = _step111$value.variants,
                      k = _step111$value$varian === void 0 ? [] : _step111$value$varian;
                    if (w.lastIndex = 0, d.has(w) || d.set(w, 0), !!w.test(y)) {
                      d.set(w, d.get(w) + 1), e.changedContent.push({
                        content: y,
                        extension: "html"
                      });
                      var _iterator112 = _createForOfIteratorHelper(k),
                        _step112;
                      try {
                        for (_iterator112.s(); !(_step112 = _iterator112.n()).done;) {
                          var S = _step112.value;
                          e.changedContent.push({
                            content: S + e.tailwindConfig.separator + y,
                            extension: "html"
                          });
                        }
                      } catch (err) {
                        _iterator112.e(err);
                      } finally {
                        _iterator112.f();
                      }
                    }
                  }
                } catch (err) {
                  _iterator111.e(err);
                } finally {
                  _iterator111.f();
                }
              }
            } catch (err) {
              _iterator110.e(err);
            } finally {
              _iterator110.f();
            }
          };
          for (_iterator108.s(); !(_step108 = _iterator108.n()).done;) {
            _loop16();
          }
        } catch (err) {
          _iterator108.e(err);
        } finally {
          _iterator108.f();
        }
        var _iterator109 = _createForOfIteratorHelper(d.entries()),
          _step109;
        try {
          for (_iterator109.s(); !(_step109 = _iterator109.n()).done;) {
            var _step109$value = _slicedToArray(_step109.value, 2),
              b = _step109$value[0],
              x = _step109$value[1];
            x === 0 && F.warn(["The safelist pattern `".concat(b, "` doesn't match any Tailwind CSS classes."), "Fix this pattern or remove it from your `safelist` configuration.", "https://tailwindcss.com/docs/content-configuration#safelisting-classes"]);
          }
        } catch (err) {
          _iterator109.e(err);
        } finally {
          _iterator109.f();
        }
      }
    }
    var u = (_concat$ = [].concat((_e$tailwindConfig$dar = e.tailwindConfig.darkMode) !== null && _e$tailwindConfig$dar !== void 0 ? _e$tailwindConfig$dar : "media")[1]) !== null && _concat$ !== void 0 ? _concat$ : "dark",
      c = [uo(e, u), uo(e, "group"), uo(e, "peer")];
    e.getClassOrder = function (d) {
      var p = _toConsumableArray(d).sort(function (y, w) {
          return y === w ? 0 : y < w ? -1 : 1;
        }),
        m = new Map(p.map(function (y) {
          return [y, null];
        })),
        b = kn(new Set(p), e, !0);
      b = e.offsets.sort(b);
      var x = BigInt(c.length);
      var _iterator113 = _createForOfIteratorHelper(b),
        _step113;
      try {
        for (_iterator113.s(); !(_step113 = _iterator113.n()).done;) {
          var _m$get2;
          var _step113$value = _slicedToArray(_step113.value, 2),
            y = _step113$value[1];
          var w = y.raws.tailwind.candidate;
          m.set(w, (_m$get2 = m.get(w)) !== null && _m$get2 !== void 0 ? _m$get2 : x++);
        }
      } catch (err) {
        _iterator113.e(err);
      } finally {
        _iterator113.f();
      }
      return d.map(function (y) {
        var _m$get;
        var w = (_m$get = m.get(y)) !== null && _m$get !== void 0 ? _m$get : null,
          k = c.indexOf(y);
        return w === null && k !== -1 && (w = BigInt(k)), [y, w];
      });
    }, e.getClassList = function () {
      var d = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var p = [];
      var _iterator114 = _createForOfIteratorHelper(a),
        _step114;
      try {
        for (_iterator114.s(); !(_step114 = _iterator114.n()).done;) {
          var _m3 = _step114.value;
          if (Array.isArray(_m3)) {
            var _x6$modifiers, _x6$types, _e$tailwindConfig$the;
            var _m4 = _slicedToArray(_m3, 2),
              _b6 = _m4[0],
              _x6 = _m4[1],
              y = [],
              w = Object.keys((_x6$modifiers = _x6 === null || _x6 === void 0 ? void 0 : _x6.modifiers) !== null && _x6$modifiers !== void 0 ? _x6$modifiers : {});
            (_x6 === null || _x6 === void 0 || (_x6$types = _x6.types) === null || _x6$types === void 0 ? void 0 : _x6$types.some(function (_ref310) {
              var _ = _ref310.type;
              return _ === "color";
            })) && w.push.apply(w, _toConsumableArray(Object.keys((_e$tailwindConfig$the = e.tailwindConfig.theme.opacity) !== null && _e$tailwindConfig$the !== void 0 ? _e$tailwindConfig$the : {})));
            var k = {
                modifiers: w
              },
              S = d.includeMetadata && w.length > 0;
            for (var _i18 = 0, _Object$entries3 = Object.entries((_x6$values = _x6 === null || _x6 === void 0 ? void 0 : _x6.values) !== null && _x6$values !== void 0 ? _x6$values : {}); _i18 < _Object$entries3.length; _i18++) {
              var _x6$values;
              var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i18], 2),
                _ = _Object$entries3$_i[0],
                E = _Object$entries3$_i[1];
              if (E == null) continue;
              var I = Jr(_b6, _);
              if (p.push(S ? [I, k] : I), _x6 !== null && _x6 !== void 0 && _x6.supportsNegativeValues && Xe(E)) {
                var q = Jr(_b6, "-".concat(_));
                y.push(S ? [q, k] : q);
              }
            }
            p.push.apply(p, y);
          } else p.push(_m3);
        }
      } catch (err) {
        _iterator114.e(err);
      } finally {
        _iterator114.f();
      }
      return p;
    }, e.getVariants = function () {
      var d = Math.random().toString(36).substring(7).toUpperCase(),
        p = [];
      var _iterator115 = _createForOfIteratorHelper(e.variantOptions.entries()),
        _step115;
      try {
        var _loop17 = function _loop17() {
          var _b$values3;
          var _step115$value = _slicedToArray(_step115.value, 2),
            m = _step115$value[0],
            b = _step115$value[1];
          b.variantInfo !== lo.Base && p.push({
            name: m,
            isArbitrary: b.type === Symbol["for"]("MATCH_VARIANT"),
            values: Object.keys((_b$values3 = b.values) !== null && _b$values3 !== void 0 ? _b$values3 : {}),
            hasDash: m !== "@",
            selectors: function selectors() {
              var _e$variantMap$get, _b$values4, _b$ot;
              var _ref311 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                x = _ref311.modifier,
                y = _ref311.value;
              var w = "TAILWINDPLACEHOLDER".concat(d),
                k = z.rule({
                  selector: ".".concat(w)
                }),
                S = z.root({
                  nodes: [k.clone()]
                }),
                _ = S.toString(),
                E = ((_e$variantMap$get = e.variantMap.get(m)) !== null && _e$variantMap$get !== void 0 ? _e$variantMap$get : []).flatMap(function (_ref312) {
                  var _ref313 = _slicedToArray(_ref312, 2),
                    oe = _ref313[0],
                    he = _ref313[1];
                  return he;
                }),
                I = [];
              var _iterator116 = _createForOfIteratorHelper(E),
                _step116;
              try {
                var _loop18 = function _loop18() {
                  var _b$values$y, _b$values5;
                  var oe = _step116.value;
                  var he = [],
                    ai = {
                      args: {
                        modifier: x,
                        value: (_b$values$y = (_b$values5 = b.values) === null || _b$values5 === void 0 ? void 0 : _b$values5[y]) !== null && _b$values$y !== void 0 ? _b$values$y : y
                      },
                      separator: e.tailwindConfig.separator,
                      modifySelectors: function modifySelectors(Ce) {
                        return S.each(function (Yn) {
                          Yn.type === "rule" && (Yn.selectors = Yn.selectors.map(function (su) {
                            return Ce({
                              get className() {
                                return to(su);
                              },
                              selector: su
                            });
                          }));
                        }), S;
                      },
                      format: function format(Ce) {
                        he.push(Ce);
                      },
                      wrap: function wrap(Ce) {
                        he.push("@".concat(Ce.name, " ").concat(Ce.params, " { & }"));
                      },
                      container: S
                    },
                    oi = oe(ai);
                  if (he.length > 0 && I.push(he), Array.isArray(oi)) {
                    var _iterator117 = _createForOfIteratorHelper(oi),
                      _step117;
                    try {
                      for (_iterator117.s(); !(_step117 = _iterator117.n()).done;) {
                        var Ce = _step117.value;
                        he = [], Ce(ai), I.push(he);
                      }
                    } catch (err) {
                      _iterator117.e(err);
                    } finally {
                      _iterator117.f();
                    }
                  }
                };
                for (_iterator116.s(); !(_step116 = _iterator116.n()).done;) {
                  _loop18();
                }
              } catch (err) {
                _iterator116.e(err);
              } finally {
                _iterator116.f();
              }
              var q = [],
                R = S.toString();
              _ !== R && (S.walkRules(function (oe) {
                var he = oe.selector,
                  ai = (0, ao["default"])(function (oi) {
                    oi.walkClasses(function (Ce) {
                      Ce.value = "".concat(m).concat(e.tailwindConfig.separator).concat(Ce.value);
                    });
                  }).processSync(he);
                q.push(he.replace(ai, "&").replace(w, "&"));
              }), S.walkAtRules(function (oe) {
                q.push("@".concat(oe.name, " (").concat(oe.params, ") { & }"));
              }));
              var J = !(y in ((_b$values4 = b.values) !== null && _b$values4 !== void 0 ? _b$values4 : {})),
                ue = (_b$ot = b[ot]) !== null && _b$ot !== void 0 ? _b$ot : {},
                de = function () {
                  return !(J || ue.respectPrefix === !1);
                }();
              I = I.map(function (oe) {
                return oe.map(function (he) {
                  return {
                    format: he,
                    respectPrefix: de
                  };
                });
              }), q = q.map(function (oe) {
                return {
                  format: oe,
                  respectPrefix: de
                };
              });
              var De = {
                  candidate: w,
                  context: e
                },
                ee = I.map(function (oe) {
                  return wn(".".concat(w), jt(oe, De), De).replace(".".concat(w), "&").replace("{ & }", "").trim();
                });
              return q.length > 0 && ee.push(jt(q, De).toString().replace(".".concat(w), "&")), ee;
            }
          });
        };
        for (_iterator115.s(); !(_step115 = _iterator115.n()).done;) {
          _loop17();
        }
      } catch (err) {
        _iterator115.e(err);
      } finally {
        _iterator115.f();
      }
      return p;
    };
  }
  function $d(i, e) {
    !i.classCache.has(e) || (i.notClassCache.add(e), i.classCache["delete"](e), i.applyClassCache["delete"](e), i.candidateRuleMap["delete"](e), i.candidateRuleCache["delete"](e), i.stylesheetCache = null);
  }
  function TC(i, e) {
    var t = e.raws.tailwind.candidate;
    if (!!t) {
      var _iterator119 = _createForOfIteratorHelper(i.ruleCache),
        _step119;
      try {
        for (_iterator119.s(); !(_step119 = _iterator119.n()).done;) {
          var r = _step119.value;
          r[1].raws.tailwind.candidate === t && i.ruleCache["delete"](r);
        }
      } catch (err) {
        _iterator119.e(err);
      } finally {
        _iterator119.f();
      }
      $d(i, t);
    }
  }
  function co(i) {
    var _i$blocklist;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : z.root();
    var r = {
        disposables: [],
        ruleCache: new Set(),
        candidateRuleCache: new Map(),
        classCache: new Map(),
        applyClassCache: new Map(),
        notClassCache: new Set((_i$blocklist = i.blocklist) !== null && _i$blocklist !== void 0 ? _i$blocklist : []),
        postCssNodeCache: new Map(),
        candidateRuleMap: new Map(),
        tailwindConfig: i,
        changedContent: e,
        variantMap: new Map(),
        stylesheetCache: null,
        variantOptions: new Map(),
        markInvalidUtilityCandidate: function markInvalidUtilityCandidate(a) {
          return $d(r, a);
        },
        markInvalidUtilityNode: function markInvalidUtilityNode(a) {
          return TC(r, a);
        }
      },
      n = OC(r, t);
    return EC(n, r), r;
  }
  function jd(i, e, t, r, n, a) {
    var s = e.opts.from,
      o = r !== null;
    Pe.DEBUG && console.log("Source path:", s);
    var u;
    if (o && zt.has(s)) u = zt.get(s);else if (ei.has(n)) {
      var p = ei.get(n);
      ut.get(p).add(s), zt.set(s, p), u = p;
    }
    var c = Ed(s, i);
    if (u) {
      var _Nd = Nd(_toConsumableArray(a), On(u)),
        _Nd2 = _slicedToArray(_Nd, 2),
        _p7 = _Nd2[0],
        m = _Nd2[1];
      if (!_p7 && !c) return [u, !1, m];
    }
    if (zt.has(s)) {
      var _p8 = zt.get(s);
      if (ut.has(_p8) && (ut.get(_p8)["delete"](s), ut.get(_p8).size === 0)) {
        ut["delete"](_p8);
        var _iterator120 = _createForOfIteratorHelper(ei),
          _step120;
        try {
          for (_iterator120.s(); !(_step120 = _iterator120.n()).done;) {
            var _step120$value = _slicedToArray(_step120.value, 2),
              _m5 = _step120$value[0],
              b = _step120$value[1];
            b === _p8 && ei["delete"](_m5);
          }
        } catch (err) {
          _iterator120.e(err);
        } finally {
          _iterator120.f();
        }
        var _iterator121 = _createForOfIteratorHelper(_p8.disposables.splice(0)),
          _step121;
        try {
          for (_iterator121.s(); !(_step121 = _iterator121.n()).done;) {
            var _m6 = _step121.value;
            _m6(_p8);
          }
        } catch (err) {
          _iterator121.e(err);
        } finally {
          _iterator121.f();
        }
      }
    }
    Pe.DEBUG && console.log("Setting up new context...");
    var f = co(t, [], i);
    Object.assign(f, {
      userConfigPath: r
    });
    var _Nd3 = Nd(_toConsumableArray(a), On(f)),
      _Nd4 = _slicedToArray(_Nd3, 2),
      d = _Nd4[1];
    return ei.set(n, f), zt.set(s, f), ut.has(f) || ut.set(f, new Set()), ut.get(f).add(s), [f, !0, d];
  }
  var Md,
    ao,
    ot,
    oo,
    lo,
    fo,
    zt,
    ei,
    ut,
    Xr = C(function () {
      l();
      je();
      ys();
      nt();
      Md = X(Ls()), ao = X(Me());
      Yr();
      za();
      un();
      St();
      Nt();
      Ua();
      pr();
      md();
      lt();
      lt();
      pi();
      Oe();
      fi();
      Ha();
      Sn();
      Td();
      Rd();
      ze();
      Ka();
      ot = Symbol(), oo = {
        AddVariant: Symbol["for"]("ADD_VARIANT"),
        MatchVariant: Symbol["for"]("MATCH_VARIANT")
      }, lo = {
        Base: 1 << 0,
        Dynamic: 1 << 1
      };
      fo = new WeakMap();
      zt = gd, ei = yd, ut = gn;
    });
  function po(i) {
    return i.ignore ? [] : i.glob ? h.env.ROLLUP_WATCH === "true" ? [{
      type: "dependency",
      file: i.base
    }] : [{
      type: "dir-dependency",
      dir: i.base,
      glob: i.glob
    }] : [{
      type: "dependency",
      file: i.base
    }];
  }
  var zd = C(function () {
    l();
  });
  function Vd(i, e) {
    return {
      handler: i,
      config: e
    };
  }
  var Ud,
    Wd = C(function () {
      l();
      Vd.withOptions = function (i) {
        var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
          return {};
        };
        var t = function t(r) {
          return {
            __options: r,
            handler: i(r),
            config: e(r)
          };
        };
        return t.__isOptionsFunction = !0, t.__pluginFunction = i, t.__configFunction = e, t;
      };
      Ud = Vd;
    });
  var ho = {};
  Ae(ho, {
    "default": function _default() {
      return PC;
    }
  });
  var PC,
    mo = C(function () {
      l();
      Wd();
      PC = Ud;
    });
  var Hd = v(function (c6, Gd) {
    l();
    var DC = (mo(), ho)["default"],
      IC = {
        overflow: "hidden",
        display: "-webkit-box",
        "-webkit-box-orient": "vertical"
      },
      qC = DC(function (_ref314) {
        var i = _ref314.matchUtilities,
          e = _ref314.addUtilities,
          t = _ref314.theme,
          r = _ref314.variants;
        var n = t("lineClamp");
        i({
          "line-clamp": function lineClamp(a) {
            return _objectSpread(_objectSpread({}, IC), {}, {
              "-webkit-line-clamp": "".concat(a)
            });
          }
        }, {
          values: n
        }), e([{
          ".line-clamp-none": {
            "-webkit-line-clamp": "unset"
          }
        }], r("lineClamp"));
      }, {
        theme: {
          lineClamp: {
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6"
          }
        },
        variants: {
          lineClamp: ["responsive"]
        }
      });
    Gd.exports = qC;
  });
  function go(i) {
    i.content.files.length === 0 && F.warn("content-problems", ["The `content` option in your Tailwind CSS configuration is missing or empty.", "Configure your content sources or your generated CSS will be missing styles.", "https://tailwindcss.com/docs/content-configuration"]);
    try {
      var e = Hd();
      i.plugins.includes(e) && (F.warn("line-clamp-in-core", ["As of Tailwind CSS v3.3, the `@tailwindcss/line-clamp` plugin is now included by default.", "Remove it from the `plugins` array in your configuration to eliminate this warning."]), i.plugins = i.plugins.filter(function (t) {
        return t !== e;
      }));
    } catch (_unused3) {}
    return i;
  }
  var Yd = C(function () {
    l();
    Oe();
  });
  var Qd,
    Jd = C(function () {
      l();
      Qd = function Qd() {
        return !1;
      };
    });
  var En,
    Xd = C(function () {
      l();
      En = {
        sync: function sync(i) {
          return [].concat(i);
        },
        generateTasks: function generateTasks(i) {
          return [{
            dynamic: !1,
            base: ".",
            negative: [],
            positive: [].concat(i),
            patterns: [].concat(i)
          }];
        },
        escapePath: function escapePath(i) {
          return i;
        }
      };
    });
  var yo,
    Kd = C(function () {
      l();
      yo = function yo(i) {
        return i;
      };
    });
  var Zd,
    eh = C(function () {
      l();
      Zd = function Zd() {
        return "";
      };
    });
  function th(i) {
    var e = i,
      t = Zd(i);
    return t !== "." && (e = i.substr(t.length), e.charAt(0) === "/" && (e = e.substr(1))), e.substr(0, 2) === "./" && (e = e.substr(2)), e.charAt(0) === "/" && (e = e.substr(1)), {
      base: t,
      glob: e
    };
  }
  var rh = C(function () {
    l();
    eh();
  });
  function ih(i, e) {
    var t = e.content.files;
    t = t.filter(function (o) {
      return typeof o == "string";
    }), t = t.map(yo);
    var r = En.generateTasks(t),
      n = [],
      a = [];
    var _iterator122 = _createForOfIteratorHelper(r),
      _step122;
    try {
      for (_iterator122.s(); !(_step122 = _iterator122.n()).done;) {
        var o = _step122.value;
        n.push.apply(n, _toConsumableArray(o.positive.map(function (u) {
          return nh(u, !1);
        }))), a.push.apply(a, _toConsumableArray(o.negative.map(function (u) {
          return nh(u, !0);
        })));
      }
    } catch (err) {
      _iterator122.e(err);
    } finally {
      _iterator122.f();
    }
    var s = [].concat(n, a);
    return s = MC(i, s), s = s.flatMap(BC), s = s.map(RC), s;
  }
  function nh(i, e) {
    var t = {
      original: i,
      base: i,
      ignore: e,
      pattern: i,
      glob: null
    };
    return Qd(i) && Object.assign(t, th(i)), t;
  }
  function RC(i) {
    var e = yo(i.base);
    return e = En.escapePath(e), i.pattern = i.glob ? "".concat(e, "/").concat(i.glob) : e, i.pattern = i.ignore ? "!".concat(i.pattern) : i.pattern, i;
  }
  function MC(i, e) {
    var t = [];
    return i.userConfigPath && i.tailwindConfig.content.relative && (t = [Z.dirname(i.userConfigPath)]), e.map(function (r) {
      var _Z;
      return r.base = (_Z = Z).resolve.apply(_Z, _toConsumableArray(t).concat([r.base])), r;
    });
  }
  function BC(i) {
    var e = [i];
    try {
      var t = te.realpathSync(i.base);
      t !== i.base && e.push(_objectSpread(_objectSpread({}, i), {}, {
        base: t
      }));
    } catch (_unused4) {}
    return e;
  }
  function sh(i, e, t) {
    var r = i.tailwindConfig.content.files.filter(function (s) {
        return typeof s.raw == "string";
      }).map(function (_ref315) {
        var s = _ref315.raw,
          _ref315$extension = _ref315.extension,
          o = _ref315$extension === void 0 ? "html" : _ref315$extension;
        return {
          content: s,
          extension: o
        };
      }),
      _FC = FC(e, t),
      _FC2 = _slicedToArray(_FC, 2),
      n = _FC2[0],
      a = _FC2[1];
    var _iterator123 = _createForOfIteratorHelper(n),
      _step123;
    try {
      for (_iterator123.s(); !(_step123 = _iterator123.n()).done;) {
        var s = _step123.value;
        var o = Z.extname(s).slice(1);
        r.push({
          file: s,
          extension: o
        });
      }
    } catch (err) {
      _iterator123.e(err);
    } finally {
      _iterator123.f();
    }
    return [r, a];
  }
  function FC(i, e) {
    var t = i.map(function (s) {
        return s.pattern;
      }),
      r = new Map(),
      n = new Set();
    Pe.DEBUG && console.time("Finding changed files");
    var a = En.sync(t, {
      absolute: !0
    });
    var _iterator124 = _createForOfIteratorHelper(a),
      _step124;
    try {
      for (_iterator124.s(); !(_step124 = _iterator124.n()).done;) {
        var s = _step124.value;
        var o = e.get(s) || -1 / 0,
          _u6 = te.statSync(s).mtimeMs;
        _u6 > o && (n.add(s), r.set(s, _u6));
      }
    } catch (err) {
      _iterator124.e(err);
    } finally {
      _iterator124.f();
    }
    return Pe.DEBUG && console.timeEnd("Finding changed files"), [n, r];
  }
  var ah = C(function () {
    l();
    je();
    yt();
    Jd();
    Xd();
    Kd();
    rh();
    lt();
  });
  function oh() {}
  var lh = C(function () {
    l();
  });
  function jC(i, e) {
    var _iterator125 = _createForOfIteratorHelper(e),
      _step125;
    try {
      for (_iterator125.s(); !(_step125 = _iterator125.n()).done;) {
        var t = _step125.value;
        var r = "".concat(i).concat(t);
        if (te.existsSync(r) && te.statSync(r).isFile()) return r;
      }
    } catch (err) {
      _iterator125.e(err);
    } finally {
      _iterator125.f();
    }
    var _iterator126 = _createForOfIteratorHelper(e),
      _step126;
    try {
      for (_iterator126.s(); !(_step126 = _iterator126.n()).done;) {
        var _t11 = _step126.value;
        var _r15 = "".concat(i, "/index").concat(_t11);
        if (te.existsSync(_r15)) return _r15;
      }
    } catch (err) {
      _iterator126.e(err);
    } finally {
      _iterator126.f();
    }
    return null;
  }
  function uh(i, e, t) {
    var r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Z.extname(i);
    return /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var n, a, _i19, _arr2, s;
      return _regeneratorRuntime().wrap(function _callee4$(_context18) {
        while (1) switch (_context18.prev = _context18.next) {
          case 0:
            n = jC(Z.resolve(e, i), NC.includes(r) ? LC : $C);
            if (!(n === null || t.has(n))) {
              _context18.next = 3;
              break;
            }
            return _context18.abrupt("return");
          case 3:
            t.add(n);
            _context18.next = 6;
            return n;
          case 6:
            e = Z.dirname(n);
            r = Z.extname(n);
            a = te.readFileSync(n, "utf-8");
            _i19 = 0, _arr2 = [].concat(_toConsumableArray(a.matchAll(/import[\s\S]*?['"](.{3,}?)['"]/gi)), _toConsumableArray(a.matchAll(/import[\s\S]*from[\s\S]*?['"](.{3,}?)['"]/gi)), _toConsumableArray(a.matchAll(/require\(['"`](.+)['"`]\)/gi)));
          case 10:
            if (!(_i19 < _arr2.length)) {
              _context18.next = 18;
              break;
            }
            s = _arr2[_i19];
            _context18.t0 = !s[1].startsWith(".");
            if (_context18.t0) {
              _context18.next = 15;
              break;
            }
            return _context18.delegateYield(uh(s[1], e, t, r), "t1", 15);
          case 15:
            _i19++;
            _context18.next = 10;
            break;
          case 18:
          case "end":
            return _context18.stop();
        }
      }, _callee4);
    })();
  }
  function wo(i) {
    return i === null ? new Set() : new Set(uh(i, Z.dirname(i), new Set()));
  }
  var NC,
    LC,
    $C,
    fh = C(function () {
      l();
      je();
      yt();
      NC = [".js", ".cjs", ".mjs"], LC = ["", ".js", ".cjs", ".mjs", ".ts", ".cts", ".mts", ".jsx", ".tsx"], $C = ["", ".ts", ".cts", ".mts", ".tsx", ".js", ".cjs", ".mjs", ".jsx"];
    });
  function zC(i, e) {
    if (bo.has(i)) return bo.get(i);
    var t = ih(i, e);
    return bo.set(i, t).get(i);
  }
  function VC(i) {
    var _ref318, _i$config;
    var e = ms(i);
    if (e !== null) {
      var _ref316 = ph.get(e) || [],
        _ref317 = _slicedToArray(_ref316, 4),
        r = _ref317[0],
        n = _ref317[1],
        a = _ref317[2],
        s = _ref317[3],
        o = wo(e),
        _u7 = !1,
        c = new Map();
      var _iterator127 = _createForOfIteratorHelper(o),
        _step127;
      try {
        for (_iterator127.s(); !(_step127 = _iterator127.n()).done;) {
          var p = _step127.value;
          var m = te.statSync(p).mtimeMs;
          c.set(p, m), (!s || !s.has(p) || m > s.get(p)) && (_u7 = !0);
        }
      } catch (err) {
        _iterator127.e(err);
      } finally {
        _iterator127.f();
      }
      if (!_u7) return [r, e, n, a];
      var _iterator128 = _createForOfIteratorHelper(o),
        _step128;
      try {
        for (_iterator128.s(); !(_step128 = _iterator128.n()).done;) {
          var _p9 = _step128.value;
          delete ou.cache[_p9];
        }
      } catch (err) {
        _iterator128.e(err);
      } finally {
        _iterator128.f();
      }
      var f = go(hr(oh(e))),
        d = ui(f);
      return ph.set(e, [f, d, o, c]), [f, e, d, o];
    }
    var t = hr((_ref318 = (_i$config = i === null || i === void 0 ? void 0 : i.config) !== null && _i$config !== void 0 ? _i$config : i) !== null && _ref318 !== void 0 ? _ref318 : {});
    return t = go(t), [t, null, ui(t), []];
  }
  function vo(i) {
    return function (_ref319) {
      var e = _ref319.tailwindDirectives,
        t = _ref319.registerDependency;
      return function (r, n) {
        var _VC = VC(i),
          _VC2 = _slicedToArray(_VC, 4),
          a = _VC2[0],
          s = _VC2[1],
          o = _VC2[2],
          u = _VC2[3],
          c = new Set(u);
        if (e.size > 0) {
          c.add(n.opts.from);
          var _iterator129 = _createForOfIteratorHelper(n.messages),
            _step129;
          try {
            for (_iterator129.s(); !(_step129 = _iterator129.n()).done;) {
              var b = _step129.value;
              b.type === "dependency" && c.add(b.file);
            }
          } catch (err) {
            _iterator129.e(err);
          } finally {
            _iterator129.f();
          }
        }
        var _jd = jd(r, n, a, s, o, c),
          _jd2 = _slicedToArray(_jd, 3),
          f = _jd2[0],
          d = _jd2[2],
          p = On(f),
          m = zC(f, a);
        if (e.size > 0) {
          var _iterator130 = _createForOfIteratorHelper(m),
            _step130;
          try {
            for (_iterator130.s(); !(_step130 = _iterator130.n()).done;) {
              var y = _step130.value;
              var _iterator133 = _createForOfIteratorHelper(po(y)),
                _step133;
              try {
                for (_iterator133.s(); !(_step133 = _iterator133.n()).done;) {
                  var w = _step133.value;
                  t(w);
                }
              } catch (err) {
                _iterator133.e(err);
              } finally {
                _iterator133.f();
              }
            }
          } catch (err) {
            _iterator130.e(err);
          } finally {
            _iterator130.f();
          }
          var _sh = sh(f, m, p),
            _sh2 = _slicedToArray(_sh, 2),
            _b7 = _sh2[0],
            x = _sh2[1];
          var _iterator131 = _createForOfIteratorHelper(_b7),
            _step131;
          try {
            for (_iterator131.s(); !(_step131 = _iterator131.n()).done;) {
              var _y4 = _step131.value;
              f.changedContent.push(_y4);
            }
          } catch (err) {
            _iterator131.e(err);
          } finally {
            _iterator131.f();
          }
          var _iterator132 = _createForOfIteratorHelper(x.entries()),
            _step132;
          try {
            for (_iterator132.s(); !(_step132 = _iterator132.n()).done;) {
              var _step132$value = _slicedToArray(_step132.value, 2),
                _y5 = _step132$value[0],
                _w5 = _step132$value[1];
              d.set(_y5, _w5);
            }
          } catch (err) {
            _iterator132.e(err);
          } finally {
            _iterator132.f();
          }
        }
        var _iterator134 = _createForOfIteratorHelper(u),
          _step134;
        try {
          for (_iterator134.s(); !(_step134 = _iterator134.n()).done;) {
            var _b8 = _step134.value;
            t({
              type: "dependency",
              file: _b8
            });
          }
        } catch (err) {
          _iterator134.e(err);
        } finally {
          _iterator134.f();
        }
        var _iterator135 = _createForOfIteratorHelper(d.entries()),
          _step135;
        try {
          for (_iterator135.s(); !(_step135 = _iterator135.n()).done;) {
            var _step135$value = _slicedToArray(_step135.value, 2),
              _b9 = _step135$value[0],
              _x7 = _step135$value[1];
            p.set(_b9, _x7);
          }
        } catch (err) {
          _iterator135.e(err);
        } finally {
          _iterator135.f();
        }
        return f;
      };
    };
  }
  var ch,
    ph,
    bo,
    dh = C(function () {
      l();
      je();
      ch = X(Qn());
      pu();
      hs();
      tf();
      Xr();
      zd();
      Yd();
      ah();
      lh();
      fh();
      ph = new ch["default"]({
        maxSize: 100
      }), bo = new WeakMap();
    });
  function xo(i) {
    var e = new Set(),
      t = new Set(),
      r = new Set();
    if (i.walkAtRules(function (n) {
      n.name === "apply" && r.add(n), n.name === "import" && (n.params === '"tailwindcss/base"' || n.params === "'tailwindcss/base'" ? (n.name = "tailwind", n.params = "base") : n.params === '"tailwindcss/components"' || n.params === "'tailwindcss/components'" ? (n.name = "tailwind", n.params = "components") : n.params === '"tailwindcss/utilities"' || n.params === "'tailwindcss/utilities'" ? (n.name = "tailwind", n.params = "utilities") : (n.params === '"tailwindcss/screens"' || n.params === "'tailwindcss/screens'" || n.params === '"tailwindcss/variants"' || n.params === "'tailwindcss/variants'") && (n.name = "tailwind", n.params = "variants")), n.name === "tailwind" && (n.params === "screens" && (n.params = "variants"), e.add(n.params)), ["layer", "responsive", "variants"].includes(n.name) && (["responsive", "variants"].includes(n.name) && F.warn("".concat(n.name, "-at-rule-deprecated"), ["The `@".concat(n.name, "` directive has been deprecated in Tailwind CSS v3.0."), "Use `@layer utilities` or `@layer components` instead.", "https://tailwindcss.com/docs/upgrade-guide#replace-variants-with-layer"]), t.add(n));
    }), !e.has("base") || !e.has("components") || !e.has("utilities")) {
      var _iterator136 = _createForOfIteratorHelper(t),
        _step136;
      try {
        for (_iterator136.s(); !(_step136 = _iterator136.n()).done;) {
          var n = _step136.value;
          if (n.name === "layer" && ["base", "components", "utilities"].includes(n.params)) {
            if (!e.has(n.params)) throw n.error("`@layer ".concat(n.params, "` is used but no matching `@tailwind ").concat(n.params, "` directive is present."));
          } else if (n.name === "responsive") {
            if (!e.has("utilities")) throw n.error("`@responsive` is used but `@tailwind utilities` is missing.");
          } else if (n.name === "variants" && !e.has("utilities")) throw n.error("`@variants` is used but `@tailwind utilities` is missing.");
        }
      } catch (err) {
        _iterator136.e(err);
      } finally {
        _iterator136.f();
      }
    }
    return {
      tailwindDirectives: e,
      applyDirectives: r
    };
  }
  var hh = C(function () {
    l();
    Oe();
  });
  function xt(i) {
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : void 0;
    var t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : void 0;
    return i.map(function (r) {
      var n = r.clone();
      return t !== void 0 && (n.raws.tailwind = _objectSpread(_objectSpread({}, n.raws.tailwind), t)), e !== void 0 && mh(n, function (a) {
        var _a$raws$tailwind;
        if (((_a$raws$tailwind = a.raws.tailwind) === null || _a$raws$tailwind === void 0 ? void 0 : _a$raws$tailwind.preserveSource) === !0 && a.source) return !1;
        a.source = e;
      }), n;
    });
  }
  function mh(i, e) {
    var _i$each;
    e(i) !== !1 && ((_i$each = i.each) === null || _i$each === void 0 ? void 0 : _i$each.call(i, function (t) {
      return mh(t, e);
    }));
  }
  var gh = C(function () {
    l();
  });
  function ko(i) {
    return i = Array.isArray(i) ? i : [i], i = i.map(function (e) {
      return e instanceof RegExp ? e.source : e;
    }), i.join("");
  }
  function ye(i) {
    return new RegExp(ko(i), "g");
  }
  function ft(i) {
    return "(?:".concat(i.map(ko).join("|"), ")");
  }
  function So(i) {
    return "(?:".concat(ko(i), ")?");
  }
  function wh(i) {
    return i && UC.test(i) ? i.replace(yh, "\\$&") : i || "";
  }
  var yh,
    UC,
    bh = C(function () {
      l();
      yh = /[\\^$.*+?()[\]{}|]/g, UC = RegExp(yh.source);
    });
  function vh(i) {
    var e = Array.from(WC(i));
    return function (t) {
      var r = [];
      for (var _i20 = 0, _e26 = e; _i20 < _e26.length; _i20++) {
        var _t$match;
        var n = _e26[_i20];
        var _iterator137 = _createForOfIteratorHelper((_t$match = t.match(n)) !== null && _t$match !== void 0 ? _t$match : []),
          _step137;
        try {
          for (_iterator137.s(); !(_step137 = _iterator137.n()).done;) {
            var a = _step137.value;
            r.push(YC(a));
          }
        } catch (err) {
          _iterator137.e(err);
        } finally {
          _iterator137.f();
        }
      }
      return r;
    };
  }
  function WC(i) {
    var e, t, r, n, _i21, _n14, a;
    return _regeneratorRuntime().wrap(function WC$(_context19) {
      while (1) switch (_context19.prev = _context19.next) {
        case 0:
          e = i.tailwindConfig.separator, t = i.tailwindConfig.prefix !== "" ? So(ye([/-?/, wh(i.tailwindConfig.prefix)])) : "", r = ft([/\[[^\s:'"`]+:[^\s\[\]]+\]/, /\[[^\s:'"`\]]+:[^\s]+?\[[^\s]+\][^\s]+?\]/, ye([ft([/-?(?:\w+)/, /@(?:\w+)/]), So(ft([ye([ft([/-(?:\w+-)*\['[^\s]+'\]/, /-(?:\w+-)*\["[^\s]+"\]/, /-(?:\w+-)*\[`[^\s]+`\]/, /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s:\[\]]+\]/]), /(?![{([]])/, /(?:\/[^\s'"`\\><$]*)?/]), ye([ft([/-(?:\w+-)*\['[^\s]+'\]/, /-(?:\w+-)*\["[^\s]+"\]/, /-(?:\w+-)*\[`[^\s]+`\]/, /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s\[\]]+\]/]), /(?![{([]])/, /(?:\/[^\s'"`\\$]*)?/]), /[-\/][^\s'"`\\$={><]*/]))])]), n = [ft([ye([/@\[[^\s"'`]+\](\/[^\s"'`]+)?/, e]), ye([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]\/[\w_-]+/, e]), ye([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/, e]), ye([/[^\s"'`\[\\]+/, e])]), ft([ye([/([^\s"'`\[\\]+-)?\[[^\s`]+\]\/[\w_-]+/, e]), ye([/([^\s"'`\[\\]+-)?\[[^\s`]+\]/, e]), ye([/[^\s`\[\\]+/, e])])];
          _i21 = 0, _n14 = n;
        case 2:
          if (!(_i21 < _n14.length)) {
            _context19.next = 9;
            break;
          }
          a = _n14[_i21];
          _context19.next = 6;
          return ye(["((?=((", a, ")+))\\2)?", /!?/, t, r]);
        case 6:
          _i21++;
          _context19.next = 2;
          break;
        case 9:
          _context19.next = 11;
          return /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
        case 11:
        case "end":
          return _context19.stop();
      }
    }, _marked7);
  }
  function YC(i) {
    if (!i.includes("-[")) return i;
    var e = 0,
      t = [],
      r = i.matchAll(GC);
    r = Array.from(r).flatMap(function (n) {
      var _n15 = _toArray(n),
        a = _n15.slice(1);
      return a.map(function (s, o) {
        return Object.assign([], n, {
          index: n.index + o,
          0: s
        });
      });
    });
    var _iterator138 = _createForOfIteratorHelper(r),
      _step138;
    try {
      for (_iterator138.s(); !(_step138 = _iterator138.n()).done;) {
        var n = _step138.value;
        var a = n[0],
          s = t[t.length - 1];
        if (a === s ? t.pop() : (a === "'" || a === '"' || a === "`") && t.push(a), !s) {
          if (a === "[") {
            e++;
            continue;
          } else if (a === "]") {
            e--;
            continue;
          }
          if (e < 0) return i.substring(0, n.index - 1);
          if (e === 0 && !HC.test(a)) return i.substring(0, n.index);
        }
      }
    } catch (err) {
      _iterator138.e(err);
    } finally {
      _iterator138.f();
    }
    return i;
  }
  var GC,
    HC,
    xh = C(function () {
      l();
      bh();
      GC = /([\[\]'"`])([^\[\]'"`])?/g, HC = /[^"'`\s<>\]]+/;
    });
  function QC(i, e) {
    var t = i.tailwindConfig.content.extract;
    return t[e] || t.DEFAULT || Sh[e] || Sh.DEFAULT(i);
  }
  function JC(i, e) {
    var t = i.content.transform;
    return t[e] || t.DEFAULT || Ch[e] || Ch.DEFAULT;
  }
  function XC(i, e, t, r) {
    ti.has(e) || ti.set(e, new kh["default"]({
      maxSize: 25e3
    }));
    var _iterator139 = _createForOfIteratorHelper(i.split("\n")),
      _step139;
    try {
      for (_iterator139.s(); !(_step139 = _iterator139.n()).done;) {
        var n = _step139.value;
        if (n = n.trim(), !r.has(n)) if (r.add(n), ti.get(e).has(n)) {
          var _iterator140 = _createForOfIteratorHelper(ti.get(e).get(n)),
            _step140;
          try {
            for (_iterator140.s(); !(_step140 = _iterator140.n()).done;) {
              var a = _step140.value;
              t.add(a);
            }
          } catch (err) {
            _iterator140.e(err);
          } finally {
            _iterator140.f();
          }
        } else {
          var _a11 = e(n).filter(function (o) {
              return o !== "!*";
            }),
            s = new Set(_a11);
          var _iterator141 = _createForOfIteratorHelper(s),
            _step141;
          try {
            for (_iterator141.s(); !(_step141 = _iterator141.n()).done;) {
              var o = _step141.value;
              t.add(o);
            }
          } catch (err) {
            _iterator141.e(err);
          } finally {
            _iterator141.f();
          }
          ti.get(e).set(n, s);
        }
      }
    } catch (err) {
      _iterator139.e(err);
    } finally {
      _iterator139.f();
    }
  }
  function KC(i, e) {
    var t = e.offsets.sort(i),
      r = {
        base: new Set(),
        defaults: new Set(),
        components: new Set(),
        utilities: new Set(),
        variants: new Set()
      };
    var _iterator142 = _createForOfIteratorHelper(t),
      _step142;
    try {
      for (_iterator142.s(); !(_step142 = _iterator142.n()).done;) {
        var _step142$value = _slicedToArray(_step142.value, 2),
          n = _step142$value[0],
          a = _step142$value[1];
        r[n.layer].add(a);
      }
    } catch (err) {
      _iterator142.e(err);
    } finally {
      _iterator142.f();
    }
    return r;
  }
  function Co(i) {
    return /*#__PURE__*/function () {
      var _ref320 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(e) {
        var _i$candidates, _e$source$end;
        var t, r, n, a, _iterator143, _step143, _y6, _w6, k, s, y, w, o, u, _i$stylesheetCache, c, f, d, p, m, b, x;
        return _regeneratorRuntime().wrap(function _callee6$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              t = {
                base: null,
                components: null,
                utilities: null,
                variants: null
              };
              if (!(e.walkAtRules(function (y) {
                y.name === "tailwind" && Object.keys(t).includes(y.params) && (t[y.params] = y);
              }), Object.values(t).every(function (y) {
                return y === null;
              }))) {
                _context21.next = 3;
                break;
              }
              return _context21.abrupt("return", e);
            case 3:
              r = new Set([].concat(_toConsumableArray((_i$candidates = i.candidates) !== null && _i$candidates !== void 0 ? _i$candidates : []), [He])), n = new Set();
              Ye.DEBUG && console.time("Reading changed files");
              a = [];
              _iterator143 = _createForOfIteratorHelper(i.changedContent);
              try {
                for (_iterator143.s(); !(_step143 = _iterator143.n()).done;) {
                  _y6 = _step143.value;
                  _w6 = JC(i.tailwindConfig, _y6.extension), k = QC(i, _y6.extension);
                  a.push([_y6, {
                    transformer: _w6,
                    extractor: k
                  }]);
                }
              } catch (err) {
                _iterator143.e(err);
              } finally {
                _iterator143.f();
              }
              s = 500;
              y = 0;
            case 10:
              if (!(y < a.length)) {
                _context21.next = 17;
                break;
              }
              w = a.slice(y, y + s);
              _context21.next = 14;
              return Promise.all(w.map( /*#__PURE__*/function () {
                var _ref322 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_ref321) {
                  var _ref323, _ref323$, k, S, _ref323$2, _, E;
                  return _regeneratorRuntime().wrap(function _callee5$(_context20) {
                    while (1) switch (_context20.prev = _context20.next) {
                      case 0:
                        _ref323 = _slicedToArray(_ref321, 2), _ref323$ = _ref323[0], k = _ref323$.file, S = _ref323$.content, _ref323$2 = _ref323[1], _ = _ref323$2.transformer, E = _ref323$2.extractor;
                        if (!k) {
                          _context20.next = 7;
                          break;
                        }
                        _context20.next = 4;
                        return te.promises.readFile(k, "utf8");
                      case 4:
                        _context20.t0 = _context20.sent;
                        _context20.next = 8;
                        break;
                      case 7:
                        _context20.t0 = S;
                      case 8:
                        S = _context20.t0;
                        XC(_(S), E, r, n);
                      case 10:
                      case "end":
                        return _context20.stop();
                    }
                  }, _callee5);
                }));
                return function (_x9) {
                  return _ref322.apply(this, arguments);
                };
              }()));
            case 14:
              y += s;
              _context21.next = 10;
              break;
            case 17:
              Ye.DEBUG && console.timeEnd("Reading changed files");
              o = i.classCache.size;
              Ye.DEBUG && console.time("Generate rules"), Ye.DEBUG && console.time("Sorting candidates");
              u = new Set(_toConsumableArray(r).sort(function (y, w) {
                return y === w ? 0 : y < w ? -1 : 1;
              }));
              Ye.DEBUG && console.timeEnd("Sorting candidates"), kn(u, i), Ye.DEBUG && console.timeEnd("Generate rules"), Ye.DEBUG && console.time("Build stylesheet"), (i.stylesheetCache === null || i.classCache.size !== o) && (i.stylesheetCache = KC(_toConsumableArray(i.ruleCache), i)), Ye.DEBUG && console.timeEnd("Build stylesheet");
              _i$stylesheetCache = i.stylesheetCache, c = _i$stylesheetCache.defaults, f = _i$stylesheetCache.base, d = _i$stylesheetCache.components, p = _i$stylesheetCache.utilities, m = _i$stylesheetCache.variants;
              t.base && (t.base.before(xt([].concat(_toConsumableArray(f), _toConsumableArray(c)), t.base.source, {
                layer: "base"
              })), t.base.remove()), t.components && (t.components.before(xt(_toConsumableArray(d), t.components.source, {
                layer: "components"
              })), t.components.remove()), t.utilities && (t.utilities.before(xt(_toConsumableArray(p), t.utilities.source, {
                layer: "utilities"
              })), t.utilities.remove());
              b = Array.from(m).filter(function (y) {
                var _y$raws$tailwind;
                var w = (_y$raws$tailwind = y.raws.tailwind) === null || _y$raws$tailwind === void 0 ? void 0 : _y$raws$tailwind.parentLayer;
                return w === "components" ? t.components !== null : w === "utilities" ? t.utilities !== null : !0;
              });
              t.variants ? (t.variants.before(xt(b, t.variants.source, {
                layer: "variants"
              })), t.variants.remove()) : b.length > 0 && e.append(xt(b, e.source, {
                layer: "variants"
              })), e.source.end = (_e$source$end = e.source.end) !== null && _e$source$end !== void 0 ? _e$source$end : e.source.start;
              x = b.some(function (y) {
                var _y$raws$tailwind2;
                return ((_y$raws$tailwind2 = y.raws.tailwind) === null || _y$raws$tailwind2 === void 0 ? void 0 : _y$raws$tailwind2.parentLayer) === "utilities";
              });
              t.utilities && p.size === 0 && !x && F.warn("content-problems", ["No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.", "https://tailwindcss.com/docs/content-configuration"]), Ye.DEBUG && (console.log("Potential classes: ", r.size), console.log("Active contexts: ", gn.size)), i.changedContent = [], e.walkAtRules("layer", function (y) {
                Object.keys(t).includes(y.params) && y.remove();
              });
            case 28:
            case "end":
              return _context21.stop();
          }
        }, _callee6);
      }));
      return function (_x8) {
        return _ref320.apply(this, arguments);
      };
    }();
  }
  var kh,
    Ye,
    Sh,
    Ch,
    ti,
    Ah = C(function () {
      l();
      je();
      kh = X(Qn());
      lt();
      Sn();
      Oe();
      gh();
      xh();
      Ye = Pe, Sh = {
        DEFAULT: vh
      }, Ch = {
        DEFAULT: function DEFAULT(i) {
          return i;
        },
        svelte: function svelte(i) {
          return i.replace(/(?:^|\s)class:/g, " ");
        }
      };
      ti = new WeakMap();
    });
  function Pn(i) {
    var e = new Map();
    z.root({
      nodes: [i.clone()]
    }).walkRules(function (a) {
      (0, Tn["default"])(function (s) {
        s.walkClasses(function (o) {
          var u = o.parent.toString(),
            c = e.get(u);
          c || e.set(u, c = new Set()), c.add(o.value);
        });
      }).processSync(a.selector);
    });
    var r = Array.from(e.values(), function (a) {
        return Array.from(a);
      }),
      n = r.flat();
    return Object.assign(n, {
      groups: r
    });
  }
  function Ao(i) {
    return ZC.astSync(i);
  }
  function _h(i, e) {
    var t = new Set();
    var _iterator144 = _createForOfIteratorHelper(i),
      _step144;
    try {
      for (_iterator144.s(); !(_step144 = _iterator144.n()).done;) {
        var r = _step144.value;
        t.add(r.split(e).pop());
      }
    } catch (err) {
      _iterator144.e(err);
    } finally {
      _iterator144.f();
    }
    return Array.from(t);
  }
  function Oh(i, e) {
    var t = i.tailwindConfig.prefix;
    return typeof t == "function" ? t(e) : t + e;
  }
  function Eh(i) {
    return _regeneratorRuntime().wrap(function Eh$(_context22) {
      while (1) switch (_context22.prev = _context22.next) {
        case 0:
          _context22.next = 2;
          return i;
        case 2:
          if (!i.parent) {
            _context22.next = 8;
            break;
          }
          _context22.next = 5;
          return i.parent;
        case 5:
          i = i.parent;
        case 6:
          _context22.next = 2;
          break;
        case 8:
        case "end":
          return _context22.stop();
      }
    }, _marked8);
  }
  function e2(i) {
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var t = i.nodes;
    i.nodes = [];
    var r = i.clone(e);
    return i.nodes = t, r;
  }
  function t2(i) {
    var _iterator145 = _createForOfIteratorHelper(Eh(i)),
      _step145;
    try {
      for (_iterator145.s(); !(_step145 = _iterator145.n()).done;) {
        var e = _step145.value;
        if (i !== e) {
          if (e.type === "root") break;
          i = e2(e, {
            nodes: [i]
          });
        }
      }
    } catch (err) {
      _iterator145.e(err);
    } finally {
      _iterator145.f();
    }
    return i;
  }
  function r2(i, e) {
    var t = new Map();
    return i.walkRules(function (r) {
      var _iterator146 = _createForOfIteratorHelper(Eh(r)),
        _step146;
      try {
        for (_iterator146.s(); !(_step146 = _iterator146.n()).done;) {
          var _s$raws$tailwind;
          var s = _step146.value;
          if (((_s$raws$tailwind = s.raws.tailwind) === null || _s$raws$tailwind === void 0 ? void 0 : _s$raws$tailwind.layer) !== void 0) return;
        }
      } catch (err) {
        _iterator146.e(err);
      } finally {
        _iterator146.f();
      }
      var n = t2(r),
        a = e.offsets.create("user");
      var _iterator147 = _createForOfIteratorHelper(Pn(r)),
        _step147;
      try {
        for (_iterator147.s(); !(_step147 = _iterator147.n()).done;) {
          var _s16 = _step147.value;
          var o = t.get(_s16) || [];
          t.set(_s16, o), o.push([{
            layer: "user",
            sort: a,
            important: !1
          }, n]);
        }
      } catch (err) {
        _iterator147.e(err);
      } finally {
        _iterator147.f();
      }
    }), t;
  }
  function i2(i, e) {
    var _iterator148 = _createForOfIteratorHelper(i),
      _step148;
    try {
      for (_iterator148.s(); !(_step148 = _iterator148.n()).done;) {
        var t = _step148.value;
        if (e.notClassCache.has(t) || e.applyClassCache.has(t)) continue;
        if (e.classCache.has(t)) {
          e.applyClassCache.set(t, e.classCache.get(t).map(function (_ref324) {
            var _ref325 = _slicedToArray(_ref324, 2),
              n = _ref325[0],
              a = _ref325[1];
            return [n, a.clone()];
          }));
          continue;
        }
        var r = Array.from(io(t, e));
        if (r.length === 0) {
          e.notClassCache.add(t);
          continue;
        }
        e.applyClassCache.set(t, r);
      }
    } catch (err) {
      _iterator148.e(err);
    } finally {
      _iterator148.f();
    }
    return e.applyClassCache;
  }
  function n2(i) {
    var e = null;
    return {
      get: function get(t) {
        return e = e || i(), e.get(t);
      },
      has: function has(t) {
        return e = e || i(), e.has(t);
      }
    };
  }
  function s2(i) {
    return {
      get: function get(e) {
        return i.flatMap(function (t) {
          return t.get(e) || [];
        });
      },
      has: function has(e) {
        return i.some(function (t) {
          return t.has(e);
        });
      }
    };
  }
  function Th(i) {
    var e = i.split(/[\s\t\n]+/g);
    return e[e.length - 1] === "!important" ? [e.slice(0, -1), !0] : [e, !1];
  }
  function Ph(i, e, t) {
    var r = new Set(),
      n = [];
    if (i.walkAtRules("apply", function (u) {
      var _Th = Th(u.params),
        _Th2 = _slicedToArray(_Th, 1),
        c = _Th2[0];
      var _iterator149 = _createForOfIteratorHelper(c),
        _step149;
      try {
        for (_iterator149.s(); !(_step149 = _iterator149.n()).done;) {
          var f = _step149.value;
          r.add(f);
        }
      } catch (err) {
        _iterator149.e(err);
      } finally {
        _iterator149.f();
      }
      n.push(u);
    }), n.length === 0) return;
    var a = s2([t, i2(r, e)]);
    function s(u, c, f) {
      var d = Ao(u),
        p = Ao(c),
        b = Ao(".".concat(ce(f))).nodes[0].nodes[0];
      return d.each(function (x) {
        var y = new Set();
        p.each(function (w) {
          var k = !1;
          w = w.clone(), w.walkClasses(function (S) {
            S.value === b.value && (k || (S.replaceWith.apply(S, _toConsumableArray(x.nodes.map(function (_) {
              return _.clone();
            }))), y.add(w), k = !0));
          });
        });
        var _iterator150 = _createForOfIteratorHelper(y),
          _step150;
        try {
          for (_iterator150.s(); !(_step150 = _iterator150.n()).done;) {
            var w = _step150.value;
            var k = [[]];
            var _iterator151 = _createForOfIteratorHelper(w.nodes),
              _step151;
            try {
              for (_iterator151.s(); !(_step151 = _iterator151.n()).done;) {
                var _S3 = _step151.value;
                _S3.type === "combinator" ? (k.push(_S3), k.push([])) : k[k.length - 1].push(_S3);
              }
            } catch (err) {
              _iterator151.e(err);
            } finally {
              _iterator151.f();
            }
            w.nodes = [];
            for (var _i22 = 0, _k5 = k; _i22 < _k5.length; _i22++) {
              var S = _k5[_i22];
              Array.isArray(S) && S.sort(function (_, E) {
                return _.type === "tag" && E.type === "class" ? -1 : _.type === "class" && E.type === "tag" ? 1 : _.type === "class" && E.type === "pseudo" && E.value.startsWith("::") ? -1 : _.type === "pseudo" && _.value.startsWith("::") && E.type === "class" ? 1 : 0;
              }), w.nodes = w.nodes.concat(S);
            }
          }
        } catch (err) {
          _iterator150.e(err);
        } finally {
          _iterator150.f();
        }
        x.replaceWith.apply(x, _toConsumableArray(y));
      }), d.toString();
    }
    var o = new Map();
    var _loop20 = function _loop20() {
      var u = _n16[_i23];
      var _ref326 = o.get(u.parent) || [[], u.source],
        _ref327 = _slicedToArray(_ref326, 1),
        c = _ref327[0];
      o.set(u.parent, [c, u.source]);
      var _Th3 = Th(u.params),
        _Th4 = _slicedToArray(_Th3, 2),
        f = _Th4[0],
        d = _Th4[1];
      if (u.parent.type === "atrule") {
        if (u.parent.name === "screen") {
          var p = u.parent.params;
          throw u.error("@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ".concat(f.map(function (m) {
            return "".concat(p, ":").concat(m);
          }).join(" "), " instead."));
        }
        throw u.error("@apply is not supported within nested at-rules like @".concat(u.parent.name, ". You can fix this by un-nesting @").concat(u.parent.name, "."));
      }
      var _iterator152 = _createForOfIteratorHelper(f),
        _step152;
      try {
        var _loop21 = function _loop21() {
          var p = _step152.value;
          if ([Oh(e, "group"), Oh(e, "peer")].includes(p)) throw u.error("@apply should not be used with the '".concat(p, "' utility"));
          if (!a.has(p)) throw u.error("The `".concat(p, "` class does not exist. If `").concat(p, "` is a custom class, make sure it is defined within a `@layer` directive."));
          var m = a.get(p);
          var _iterator153 = _createForOfIteratorHelper(m),
            _step153;
          try {
            for (_iterator153.s(); !(_step153 = _iterator153.n()).done;) {
              var _step153$value = _slicedToArray(_step153.value, 2),
                b = _step153$value[1];
              b.type !== "atrule" && b.walkRules(function () {
                throw u.error(["The `".concat(p, "` class cannot be used with `@apply` because `@apply` does not currently support nested CSS."), "Rewrite the selector without nesting or configure the `tailwindcss/nesting` plugin:", "https://tailwindcss.com/docs/using-with-preprocessors#nesting"].join("\n"));
              });
            }
          } catch (err) {
            _iterator153.e(err);
          } finally {
            _iterator153.f();
          }
          c.push([p, d, m]);
        };
        for (_iterator152.s(); !(_step152 = _iterator152.n()).done;) {
          _loop21();
        }
      } catch (err) {
        _iterator152.e(err);
      } finally {
        _iterator152.f();
      }
    };
    for (var _i23 = 0, _n16 = n; _i23 < _n16.length; _i23++) {
      _loop20();
    }
    var _iterator154 = _createForOfIteratorHelper(o),
      _step154;
    try {
      var _loop22 = function _loop22() {
        var _step154$value = _slicedToArray(_step154.value, 2),
          u = _step154$value[0],
          _step154$value$ = _slicedToArray(_step154$value[1], 2),
          c = _step154$value$[0],
          f = _step154$value$[1];
        var d = [];
        var _iterator155 = _createForOfIteratorHelper(c),
          _step155;
        try {
          var _loop23 = function _loop23() {
            var _step155$value = _slicedToArray(_step155.value, 3),
              m = _step155$value[0],
              b = _step155$value[1],
              x = _step155$value[2];
            var y = [m].concat(_toConsumableArray(_h([m], e.tailwindConfig.separator)));
            var _iterator156 = _createForOfIteratorHelper(x),
              _step156;
            try {
              var _loop24 = function _loop24() {
                var _step156$value = _slicedToArray(_step156.value, 2),
                  w = _step156$value[0],
                  k = _step156$value[1];
                var S = Pn(u),
                  _ = Pn(k);
                if (_ = _.groups.filter(function (R) {
                  return R.some(function (J) {
                    return y.includes(J);
                  });
                }).flat(), _ = _.concat(_h(_, e.tailwindConfig.separator)), S.some(function (R) {
                  return _.includes(R);
                })) throw k.error("You cannot `@apply` the `".concat(m, "` utility here because it creates a circular dependency."));
                var I = z.root({
                  nodes: [k.clone()]
                });
                I.walk(function (R) {
                  R.source = f;
                }), (k.type !== "atrule" || k.type === "atrule" && k.name !== "keyframes") && I.walkRules(function (R) {
                  if (!Pn(R).some(function (ee) {
                    return ee === m;
                  })) {
                    R.remove();
                    return;
                  }
                  var J = typeof e.tailwindConfig.important == "string" ? e.tailwindConfig.important : null,
                    de = u.raws.tailwind !== void 0 && J && u.selector.indexOf(J) === 0 ? u.selector.slice(J.length) : u.selector;
                  de === "" && (de = u.selector), R.selector = s(de, R.selector, m), J && de !== u.selector && (R.selector = bn(R.selector, J)), R.walkDecls(function (ee) {
                    ee.important = w.important || b;
                  });
                  var De = (0, Tn["default"])().astSync(R.selector);
                  De.each(function (ee) {
                    return $t(ee);
                  }), R.selector = De.toString();
                }), !!I.nodes[0] && d.push([w.sort, I.nodes[0]]);
              };
              for (_iterator156.s(); !(_step156 = _iterator156.n()).done;) {
                _loop24();
              }
            } catch (err) {
              _iterator156.e(err);
            } finally {
              _iterator156.f();
            }
          };
          for (_iterator155.s(); !(_step155 = _iterator155.n()).done;) {
            _loop23();
          }
        } catch (err) {
          _iterator155.e(err);
        } finally {
          _iterator155.f();
        }
        var p = e.offsets.sort(d).map(function (m) {
          return m[1];
        });
        u.after(p);
      };
      for (_iterator154.s(); !(_step154 = _iterator154.n()).done;) {
        _loop22();
      }
    } catch (err) {
      _iterator154.e(err);
    } finally {
      _iterator154.f();
    }
    for (var _i24 = 0, _n17 = n; _i24 < _n17.length; _i24++) {
      var _u8 = _n17[_i24];
      _u8.parent.nodes.length > 1 ? _u8.remove() : _u8.parent.remove();
    }
    Ph(i, e, t);
  }
  function _o(i) {
    return function (e) {
      var t = n2(function () {
        return r2(e, i);
      });
      Ph(e, i, t);
    };
  }
  var Tn,
    ZC,
    Dh = C(function () {
      l();
      nt();
      Tn = X(Me());
      Sn();
      Nt();
      eo();
      yn();
      ZC = (0, Tn["default"])();
    });
  var Ih = v(function (lD, Dn) {
    l();
    (function () {
      "use strict";

      function i(r, n, a) {
        if (!r) return null;
        i.caseSensitive || (r = r.toLowerCase());
        var s = i.threshold === null ? null : i.threshold * r.length,
          o = i.thresholdAbsolute,
          u;
        s !== null && o !== null ? u = Math.min(s, o) : s !== null ? u = s : o !== null ? u = o : u = null;
        var c,
          f,
          d,
          p,
          m,
          b = n.length;
        for (m = 0; m < b; m++) if (f = n[m], a && (f = f[a]), !!f && (i.caseSensitive ? d = f : d = f.toLowerCase(), p = t(r, d, u), (u === null || p < u) && (u = p, a && i.returnWinningObject ? c = n[m] : c = f, i.returnFirstMatch))) return c;
        return c || i.nullResultValue;
      }
      i.threshold = .4, i.thresholdAbsolute = 20, i.caseSensitive = !1, i.nullResultValue = null, i.returnWinningObject = null, i.returnFirstMatch = !1, typeof Dn != "undefined" && Dn.exports ? Dn.exports = i : window.didYouMean = i;
      var e = Math.pow(2, 32) - 1;
      function t(r, n, a) {
        a = a || a === 0 ? a : e;
        var s = r.length,
          o = n.length;
        if (s === 0) return Math.min(a + 1, o);
        if (o === 0) return Math.min(a + 1, s);
        if (Math.abs(s - o) > a) return a + 1;
        var u = [],
          c,
          f,
          d,
          p,
          m;
        for (c = 0; c <= o; c++) u[c] = [c];
        for (f = 0; f <= s; f++) u[0][f] = f;
        for (c = 1; c <= o; c++) {
          for (d = e, p = 1, c > a && (p = c - a), m = o + 1, m > a + c && (m = a + c), f = 1; f <= s; f++) f < p || f > m ? u[c][f] = a + 1 : n.charAt(c - 1) === r.charAt(f - 1) ? u[c][f] = u[c - 1][f - 1] : u[c][f] = Math.min(u[c - 1][f - 1] + 1, Math.min(u[c][f - 1] + 1, u[c - 1][f] + 1)), u[c][f] < d && (d = u[c][f]);
          if (d > a) return a + 1;
        }
        return u[o][s];
      }
    })();
  });
  var Rh = v(function (uD, qh) {
    l();
    var Oo = "(".charCodeAt(0),
      Eo = ")".charCodeAt(0),
      In = "'".charCodeAt(0),
      To = '"'.charCodeAt(0),
      Po = "\\".charCodeAt(0),
      Vt = "/".charCodeAt(0),
      Do = ",".charCodeAt(0),
      Io = ":".charCodeAt(0),
      qn = "*".charCodeAt(0),
      a2 = "u".charCodeAt(0),
      o2 = "U".charCodeAt(0),
      l2 = "+".charCodeAt(0),
      u2 = /^[a-f0-9?-]+$/i;
    qh.exports = function (i) {
      for (var e = [], t = i, r, n, a, s, o, u, c, f, d = 0, p = t.charCodeAt(d), m = t.length, b = [{
          nodes: e
        }], x = 0, y, w = "", k = "", S = ""; d < m;) if (p <= 32) {
        r = d;
        do r += 1, p = t.charCodeAt(r); while (p <= 32);
        s = t.slice(d, r), a = e[e.length - 1], p === Eo && x ? S = s : a && a.type === "div" ? (a.after = s, a.sourceEndIndex += s.length) : p === Do || p === Io || p === Vt && t.charCodeAt(r + 1) !== qn && (!y || y && y.type === "function" && !1) ? k = s : e.push({
          type: "space",
          sourceIndex: d,
          sourceEndIndex: r,
          value: s
        }), d = r;
      } else if (p === In || p === To) {
        r = d, n = p === In ? "'" : '"', s = {
          type: "string",
          sourceIndex: d,
          quote: n
        };
        do if (o = !1, r = t.indexOf(n, r + 1), ~r) for (u = r; t.charCodeAt(u - 1) === Po;) u -= 1, o = !o;else t += n, r = t.length - 1, s.unclosed = !0; while (o);
        s.value = t.slice(d + 1, r), s.sourceEndIndex = s.unclosed ? r : r + 1, e.push(s), d = r + 1, p = t.charCodeAt(d);
      } else if (p === Vt && t.charCodeAt(d + 1) === qn) r = t.indexOf("*/", d), s = {
        type: "comment",
        sourceIndex: d,
        sourceEndIndex: r + 2
      }, r === -1 && (s.unclosed = !0, r = t.length, s.sourceEndIndex = r), s.value = t.slice(d + 2, r), e.push(s), d = r + 2, p = t.charCodeAt(d);else if ((p === Vt || p === qn) && y && y.type === "function") s = t[d], e.push({
        type: "word",
        sourceIndex: d - k.length,
        sourceEndIndex: d + s.length,
        value: s
      }), d += 1, p = t.charCodeAt(d);else if (p === Vt || p === Do || p === Io) s = t[d], e.push({
        type: "div",
        sourceIndex: d - k.length,
        sourceEndIndex: d + s.length,
        value: s,
        before: k,
        after: ""
      }), k = "", d += 1, p = t.charCodeAt(d);else if (Oo === p) {
        r = d;
        do r += 1, p = t.charCodeAt(r); while (p <= 32);
        if (f = d, s = {
          type: "function",
          sourceIndex: d - w.length,
          value: w,
          before: t.slice(f + 1, r)
        }, d = r, w === "url" && p !== In && p !== To) {
          r -= 1;
          do if (o = !1, r = t.indexOf(")", r + 1), ~r) for (u = r; t.charCodeAt(u - 1) === Po;) u -= 1, o = !o;else t += ")", r = t.length - 1, s.unclosed = !0; while (o);
          c = r;
          do c -= 1, p = t.charCodeAt(c); while (p <= 32);
          f < c ? (d !== c + 1 ? s.nodes = [{
            type: "word",
            sourceIndex: d,
            sourceEndIndex: c + 1,
            value: t.slice(d, c + 1)
          }] : s.nodes = [], s.unclosed && c + 1 !== r ? (s.after = "", s.nodes.push({
            type: "space",
            sourceIndex: c + 1,
            sourceEndIndex: r,
            value: t.slice(c + 1, r)
          })) : (s.after = t.slice(c + 1, r), s.sourceEndIndex = r)) : (s.after = "", s.nodes = []), d = r + 1, s.sourceEndIndex = s.unclosed ? r : d, p = t.charCodeAt(d), e.push(s);
        } else x += 1, s.after = "", s.sourceEndIndex = d + 1, e.push(s), b.push(s), e = s.nodes = [], y = s;
        w = "";
      } else if (Eo === p && x) d += 1, p = t.charCodeAt(d), y.after = S, y.sourceEndIndex += S.length, S = "", x -= 1, b[b.length - 1].sourceEndIndex = d, b.pop(), y = b[x], e = y.nodes;else {
        r = d;
        do p === Po && (r += 1), r += 1, p = t.charCodeAt(r); while (r < m && !(p <= 32 || p === In || p === To || p === Do || p === Io || p === Vt || p === Oo || p === qn && y && y.type === "function" && !0 || p === Vt && y.type === "function" && !0 || p === Eo && x));
        s = t.slice(d, r), Oo === p ? w = s : (a2 === s.charCodeAt(0) || o2 === s.charCodeAt(0)) && l2 === s.charCodeAt(1) && u2.test(s.slice(2)) ? e.push({
          type: "unicode-range",
          sourceIndex: d,
          sourceEndIndex: r,
          value: s
        }) : e.push({
          type: "word",
          sourceIndex: d,
          sourceEndIndex: r,
          value: s
        }), d = r;
      }
      for (d = b.length - 1; d; d -= 1) b[d].unclosed = !0, b[d].sourceEndIndex = t.length;
      return b[0].nodes;
    };
  });
  var Bh = v(function (fD, Mh) {
    l();
    Mh.exports = function i(e, t, r) {
      var n, a, s, o;
      for (n = 0, a = e.length; n < a; n += 1) s = e[n], r || (o = t(s, n, e)), o !== !1 && s.type === "function" && Array.isArray(s.nodes) && i(s.nodes, t, r), r && t(s, n, e);
    };
  });
  var $h = v(function (cD, Lh) {
    l();
    function Fh(i, e) {
      var t = i.type,
        r = i.value,
        n,
        a;
      return e && (a = e(i)) !== void 0 ? a : t === "word" || t === "space" ? r : t === "string" ? (n = i.quote || "", n + r + (i.unclosed ? "" : n)) : t === "comment" ? "/*" + r + (i.unclosed ? "" : "*/") : t === "div" ? (i.before || "") + r + (i.after || "") : Array.isArray(i.nodes) ? (n = Nh(i.nodes, e), t !== "function" ? n : r + "(" + (i.before || "") + n + (i.after || "") + (i.unclosed ? "" : ")")) : r;
    }
    function Nh(i, e) {
      var t, r;
      if (Array.isArray(i)) {
        for (t = "", r = i.length - 1; ~r; r -= 1) t = Fh(i[r], e) + t;
        return t;
      }
      return Fh(i, e);
    }
    Lh.exports = Nh;
  });
  var zh = v(function (pD, jh) {
    l();
    var Rn = "-".charCodeAt(0),
      Mn = "+".charCodeAt(0),
      qo = ".".charCodeAt(0),
      f2 = "e".charCodeAt(0),
      c2 = "E".charCodeAt(0);
    function p2(i) {
      var e = i.charCodeAt(0),
        t;
      if (e === Mn || e === Rn) {
        if (t = i.charCodeAt(1), t >= 48 && t <= 57) return !0;
        var r = i.charCodeAt(2);
        return t === qo && r >= 48 && r <= 57;
      }
      return e === qo ? (t = i.charCodeAt(1), t >= 48 && t <= 57) : e >= 48 && e <= 57;
    }
    jh.exports = function (i) {
      var e = 0,
        t = i.length,
        r,
        n,
        a;
      if (t === 0 || !p2(i)) return !1;
      for (r = i.charCodeAt(e), (r === Mn || r === Rn) && e++; e < t && (r = i.charCodeAt(e), !(r < 48 || r > 57));) e += 1;
      if (r = i.charCodeAt(e), n = i.charCodeAt(e + 1), r === qo && n >= 48 && n <= 57) for (e += 2; e < t && (r = i.charCodeAt(e), !(r < 48 || r > 57));) e += 1;
      if (r = i.charCodeAt(e), n = i.charCodeAt(e + 1), a = i.charCodeAt(e + 2), (r === f2 || r === c2) && (n >= 48 && n <= 57 || (n === Mn || n === Rn) && a >= 48 && a <= 57)) for (e += n === Mn || n === Rn ? 3 : 2; e < t && (r = i.charCodeAt(e), !(r < 48 || r > 57));) e += 1;
      return {
        number: i.slice(0, e),
        unit: i.slice(e)
      };
    };
  });
  var Gh = v(function (dD, Wh) {
    l();
    var d2 = Rh(),
      Vh = Bh(),
      Uh = $h();
    function ct(i) {
      return this instanceof ct ? (this.nodes = d2(i), this) : new ct(i);
    }
    ct.prototype.toString = function () {
      return Array.isArray(this.nodes) ? Uh(this.nodes) : "";
    };
    ct.prototype.walk = function (i, e) {
      return Vh(this.nodes, i, e), this;
    };
    ct.unit = zh();
    ct.walk = Vh;
    ct.stringify = Uh;
    Wh.exports = ct;
  });
  function Mo(i) {
    return _typeof(i) == "object" && i !== null;
  }
  function h2(i, e) {
    var t = Ke(e);
    do if (t.pop(), (0, ri["default"])(i, t) !== void 0) break; while (t.length);
    return t.length ? t : void 0;
  }
  function Ut(i) {
    return typeof i == "string" ? i : i.reduce(function (e, t, r) {
      return t.includes(".") ? "".concat(e, "[").concat(t, "]") : r === 0 ? t : "".concat(e, ".").concat(t);
    }, "");
  }
  function Yh(i) {
    return i.map(function (e) {
      return "'".concat(e, "'");
    }).join(", ");
  }
  function Qh(i) {
    return Yh(Object.keys(i));
  }
  function Bo(i, e, t) {
    var r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var n = Array.isArray(e) ? Ut(e) : e.replace(/^['"]+|['"]+$/g, ""),
      a = Array.isArray(e) ? e : Ke(n),
      s = (0, ri["default"])(i.theme, a, t);
    if (s === void 0) {
      var _u9 = "'".concat(n, "' does not exist in your theme config."),
        c = a.slice(0, -1),
        f = (0, ri["default"])(i.theme, c);
      if (Mo(f)) {
        var d = Object.keys(f).filter(function (m) {
            return Bo(i, [].concat(_toConsumableArray(c), [m])).isValid;
          }),
          p = (0, Hh["default"])(a[a.length - 1], d);
        p ? _u9 += " Did you mean '".concat(Ut([].concat(_toConsumableArray(c), [p])), "'?") : d.length > 0 && (_u9 += " '".concat(Ut(c), "' has the following valid keys: ").concat(Yh(d)));
      } else {
        var _d6 = h2(i.theme, n);
        if (_d6) {
          var _p10 = (0, ri["default"])(i.theme, _d6);
          Mo(_p10) ? _u9 += " '".concat(Ut(_d6), "' has the following keys: ").concat(Qh(_p10)) : _u9 += " '".concat(Ut(_d6), "' is not an object.");
        } else _u9 += " Your theme has the following top-level keys: ".concat(Qh(i.theme));
      }
      return {
        isValid: !1,
        error: _u9
      };
    }
    if (!(typeof s == "string" || typeof s == "number" || typeof s == "function" || s instanceof String || s instanceof Number || Array.isArray(s))) {
      var _u10 = "'".concat(n, "' was found but does not resolve to a string.");
      if (Mo(s)) {
        var _c5 = Object.keys(s).filter(function (f) {
          return Bo(i, [].concat(_toConsumableArray(a), [f])).isValid;
        });
        _c5.length && (_u10 += " Did you mean something like '".concat(Ut([].concat(_toConsumableArray(a), [_c5[0]])), "'?"));
      }
      return {
        isValid: !1,
        error: _u10
      };
    }
    var _a12 = _slicedToArray(a, 1),
      o = _a12[0];
    return {
      isValid: !0,
      value: Ge(o)(s, r)
    };
  }
  function m2(i, e, t) {
    e = e.map(function (n) {
      return Jh(i, n, t);
    });
    var r = [""];
    var _iterator157 = _createForOfIteratorHelper(e),
      _step157;
    try {
      for (_iterator157.s(); !(_step157 = _iterator157.n()).done;) {
        var n = _step157.value;
        n.type === "div" && n.value === "," ? r.push("") : r[r.length - 1] += Ro["default"].stringify(n);
      }
    } catch (err) {
      _iterator157.e(err);
    } finally {
      _iterator157.f();
    }
    return r;
  }
  function Jh(i, e, t) {
    if (e.type === "function" && t[e.value] !== void 0) {
      var r = m2(i, e.nodes, t);
      e.type = "word", e.value = t[e.value].apply(t, [i].concat(_toConsumableArray(r)));
    }
    return e;
  }
  function g2(i, e, t) {
    return Object.keys(t).some(function (n) {
      return e.includes("".concat(n, "("));
    }) ? (0, Ro["default"])(e).walk(function (n) {
      Jh(i, n, t);
    }).toString() : e;
  }
  function w2(i) {
    var e, t;
    return _regeneratorRuntime().wrap(function w2$(_context23) {
      while (1) switch (_context23.prev = _context23.next) {
        case 0:
          i = i.replace(/^['"]+|['"]+$/g, "");
          e = i.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/);
          _context23.next = 4;
          return [i, void 0];
        case 4:
          _context23.t0 = e;
          if (!_context23.t0) {
            _context23.next = 10;
            break;
          }
          i = e[1];
          t = e[2];
          _context23.next = 10;
          return [i, t];
        case 10:
        case "end":
          return _context23.stop();
      }
    }, _marked9);
  }
  function b2(i, e, t) {
    var _r$find;
    var r = Array.from(w2(e)).map(function (_ref328) {
      var _ref329 = _slicedToArray(_ref328, 2),
        n = _ref329[0],
        a = _ref329[1];
      return Object.assign(Bo(i, n, t, {
        opacityValue: a
      }), {
        resolvedPath: n,
        alpha: a
      });
    });
    return (_r$find = r.find(function (n) {
      return n.isValid;
    })) !== null && _r$find !== void 0 ? _r$find : r[0];
  }
  function Xh(i) {
    var e = i.tailwindConfig,
      t = {
        theme: function theme(r, n) {
          for (var _len13 = arguments.length, a = new Array(_len13 > 2 ? _len13 - 2 : 0), _key13 = 2; _key13 < _len13; _key13++) {
            a[_key13 - 2] = arguments[_key13];
          }
          var _b10 = b2(e, n, a.length ? a : void 0),
            s = _b10.isValid,
            o = _b10.value,
            u = _b10.error,
            c = _b10.alpha;
          if (!s) {
            var _p$raws$tailwind;
            var p = r.parent,
              m = p === null || p === void 0 || (_p$raws$tailwind = p.raws.tailwind) === null || _p$raws$tailwind === void 0 ? void 0 : _p$raws$tailwind.candidate;
            if (p && m !== void 0) {
              i.markInvalidUtilityNode(p), p.remove(), F.warn("invalid-theme-key-in-class", ["The utility `".concat(m, "` contains an invalid theme value and was not generated.")]);
              return;
            }
            throw r.error(u);
          }
          var f = At(o),
            d = f !== void 0 && typeof f == "function";
          return (c !== void 0 || d) && (c === void 0 && (c = 1), o = Ie(f, c, f)), o;
        },
        screen: function screen(r, n) {
          n = n.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
          var s = at(e.theme.screens).find(function (_ref330) {
            var o = _ref330.name;
            return o === n;
          });
          if (!s) throw r.error("The '".concat(n, "' screen does not exist in your theme."));
          return st(s);
        }
      };
    return function (r) {
      r.walk(function (n) {
        var a = y2[n.type];
        a !== void 0 && (n[a] = g2(n, n[a], t));
      });
    };
  }
  var ri,
    Hh,
    Ro,
    y2,
    Kh = C(function () {
      l();
      ri = X(Ls()), Hh = X(Ih());
      Yr();
      Ro = X(Gh());
      hn();
      cn();
      pi();
      lr();
      pr();
      Oe();
      y2 = {
        atrule: "params",
        decl: "value"
      };
    });
  function Zh(_ref331) {
    var i = _ref331.tailwindConfig.theme;
    return function (e) {
      e.walkAtRules("screen", function (t) {
        var r = t.params,
          a = at(i.screens).find(function (_ref332) {
            var s = _ref332.name;
            return s === r;
          });
        if (!a) throw t.error("No `".concat(r, "` screen found."));
        t.name = "media", t.params = st(a);
      });
    };
  }
  var em = C(function () {
    l();
    hn();
    cn();
  });
  function v2(i) {
    var e = i.filter(function (o) {
        return o.type !== "pseudo" || o.nodes.length > 0 ? !0 : o.value.startsWith("::") || [":before", ":after", ":first-line", ":first-letter"].includes(o.value);
      }).reverse(),
      t = new Set(["tag", "class", "id", "attribute"]),
      r = e.findIndex(function (o) {
        return t.has(o.type);
      });
    if (r === -1) return e.reverse().join("").trim();
    var n = e[r],
      a = tm[n.type] ? tm[n.type](n) : n;
    e = e.slice(0, r);
    var s = e.findIndex(function (o) {
      return o.type === "combinator" && o.value === ">";
    });
    return s !== -1 && (e.splice(0, s), e.unshift(Bn["default"].universal())), [a].concat(_toConsumableArray(e.reverse())).join("").trim();
  }
  function k2(i) {
    return Fo.has(i) || Fo.set(i, x2.transformSync(i)), Fo.get(i);
  }
  function No(_ref333) {
    var i = _ref333.tailwindConfig;
    return function (e) {
      var t = new Map(),
        r = new Set();
      if (e.walkAtRules("defaults", function (n) {
        if (n.nodes && n.nodes.length > 0) {
          r.add(n);
          return;
        }
        var a = n.params;
        t.has(a) || t.set(a, new Set()), t.get(a).add(n.parent), n.remove();
      }), K(i, "optimizeUniversalDefaults")) {
        var _iterator158 = _createForOfIteratorHelper(r),
          _step158;
        try {
          for (_iterator158.s(); !(_step158 = _iterator158.n()).done;) {
            var _t$get;
            var n = _step158.value;
            var a = new Map(),
              s = (_t$get = t.get(n.params)) !== null && _t$get !== void 0 ? _t$get : [];
            var _iterator159 = _createForOfIteratorHelper(s),
              _step159;
            try {
              for (_iterator159.s(); !(_step159 = _iterator159.n()).done;) {
                var _o8 = _step159.value;
                var _iterator161 = _createForOfIteratorHelper(k2(_o8.selector)),
                  _step161;
                try {
                  for (_iterator161.s(); !(_step161 = _iterator161.n()).done;) {
                    var _a$get;
                    var _u12 = _step161.value;
                    var c = _u12.includes(":-") || _u12.includes("::-") || _u12.includes(":has") ? _u12 : "__DEFAULT__",
                      f = (_a$get = a.get(c)) !== null && _a$get !== void 0 ? _a$get : new Set();
                    a.set(c, f), f.add(_u12);
                  }
                } catch (err) {
                  _iterator161.e(err);
                } finally {
                  _iterator161.f();
                }
              }
            } catch (err) {
              _iterator159.e(err);
            } finally {
              _iterator159.f();
            }
            if (K(i, "optimizeUniversalDefaults")) {
              if (a.size === 0) {
                n.remove();
                continue;
              }
              var _iterator160 = _createForOfIteratorHelper(a),
                _step160;
              try {
                for (_iterator160.s(); !(_step160 = _iterator160.n()).done;) {
                  var _step160$value = _slicedToArray(_step160.value, 2),
                    o = _step160$value[1];
                  var _u11 = z.rule({
                    source: n.source
                  });
                  _u11.selectors = _toConsumableArray(o), _u11.append(n.nodes.map(function (c) {
                    return c.clone();
                  })), n.before(_u11);
                }
              } catch (err) {
                _iterator160.e(err);
              } finally {
                _iterator160.f();
              }
            }
            n.remove();
          }
        } catch (err) {
          _iterator158.e(err);
        } finally {
          _iterator158.f();
        }
      } else if (r.size) {
        var _n18 = z.rule({
          selectors: ["*", "::before", "::after"]
        });
        var _iterator162 = _createForOfIteratorHelper(r),
          _step162;
        try {
          for (_iterator162.s(); !(_step162 = _iterator162.n()).done;) {
            var _s17 = _step162.value;
            _n18.append(_s17.nodes), _n18.parent || _s17.before(_n18), _n18.source || (_n18.source = _s17.source), _s17.remove();
          }
        } catch (err) {
          _iterator162.e(err);
        } finally {
          _iterator162.f();
        }
        var _a13 = _n18.clone({
          selectors: ["::backdrop"]
        });
        _n18.after(_a13);
      }
    };
  }
  var Bn,
    tm,
    x2,
    Fo,
    rm = C(function () {
      l();
      nt();
      Bn = X(Me());
      ze();
      tm = {
        id: function id(i) {
          return Bn["default"].attribute({
            attribute: "id",
            operator: "=",
            value: i.value,
            quoteMark: '"'
          });
        }
      };
      x2 = (0, Bn["default"])(function (i) {
        return i.map(function (e) {
          var t = e.split(function (r) {
            return r.type === "combinator" && r.value === " ";
          }).pop();
          return v2(t);
        });
      }), Fo = new Map();
    });
  function Lo() {
    function i(e) {
      var t = null;
      e.each(function (r) {
        if (!S2.has(r.type)) {
          t = null;
          return;
        }
        if (t === null) {
          t = r;
          return;
        }
        var n = im[r.type];
        r.type === "atrule" && r.name === "font-face" ? t = r : n.every(function (a) {
          var _r$a, _t$a;
          return ((_r$a = r[a]) !== null && _r$a !== void 0 ? _r$a : "").replace(/\s+/g, " ") === ((_t$a = t[a]) !== null && _t$a !== void 0 ? _t$a : "").replace(/\s+/g, " ");
        }) ? (r.nodes && t.append(r.nodes), r.remove()) : t = r;
      }), e.each(function (r) {
        r.type === "atrule" && i(r);
      });
    }
    return function (e) {
      i(e);
    };
  }
  var im,
    S2,
    nm = C(function () {
      l();
      im = {
        atrule: ["name", "params"],
        rule: ["selector"]
      }, S2 = new Set(Object.keys(im));
    });
  function $o() {
    return function (i) {
      i.walkRules(function (e) {
        var t = new Map(),
          r = new Set([]),
          n = new Map();
        e.walkDecls(function (a) {
          if (a.parent === e) {
            if (t.has(a.prop)) {
              if (t.get(a.prop).value === a.value) {
                r.add(t.get(a.prop)), t.set(a.prop, a);
                return;
              }
              n.has(a.prop) || n.set(a.prop, new Set()), n.get(a.prop).add(t.get(a.prop)), n.get(a.prop).add(a);
            }
            t.set(a.prop, a);
          }
        });
        var _iterator163 = _createForOfIteratorHelper(r),
          _step163;
        try {
          for (_iterator163.s(); !(_step163 = _iterator163.n()).done;) {
            var a = _step163.value;
            a.remove();
          }
        } catch (err) {
          _iterator163.e(err);
        } finally {
          _iterator163.f();
        }
        var _iterator164 = _createForOfIteratorHelper(n.values()),
          _step164;
        try {
          for (_iterator164.s(); !(_step164 = _iterator164.n()).done;) {
            var _a14 = _step164.value;
            var s = new Map();
            var _iterator165 = _createForOfIteratorHelper(_a14),
              _step165;
            try {
              for (_iterator165.s(); !(_step165 = _iterator165.n()).done;) {
                var o = _step165.value;
                var _u13 = A2(o.value);
                _u13 !== null && (s.has(_u13) || s.set(_u13, new Set()), s.get(_u13).add(o));
              }
            } catch (err) {
              _iterator165.e(err);
            } finally {
              _iterator165.f();
            }
            var _iterator166 = _createForOfIteratorHelper(s.values()),
              _step166;
            try {
              for (_iterator166.s(); !(_step166 = _iterator166.n()).done;) {
                var _o9 = _step166.value;
                var _u14 = Array.from(_o9).slice(0, -1);
                var _iterator167 = _createForOfIteratorHelper(_u14),
                  _step167;
                try {
                  for (_iterator167.s(); !(_step167 = _iterator167.n()).done;) {
                    var c = _step167.value;
                    c.remove();
                  }
                } catch (err) {
                  _iterator167.e(err);
                } finally {
                  _iterator167.f();
                }
              }
            } catch (err) {
              _iterator166.e(err);
            } finally {
              _iterator166.f();
            }
          }
        } catch (err) {
          _iterator164.e(err);
        } finally {
          _iterator164.f();
        }
      });
    };
  }
  function A2(i) {
    var _e$;
    var e = /^-?\d*.?\d+([\w%]+)?$/g.exec(i);
    return e ? (_e$ = e[1]) !== null && _e$ !== void 0 ? _e$ : C2 : null;
  }
  var C2,
    sm = C(function () {
      l();
      C2 = Symbol("unitless-number");
    });
  function _2(i) {
    if (!i.walkAtRules) return;
    var e = new Set();
    if (i.walkAtRules("apply", function (t) {
      e.add(t.parent);
    }), e.size !== 0) {
      var _iterator168 = _createForOfIteratorHelper(e),
        _step168;
      try {
        for (_iterator168.s(); !(_step168 = _iterator168.n()).done;) {
          var t = _step168.value;
          var r = [],
            n = [];
          var _iterator169 = _createForOfIteratorHelper(t.nodes),
            _step169;
          try {
            for (_iterator169.s(); !(_step169 = _iterator169.n()).done;) {
              var _a15 = _step169.value;
              _a15.type === "atrule" && _a15.name === "apply" ? (n.length > 0 && (r.push(n), n = []), r.push([_a15])) : n.push(_a15);
            }
          } catch (err) {
            _iterator169.e(err);
          } finally {
            _iterator169.f();
          }
          if (n.length > 0 && r.push(n), r.length !== 1) {
            var _iterator170 = _createForOfIteratorHelper([].concat(r).reverse()),
              _step170;
            try {
              for (_iterator170.s(); !(_step170 = _iterator170.n()).done;) {
                var a = _step170.value;
                var s = t.clone({
                  nodes: []
                });
                s.append(a), t.after(s);
              }
            } catch (err) {
              _iterator170.e(err);
            } finally {
              _iterator170.f();
            }
            t.remove();
          }
        }
      } catch (err) {
        _iterator168.e(err);
      } finally {
        _iterator168.f();
      }
    }
  }
  function Fn() {
    return function (i) {
      _2(i);
    };
  }
  var am = C(function () {
    l();
  });
  function Nn(i) {
    return /*#__PURE__*/function () {
      var _ref334 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(e, t) {
        var _xo, r, n, a;
        return _regeneratorRuntime().wrap(function _callee7$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              _xo = xo(e), r = _xo.tailwindDirectives, n = _xo.applyDirectives;
              Fn()(e, t);
              a = i({
                tailwindDirectives: r,
                applyDirectives: n,
                registerDependency: function registerDependency(s) {
                  t.messages.push(_objectSpread({
                    plugin: "tailwindcss",
                    parent: t.opts.from
                  }, s));
                },
                createContext: function createContext(s, o) {
                  return co(s, o, e);
                }
              })(e, t);
              if (!(a.tailwindConfig.separator === "-")) {
                _context24.next = 5;
                break;
              }
              throw new Error("The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead.");
            case 5:
              Su(a.tailwindConfig);
              _context24.next = 8;
              return Co(a)(e, t);
            case 8:
              Fn()(e, t);
              _o(a)(e, t);
              Xh(a)(e, t);
              Zh(a)(e, t);
              No(a)(e, t);
              Lo(a)(e, t);
              $o(a)(e, t);
            case 15:
            case "end":
              return _context24.stop();
          }
        }, _callee7);
      }));
      return function (_x10, _x11) {
        return _ref334.apply(this, arguments);
      };
    }();
  }
  var om = C(function () {
    l();
    hh();
    Ah();
    Dh();
    Kh();
    em();
    rm();
    nm();
    sm();
    am();
    Xr();
    ze();
  });
  function lm(i, e) {
    var t = null,
      r = null;
    return i.walkAtRules("config", function (n) {
      var _ref335, _n$source$input$file, _n$source;
      if (r = (_ref335 = (_n$source$input$file = (_n$source = n.source) === null || _n$source === void 0 ? void 0 : _n$source.input.file) !== null && _n$source$input$file !== void 0 ? _n$source$input$file : e.opts.from) !== null && _ref335 !== void 0 ? _ref335 : null, r === null) throw n.error("The `@config` directive cannot be used without setting `from` in your PostCSS config.");
      if (t) throw n.error("Only one `@config` directive is allowed per file.");
      var a = n.params.match(/(['"])(.*?)\1/);
      if (!a) throw n.error("A path is required when using the `@config` directive.");
      var s = a[2];
      if (Z.isAbsolute(s)) throw n.error("The `@config` directive cannot be used with an absolute path.");
      if (t = Z.resolve(Z.dirname(r), s), !te.existsSync(t)) throw n.error("The config file at \"".concat(s, "\" does not exist. Make sure the path is correct and the file exists."));
      n.remove();
    }), t || null;
  }
  var um = C(function () {
    l();
    je();
    yt();
  });
  var fm = v(function (JD, jo) {
    l();
    dh();
    om();
    lt();
    um();
    jo.exports = function (e) {
      return {
        postcssPlugin: "tailwindcss",
        plugins: [Pe.DEBUG && function (t) {
          return console.log("\n"), console.time("JIT TOTAL"), t;
        }, ( /*#__PURE__*/function () {
          var _ref336 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(t, r) {
            var _lm;
            var n, a, _iterator171, _step171, s;
            return _regeneratorRuntime().wrap(function _callee8$(_context25) {
              while (1) switch (_context25.prev = _context25.next) {
                case 0:
                  e = (_lm = lm(t, r)) !== null && _lm !== void 0 ? _lm : e;
                  n = vo(e);
                  if (!(t.type === "document")) {
                    _context25.next = 24;
                    break;
                  }
                  a = t.nodes.filter(function (s) {
                    return s.type === "root";
                  });
                  _iterator171 = _createForOfIteratorHelper(a);
                  _context25.prev = 5;
                  _iterator171.s();
                case 7:
                  if ((_step171 = _iterator171.n()).done) {
                    _context25.next = 15;
                    break;
                  }
                  s = _step171.value;
                  _context25.t0 = s.type === "root";
                  if (!_context25.t0) {
                    _context25.next = 13;
                    break;
                  }
                  _context25.next = 13;
                  return Nn(n)(s, r);
                case 13:
                  _context25.next = 7;
                  break;
                case 15:
                  _context25.next = 20;
                  break;
                case 17:
                  _context25.prev = 17;
                  _context25.t1 = _context25["catch"](5);
                  _iterator171.e(_context25.t1);
                case 20:
                  _context25.prev = 20;
                  _iterator171.f();
                  return _context25.finish(20);
                case 23:
                  return _context25.abrupt("return");
                case 24:
                  _context25.next = 26;
                  return Nn(n)(t, r);
                case 26:
                case "end":
                  return _context25.stop();
              }
            }, _callee8, null, [[5, 17, 20, 23]]);
          }));
          return function (_x12, _x13) {
            return _ref336.apply(this, arguments);
          };
        }()), Pe.DEBUG && function (t) {
          return console.timeEnd("JIT TOTAL"), console.log("\n"), t;
        }].filter(Boolean)
      };
    };
    jo.exports.postcss = !0;
  });
  var pm = v(function (XD, cm) {
    l();
    cm.exports = fm();
  });
  var zo = v(function (KD, dm) {
    l();
    dm.exports = function () {
      return ["and_chr 114", "and_uc 15.5", "chrome 114", "chrome 113", "chrome 109", "edge 114", "firefox 114", "ios_saf 16.5", "ios_saf 16.4", "ios_saf 16.3", "ios_saf 16.1", "opera 99", "safari 16.5", "samsung 21"];
    };
  });
  var Ln = {};
  Ae(Ln, {
    agents: function agents() {
      return O2;
    },
    feature: function feature() {
      return E2;
    }
  });
  function E2() {
    return {
      status: "cr",
      title: "CSS Feature Queries",
      stats: {
        ie: {
          "6": "n",
          "7": "n",
          "8": "n",
          "9": "n",
          "10": "n",
          "11": "n",
          "5.5": "n"
        },
        edge: {
          "12": "y",
          "13": "y",
          "14": "y",
          "15": "y",
          "16": "y",
          "17": "y",
          "18": "y",
          "79": "y",
          "80": "y",
          "81": "y",
          "83": "y",
          "84": "y",
          "85": "y",
          "86": "y",
          "87": "y",
          "88": "y",
          "89": "y",
          "90": "y",
          "91": "y",
          "92": "y",
          "93": "y",
          "94": "y",
          "95": "y",
          "96": "y",
          "97": "y",
          "98": "y",
          "99": "y",
          "100": "y",
          "101": "y",
          "102": "y",
          "103": "y",
          "104": "y",
          "105": "y",
          "106": "y",
          "107": "y",
          "108": "y",
          "109": "y",
          "110": "y",
          "111": "y",
          "112": "y",
          "113": "y",
          "114": "y"
        },
        firefox: {
          "2": "n",
          "3": "n",
          "4": "n",
          "5": "n",
          "6": "n",
          "7": "n",
          "8": "n",
          "9": "n",
          "10": "n",
          "11": "n",
          "12": "n",
          "13": "n",
          "14": "n",
          "15": "n",
          "16": "n",
          "17": "n",
          "18": "n",
          "19": "n",
          "20": "n",
          "21": "n",
          "22": "y",
          "23": "y",
          "24": "y",
          "25": "y",
          "26": "y",
          "27": "y",
          "28": "y",
          "29": "y",
          "30": "y",
          "31": "y",
          "32": "y",
          "33": "y",
          "34": "y",
          "35": "y",
          "36": "y",
          "37": "y",
          "38": "y",
          "39": "y",
          "40": "y",
          "41": "y",
          "42": "y",
          "43": "y",
          "44": "y",
          "45": "y",
          "46": "y",
          "47": "y",
          "48": "y",
          "49": "y",
          "50": "y",
          "51": "y",
          "52": "y",
          "53": "y",
          "54": "y",
          "55": "y",
          "56": "y",
          "57": "y",
          "58": "y",
          "59": "y",
          "60": "y",
          "61": "y",
          "62": "y",
          "63": "y",
          "64": "y",
          "65": "y",
          "66": "y",
          "67": "y",
          "68": "y",
          "69": "y",
          "70": "y",
          "71": "y",
          "72": "y",
          "73": "y",
          "74": "y",
          "75": "y",
          "76": "y",
          "77": "y",
          "78": "y",
          "79": "y",
          "80": "y",
          "81": "y",
          "82": "y",
          "83": "y",
          "84": "y",
          "85": "y",
          "86": "y",
          "87": "y",
          "88": "y",
          "89": "y",
          "90": "y",
          "91": "y",
          "92": "y",
          "93": "y",
          "94": "y",
          "95": "y",
          "96": "y",
          "97": "y",
          "98": "y",
          "99": "y",
          "100": "y",
          "101": "y",
          "102": "y",
          "103": "y",
          "104": "y",
          "105": "y",
          "106": "y",
          "107": "y",
          "108": "y",
          "109": "y",
          "110": "y",
          "111": "y",
          "112": "y",
          "113": "y",
          "114": "y",
          "115": "y",
          "116": "y",
          "117": "y",
          "3.5": "n",
          "3.6": "n"
        },
        chrome: {
          "4": "n",
          "5": "n",
          "6": "n",
          "7": "n",
          "8": "n",
          "9": "n",
          "10": "n",
          "11": "n",
          "12": "n",
          "13": "n",
          "14": "n",
          "15": "n",
          "16": "n",
          "17": "n",
          "18": "n",
          "19": "n",
          "20": "n",
          "21": "n",
          "22": "n",
          "23": "n",
          "24": "n",
          "25": "n",
          "26": "n",
          "27": "n",
          "28": "y",
          "29": "y",
          "30": "y",
          "31": "y",
          "32": "y",
          "33": "y",
          "34": "y",
          "35": "y",
          "36": "y",
          "37": "y",
          "38": "y",
          "39": "y",
          "40": "y",
          "41": "y",
          "42": "y",
          "43": "y",
          "44": "y",
          "45": "y",
          "46": "y",
          "47": "y",
          "48": "y",
          "49": "y",
          "50": "y",
          "51": "y",
          "52": "y",
          "53": "y",
          "54": "y",
          "55": "y",
          "56": "y",
          "57": "y",
          "58": "y",
          "59": "y",
          "60": "y",
          "61": "y",
          "62": "y",
          "63": "y",
          "64": "y",
          "65": "y",
          "66": "y",
          "67": "y",
          "68": "y",
          "69": "y",
          "70": "y",
          "71": "y",
          "72": "y",
          "73": "y",
          "74": "y",
          "75": "y",
          "76": "y",
          "77": "y",
          "78": "y",
          "79": "y",
          "80": "y",
          "81": "y",
          "83": "y",
          "84": "y",
          "85": "y",
          "86": "y",
          "87": "y",
          "88": "y",
          "89": "y",
          "90": "y",
          "91": "y",
          "92": "y",
          "93": "y",
          "94": "y",
          "95": "y",
          "96": "y",
          "97": "y",
          "98": "y",
          "99": "y",
          "100": "y",
          "101": "y",
          "102": "y",
          "103": "y",
          "104": "y",
          "105": "y",
          "106": "y",
          "107": "y",
          "108": "y",
          "109": "y",
          "110": "y",
          "111": "y",
          "112": "y",
          "113": "y",
          "114": "y",
          "115": "y",
          "116": "y",
          "117": "y"
        },
        safari: {
          "4": "n",
          "5": "n",
          "6": "n",
          "7": "n",
          "8": "n",
          "9": "y",
          "10": "y",
          "11": "y",
          "12": "y",
          "13": "y",
          "14": "y",
          "15": "y",
          "17": "y",
          "9.1": "y",
          "10.1": "y",
          "11.1": "y",
          "12.1": "y",
          "13.1": "y",
          "14.1": "y",
          "15.1": "y",
          "15.2-15.3": "y",
          "15.4": "y",
          "15.5": "y",
          "15.6": "y",
          "16.0": "y",
          "16.1": "y",
          "16.2": "y",
          "16.3": "y",
          "16.4": "y",
          "16.5": "y",
          "16.6": "y",
          TP: "y",
          "3.1": "n",
          "3.2": "n",
          "5.1": "n",
          "6.1": "n",
          "7.1": "n"
        },
        opera: {
          "9": "n",
          "11": "n",
          "12": "n",
          "15": "y",
          "16": "y",
          "17": "y",
          "18": "y",
          "19": "y",
          "20": "y",
          "21": "y",
          "22": "y",
          "23": "y",
          "24": "y",
          "25": "y",
          "26": "y",
          "27": "y",
          "28": "y",
          "29": "y",
          "30": "y",
          "31": "y",
          "32": "y",
          "33": "y",
          "34": "y",
          "35": "y",
          "36": "y",
          "37": "y",
          "38": "y",
          "39": "y",
          "40": "y",
          "41": "y",
          "42": "y",
          "43": "y",
          "44": "y",
          "45": "y",
          "46": "y",
          "47": "y",
          "48": "y",
          "49": "y",
          "50": "y",
          "51": "y",
          "52": "y",
          "53": "y",
          "54": "y",
          "55": "y",
          "56": "y",
          "57": "y",
          "58": "y",
          "60": "y",
          "62": "y",
          "63": "y",
          "64": "y",
          "65": "y",
          "66": "y",
          "67": "y",
          "68": "y",
          "69": "y",
          "70": "y",
          "71": "y",
          "72": "y",
          "73": "y",
          "74": "y",
          "75": "y",
          "76": "y",
          "77": "y",
          "78": "y",
          "79": "y",
          "80": "y",
          "81": "y",
          "82": "y",
          "83": "y",
          "84": "y",
          "85": "y",
          "86": "y",
          "87": "y",
          "88": "y",
          "89": "y",
          "90": "y",
          "91": "y",
          "92": "y",
          "93": "y",
          "94": "y",
          "95": "y",
          "96": "y",
          "97": "y",
          "98": "y",
          "99": "y",
          "100": "y",
          "12.1": "y",
          "9.5-9.6": "n",
          "10.0-10.1": "n",
          "10.5": "n",
          "10.6": "n",
          "11.1": "n",
          "11.5": "n",
          "11.6": "n"
        },
        ios_saf: {
          "8": "n",
          "17": "y",
          "9.0-9.2": "y",
          "9.3": "y",
          "10.0-10.2": "y",
          "10.3": "y",
          "11.0-11.2": "y",
          "11.3-11.4": "y",
          "12.0-12.1": "y",
          "12.2-12.5": "y",
          "13.0-13.1": "y",
          "13.2": "y",
          "13.3": "y",
          "13.4-13.7": "y",
          "14.0-14.4": "y",
          "14.5-14.8": "y",
          "15.0-15.1": "y",
          "15.2-15.3": "y",
          "15.4": "y",
          "15.5": "y",
          "15.6": "y",
          "16.0": "y",
          "16.1": "y",
          "16.2": "y",
          "16.3": "y",
          "16.4": "y",
          "16.5": "y",
          "16.6": "y",
          "3.2": "n",
          "4.0-4.1": "n",
          "4.2-4.3": "n",
          "5.0-5.1": "n",
          "6.0-6.1": "n",
          "7.0-7.1": "n",
          "8.1-8.4": "n"
        },
        op_mini: {
          all: "y"
        },
        android: {
          "3": "n",
          "4": "n",
          "114": "y",
          "4.4": "y",
          "4.4.3-4.4.4": "y",
          "2.1": "n",
          "2.2": "n",
          "2.3": "n",
          "4.1": "n",
          "4.2-4.3": "n"
        },
        bb: {
          "7": "n",
          "10": "n"
        },
        op_mob: {
          "10": "n",
          "11": "n",
          "12": "n",
          "73": "y",
          "11.1": "n",
          "11.5": "n",
          "12.1": "n"
        },
        and_chr: {
          "114": "y"
        },
        and_ff: {
          "115": "y"
        },
        ie_mob: {
          "10": "n",
          "11": "n"
        },
        and_uc: {
          "15.5": "y"
        },
        samsung: {
          "4": "y",
          "20": "y",
          "21": "y",
          "5.0-5.4": "y",
          "6.2-6.4": "y",
          "7.2-7.4": "y",
          "8.2": "y",
          "9.2": "y",
          "10.1": "y",
          "11.1-11.2": "y",
          "12.0": "y",
          "13.0": "y",
          "14.0": "y",
          "15.0": "y",
          "16.0": "y",
          "17.0": "y",
          "18.0": "y",
          "19.0": "y"
        },
        and_qq: {
          "13.1": "y"
        },
        baidu: {
          "13.18": "y"
        },
        kaios: {
          "2.5": "y",
          "3.0-3.1": "y"
        }
      }
    };
  }
  var O2,
    $n = C(function () {
      l();
      O2 = {
        ie: {
          prefix: "ms"
        },
        edge: {
          prefix: "webkit",
          prefix_exceptions: {
            "12": "ms",
            "13": "ms",
            "14": "ms",
            "15": "ms",
            "16": "ms",
            "17": "ms",
            "18": "ms"
          }
        },
        firefox: {
          prefix: "moz"
        },
        chrome: {
          prefix: "webkit"
        },
        safari: {
          prefix: "webkit"
        },
        opera: {
          prefix: "webkit",
          prefix_exceptions: {
            "9": "o",
            "11": "o",
            "12": "o",
            "9.5-9.6": "o",
            "10.0-10.1": "o",
            "10.5": "o",
            "10.6": "o",
            "11.1": "o",
            "11.5": "o",
            "11.6": "o",
            "12.1": "o"
          }
        },
        ios_saf: {
          prefix: "webkit"
        },
        op_mini: {
          prefix: "o"
        },
        android: {
          prefix: "webkit"
        },
        bb: {
          prefix: "webkit"
        },
        op_mob: {
          prefix: "o",
          prefix_exceptions: {
            "73": "webkit"
          }
        },
        and_chr: {
          prefix: "webkit"
        },
        and_ff: {
          prefix: "moz"
        },
        ie_mob: {
          prefix: "ms"
        },
        and_uc: {
          prefix: "webkit",
          prefix_exceptions: {
            "15.5": "webkit"
          }
        },
        samsung: {
          prefix: "webkit"
        },
        and_qq: {
          prefix: "webkit"
        },
        baidu: {
          prefix: "webkit"
        },
        kaios: {
          prefix: "moz"
        }
      };
    });
  var hm = v(function () {
    l();
  });
  var le = v(function (t4, pt) {
    l();
    var _ge2 = ge(),
      Vo = _ge2.list;
    pt.exports.error = function (i) {
      var e = new Error(i);
      throw e.autoprefixer = !0, e;
    };
    pt.exports.uniq = function (i) {
      return _toConsumableArray(new Set(i));
    };
    pt.exports.removeNote = function (i) {
      return i.includes(" ") ? i.split(" ")[0] : i;
    };
    pt.exports.escapeRegexp = function (i) {
      return i.replace(/[$()*+-.?[\\\]^{|}]/g, "\\$&");
    };
    pt.exports.regexp = function (i) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
      return e && (i = this.escapeRegexp(i)), new RegExp("(^|[\\s,(])(".concat(i, "($|[\\s(,]))"), "gi");
    };
    pt.exports.editList = function (i, e) {
      var t = Vo.comma(i),
        r = e(t, []);
      if (t === r) return i;
      var n = i.match(/,\s*/);
      return n = n ? n[0] : ", ", r.join(n);
    };
    pt.exports.splitSelector = function (i) {
      return Vo.comma(i).map(function (e) {
        return Vo.space(e).map(function (t) {
          return t.split(/(?=\.|#)/g);
        });
      });
    };
  });
  var dt = v(function (r4, ym) {
    l();
    var T2 = zo(),
      mm = ($n(), Ln).agents,
      P2 = le(),
      gm = /*#__PURE__*/function () {
        function gm(e, t, r, n) {
          _classCallCheck(this, gm);
          this.data = e, this.options = r || {}, this.browserslistOpts = n || {}, this.selected = this.parse(t);
        }
        return _createClass(gm, [{
          key: "parse",
          value: function parse(e) {
            var t = {};
            for (var r in this.browserslistOpts) t[r] = this.browserslistOpts[r];
            return t.path = this.options.from, T2(e, t);
          }
        }, {
          key: "prefix",
          value: function prefix(e) {
            var _e$split = e.split(" "),
              _e$split2 = _slicedToArray(_e$split, 2),
              t = _e$split2[0],
              r = _e$split2[1],
              n = this.data[t],
              a = n.prefix_exceptions && n.prefix_exceptions[r];
            return a || (a = n.prefix), "-".concat(a, "-");
          }
        }, {
          key: "isSelected",
          value: function isSelected(e) {
            return this.selected.includes(e);
          }
        }], [{
          key: "prefixes",
          value: function prefixes() {
            if (this.prefixesCache) return this.prefixesCache;
            this.prefixesCache = [];
            for (var e in mm) this.prefixesCache.push("-".concat(mm[e].prefix, "-"));
            return this.prefixesCache = P2.uniq(this.prefixesCache).sort(function (e, t) {
              return t.length - e.length;
            }), this.prefixesCache;
          }
        }, {
          key: "withPrefix",
          value: function withPrefix(e) {
            return this.prefixesRegexp || (this.prefixesRegexp = new RegExp(this.prefixes().join("|"))), this.prefixesRegexp.test(e);
          }
        }]);
      }();
    ym.exports = gm;
  });
  var ii = v(function (i4, wm) {
    l();
    wm.exports = {
      prefix: function prefix(i) {
        var e = i.match(/^(-\w+-)/);
        return e ? e[0] : "";
      },
      unprefixed: function unprefixed(i) {
        return i.replace(/^-\w+-/, "");
      }
    };
  });
  var Wt = v(function (n4, vm) {
    l();
    var D2 = dt(),
      bm = ii(),
      I2 = le();
    function Uo(i, e) {
      var t = new i.constructor();
      for (var _i25 = 0, _Object$keys = Object.keys(i || {}); _i25 < _Object$keys.length; _i25++) {
        var r = _Object$keys[_i25];
        var n = i[r];
        r === "parent" && _typeof(n) == "object" ? e && (t[r] = e) : r === "source" || r === null ? t[r] = n : Array.isArray(n) ? t[r] = n.map(function (a) {
          return Uo(a, t);
        }) : r !== "_autoprefixerPrefix" && r !== "_autoprefixerValues" && r !== "proxyCache" && (_typeof(n) == "object" && n !== null && (n = Uo(n, t)), t[r] = n);
      }
      return t;
    }
    var jn = /*#__PURE__*/function () {
      function jn(e, t, r) {
        _classCallCheck(this, jn);
        this.prefixes = t, this.name = e, this.all = r;
      }
      return _createClass(jn, [{
        key: "parentPrefix",
        value: function parentPrefix(e) {
          var t;
          return typeof e._autoprefixerPrefix != "undefined" ? t = e._autoprefixerPrefix : e.type === "decl" && e.prop[0] === "-" ? t = bm.prefix(e.prop) : e.type === "root" ? t = !1 : e.type === "rule" && e.selector.includes(":-") && /:(-\w+-)/.test(e.selector) ? t = e.selector.match(/:(-\w+-)/)[1] : e.type === "atrule" && e.name[0] === "-" ? t = bm.prefix(e.name) : t = this.parentPrefix(e.parent), D2.prefixes().includes(t) || (t = !1), e._autoprefixerPrefix = t, e._autoprefixerPrefix;
        }
      }, {
        key: "process",
        value: function process(e, t) {
          if (!this.check(e)) return;
          var r = this.parentPrefix(e),
            n = this.prefixes.filter(function (s) {
              return !r || r === I2.removeNote(s);
            }),
            a = [];
          var _iterator172 = _createForOfIteratorHelper(n),
            _step172;
          try {
            for (_iterator172.s(); !(_step172 = _iterator172.n()).done;) {
              var s = _step172.value;
              this.add(e, s, a.concat([s]), t) && a.push(s);
            }
          } catch (err) {
            _iterator172.e(err);
          } finally {
            _iterator172.f();
          }
          return a;
        }
      }, {
        key: "clone",
        value: function clone(e, t) {
          return jn.clone(e, t);
        }
      }], [{
        key: "hack",
        value: function hack(e) {
          var _this16 = this;
          return this.hacks || (this.hacks = {}), e.names.map(function (t) {
            return _this16.hacks[t] = e, _this16.hacks[t];
          });
        }
      }, {
        key: "load",
        value: function load(e, t, r) {
          var n = this.hacks && this.hacks[e];
          return n ? new n(e, t, r) : new this(e, t, r);
        }
      }, {
        key: "clone",
        value: function clone(e, t) {
          var r = Uo(e);
          for (var n in t) r[n] = t[n];
          return r;
        }
      }]);
    }();
    vm.exports = jn;
  });
  var M = v(function (s4, Sm) {
    l();
    var q2 = Wt(),
      R2 = dt(),
      xm = le(),
      km = /*#__PURE__*/function (_q) {
        function km() {
          _classCallCheck(this, km);
          return _callSuper(this, km, arguments);
        }
        _inherits(km, _q);
        return _createClass(km, [{
          key: "check",
          value: function check() {
            return !0;
          }
        }, {
          key: "prefixed",
          value: function prefixed(e, t) {
            return t + e;
          }
        }, {
          key: "normalize",
          value: function normalize(e) {
            return e;
          }
        }, {
          key: "otherPrefixes",
          value: function otherPrefixes(e, t) {
            var _iterator173 = _createForOfIteratorHelper(R2.prefixes()),
              _step173;
            try {
              for (_iterator173.s(); !(_step173 = _iterator173.n()).done;) {
                var r = _step173.value;
                if (r !== t && e.includes(r)) return !0;
              }
            } catch (err) {
              _iterator173.e(err);
            } finally {
              _iterator173.f();
            }
            return !1;
          }
        }, {
          key: "set",
          value: function set(e, t) {
            return e.prop = this.prefixed(e.prop, t), e;
          }
        }, {
          key: "needCascade",
          value: function needCascade(e) {
            return e._autoprefixerCascade || (e._autoprefixerCascade = this.all.options.cascade !== !1 && e.raw("before").includes("\n")), e._autoprefixerCascade;
          }
        }, {
          key: "maxPrefixed",
          value: function maxPrefixed(e, t) {
            if (t._autoprefixerMax) return t._autoprefixerMax;
            var r = 0;
            var _iterator174 = _createForOfIteratorHelper(e),
              _step174;
            try {
              for (_iterator174.s(); !(_step174 = _iterator174.n()).done;) {
                var n = _step174.value;
                n = xm.removeNote(n), n.length > r && (r = n.length);
              }
            } catch (err) {
              _iterator174.e(err);
            } finally {
              _iterator174.f();
            }
            return t._autoprefixerMax = r, t._autoprefixerMax;
          }
        }, {
          key: "calcBefore",
          value: function calcBefore(e, t) {
            var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
            var a = this.maxPrefixed(e, t) - xm.removeNote(r).length,
              s = t.raw("before");
            return a > 0 && (s += Array(a).fill(" ").join("")), s;
          }
        }, {
          key: "restoreBefore",
          value: function restoreBefore(e) {
            var t = e.raw("before").split("\n"),
              r = t[t.length - 1];
            this.all.group(e).up(function (n) {
              var a = n.raw("before").split("\n"),
                s = a[a.length - 1];
              s.length < r.length && (r = s);
            }), t[t.length - 1] = r, e.raws.before = t.join("\n");
          }
        }, {
          key: "insert",
          value: function insert(e, t, r) {
            var n = this.set(this.clone(e), t);
            if (!(!n || e.parent.some(function (s) {
              return s.prop === n.prop && s.value === n.value;
            }))) return this.needCascade(e) && (n.raws.before = this.calcBefore(r, e, t)), e.parent.insertBefore(e, n);
          }
        }, {
          key: "isAlready",
          value: function isAlready(e, t) {
            var r = this.all.group(e).up(function (n) {
              return n.prop === t;
            });
            return r || (r = this.all.group(e).down(function (n) {
              return n.prop === t;
            })), r;
          }
        }, {
          key: "add",
          value: function add(e, t, r, n) {
            var a = this.prefixed(e.prop, t);
            if (!(this.isAlready(e, a) || this.otherPrefixes(e.value, t))) return this.insert(e, t, r, n);
          }
        }, {
          key: "process",
          value: function process(e, t) {
            if (!this.needCascade(e)) {
              _get(_getPrototypeOf(km.prototype), "process", this).call(this, e, t);
              return;
            }
            var r = _get(_getPrototypeOf(km.prototype), "process", this).call(this, e, t);
            !r || !r.length || (this.restoreBefore(e), e.raws.before = this.calcBefore(r, e));
          }
        }, {
          key: "old",
          value: function old(e, t) {
            return [this.prefixed(e, t)];
          }
        }]);
      }(q2);
    Sm.exports = km;
  });
  var Am = v(function (a4, Cm) {
    l();
    Cm.exports = function i(e) {
      return {
        mul: function mul(t) {
          return new i(e * t);
        },
        div: function div(t) {
          return new i(e / t);
        },
        simplify: function simplify() {
          return new i(e);
        },
        toString: function toString() {
          return e.toString();
        }
      };
    };
  });
  var Em = v(function (o4, Om) {
    l();
    var M2 = Am(),
      B2 = Wt(),
      Wo = le(),
      F2 = /(min|max)-resolution\s*:\s*\d*\.?\d+(dppx|dpcm|dpi|x)/gi,
      N2 = /(min|max)-resolution(\s*:\s*)(\d*\.?\d+)(dppx|dpcm|dpi|x)/i,
      _m = /*#__PURE__*/function (_B) {
        function _m() {
          _classCallCheck(this, _m);
          return _callSuper(this, _m, arguments);
        }
        _inherits(_m, _B);
        return _createClass(_m, [{
          key: "prefixName",
          value: function prefixName(e, t) {
            return e === "-moz-" ? t + "--moz-device-pixel-ratio" : e + t + "-device-pixel-ratio";
          }
        }, {
          key: "prefixQuery",
          value: function prefixQuery(e, t, r, n, a) {
            return n = new M2(n), a === "dpi" ? n = n.div(96) : a === "dpcm" && (n = n.mul(2.54).div(96)), n = n.simplify(), e === "-o-" && (n = n.n + "/" + n.d), this.prefixName(e, t) + r + n;
          }
        }, {
          key: "clean",
          value: function clean(e) {
            var _this17 = this;
            if (!this.bad) {
              this.bad = [];
              var _iterator175 = _createForOfIteratorHelper(this.prefixes),
                _step175;
              try {
                for (_iterator175.s(); !(_step175 = _iterator175.n()).done;) {
                  var t = _step175.value;
                  this.bad.push(this.prefixName(t, "min")), this.bad.push(this.prefixName(t, "max"));
                }
              } catch (err) {
                _iterator175.e(err);
              } finally {
                _iterator175.f();
              }
            }
            e.params = Wo.editList(e.params, function (t) {
              return t.filter(function (r) {
                return _this17.bad.every(function (n) {
                  return !r.includes(n);
                });
              });
            });
          }
        }, {
          key: "process",
          value: function process(e) {
            var _this18 = this;
            var t = this.parentPrefix(e),
              r = t ? [t] : this.prefixes;
            e.params = Wo.editList(e.params, function (n, a) {
              var _iterator176 = _createForOfIteratorHelper(n),
                _step176;
              try {
                for (_iterator176.s(); !(_step176 = _iterator176.n()).done;) {
                  var s = _step176.value;
                  if (!s.includes("min-resolution") && !s.includes("max-resolution")) {
                    a.push(s);
                    continue;
                  }
                  var _iterator177 = _createForOfIteratorHelper(r),
                    _step177;
                  try {
                    var _loop25 = function _loop25() {
                      var o = _step177.value;
                      var u = s.replace(F2, function (c) {
                        var f = c.match(N2);
                        return _this18.prefixQuery(o, f[1], f[2], f[3], f[4]);
                      });
                      a.push(u);
                    };
                    for (_iterator177.s(); !(_step177 = _iterator177.n()).done;) {
                      _loop25();
                    }
                  } catch (err) {
                    _iterator177.e(err);
                  } finally {
                    _iterator177.f();
                  }
                  a.push(s);
                }
              } catch (err) {
                _iterator176.e(err);
              } finally {
                _iterator176.f();
              }
              return Wo.uniq(a);
            });
          }
        }]);
      }(B2);
    Om.exports = _m;
  });
  var Pm = v(function (l4, Tm) {
    l();
    var Go = "(".charCodeAt(0),
      Ho = ")".charCodeAt(0),
      zn = "'".charCodeAt(0),
      Yo = '"'.charCodeAt(0),
      Qo = "\\".charCodeAt(0),
      Gt = "/".charCodeAt(0),
      Jo = ",".charCodeAt(0),
      Xo = ":".charCodeAt(0),
      Vn = "*".charCodeAt(0),
      L2 = "u".charCodeAt(0),
      $2 = "U".charCodeAt(0),
      j2 = "+".charCodeAt(0),
      z2 = /^[a-f0-9?-]+$/i;
    Tm.exports = function (i) {
      for (var e = [], t = i, r, n, a, s, o, u, c, f, d = 0, p = t.charCodeAt(d), m = t.length, b = [{
          nodes: e
        }], x = 0, y, w = "", k = "", S = ""; d < m;) if (p <= 32) {
        r = d;
        do r += 1, p = t.charCodeAt(r); while (p <= 32);
        s = t.slice(d, r), a = e[e.length - 1], p === Ho && x ? S = s : a && a.type === "div" ? (a.after = s, a.sourceEndIndex += s.length) : p === Jo || p === Xo || p === Gt && t.charCodeAt(r + 1) !== Vn && (!y || y && y.type === "function" && y.value !== "calc") ? k = s : e.push({
          type: "space",
          sourceIndex: d,
          sourceEndIndex: r,
          value: s
        }), d = r;
      } else if (p === zn || p === Yo) {
        r = d, n = p === zn ? "'" : '"', s = {
          type: "string",
          sourceIndex: d,
          quote: n
        };
        do if (o = !1, r = t.indexOf(n, r + 1), ~r) for (u = r; t.charCodeAt(u - 1) === Qo;) u -= 1, o = !o;else t += n, r = t.length - 1, s.unclosed = !0; while (o);
        s.value = t.slice(d + 1, r), s.sourceEndIndex = s.unclosed ? r : r + 1, e.push(s), d = r + 1, p = t.charCodeAt(d);
      } else if (p === Gt && t.charCodeAt(d + 1) === Vn) r = t.indexOf("*/", d), s = {
        type: "comment",
        sourceIndex: d,
        sourceEndIndex: r + 2
      }, r === -1 && (s.unclosed = !0, r = t.length, s.sourceEndIndex = r), s.value = t.slice(d + 2, r), e.push(s), d = r + 2, p = t.charCodeAt(d);else if ((p === Gt || p === Vn) && y && y.type === "function" && y.value === "calc") s = t[d], e.push({
        type: "word",
        sourceIndex: d - k.length,
        sourceEndIndex: d + s.length,
        value: s
      }), d += 1, p = t.charCodeAt(d);else if (p === Gt || p === Jo || p === Xo) s = t[d], e.push({
        type: "div",
        sourceIndex: d - k.length,
        sourceEndIndex: d + s.length,
        value: s,
        before: k,
        after: ""
      }), k = "", d += 1, p = t.charCodeAt(d);else if (Go === p) {
        r = d;
        do r += 1, p = t.charCodeAt(r); while (p <= 32);
        if (f = d, s = {
          type: "function",
          sourceIndex: d - w.length,
          value: w,
          before: t.slice(f + 1, r)
        }, d = r, w === "url" && p !== zn && p !== Yo) {
          r -= 1;
          do if (o = !1, r = t.indexOf(")", r + 1), ~r) for (u = r; t.charCodeAt(u - 1) === Qo;) u -= 1, o = !o;else t += ")", r = t.length - 1, s.unclosed = !0; while (o);
          c = r;
          do c -= 1, p = t.charCodeAt(c); while (p <= 32);
          f < c ? (d !== c + 1 ? s.nodes = [{
            type: "word",
            sourceIndex: d,
            sourceEndIndex: c + 1,
            value: t.slice(d, c + 1)
          }] : s.nodes = [], s.unclosed && c + 1 !== r ? (s.after = "", s.nodes.push({
            type: "space",
            sourceIndex: c + 1,
            sourceEndIndex: r,
            value: t.slice(c + 1, r)
          })) : (s.after = t.slice(c + 1, r), s.sourceEndIndex = r)) : (s.after = "", s.nodes = []), d = r + 1, s.sourceEndIndex = s.unclosed ? r : d, p = t.charCodeAt(d), e.push(s);
        } else x += 1, s.after = "", s.sourceEndIndex = d + 1, e.push(s), b.push(s), e = s.nodes = [], y = s;
        w = "";
      } else if (Ho === p && x) d += 1, p = t.charCodeAt(d), y.after = S, y.sourceEndIndex += S.length, S = "", x -= 1, b[b.length - 1].sourceEndIndex = d, b.pop(), y = b[x], e = y.nodes;else {
        r = d;
        do p === Qo && (r += 1), r += 1, p = t.charCodeAt(r); while (r < m && !(p <= 32 || p === zn || p === Yo || p === Jo || p === Xo || p === Gt || p === Go || p === Vn && y && y.type === "function" && y.value === "calc" || p === Gt && y.type === "function" && y.value === "calc" || p === Ho && x));
        s = t.slice(d, r), Go === p ? w = s : (L2 === s.charCodeAt(0) || $2 === s.charCodeAt(0)) && j2 === s.charCodeAt(1) && z2.test(s.slice(2)) ? e.push({
          type: "unicode-range",
          sourceIndex: d,
          sourceEndIndex: r,
          value: s
        }) : e.push({
          type: "word",
          sourceIndex: d,
          sourceEndIndex: r,
          value: s
        }), d = r;
      }
      for (d = b.length - 1; d; d -= 1) b[d].unclosed = !0, b[d].sourceEndIndex = t.length;
      return b[0].nodes;
    };
  });
  var Im = v(function (u4, Dm) {
    l();
    Dm.exports = function i(e, t, r) {
      var n, a, s, o;
      for (n = 0, a = e.length; n < a; n += 1) s = e[n], r || (o = t(s, n, e)), o !== !1 && s.type === "function" && Array.isArray(s.nodes) && i(s.nodes, t, r), r && t(s, n, e);
    };
  });
  var Bm = v(function (f4, Mm) {
    l();
    function qm(i, e) {
      var t = i.type,
        r = i.value,
        n,
        a;
      return e && (a = e(i)) !== void 0 ? a : t === "word" || t === "space" ? r : t === "string" ? (n = i.quote || "", n + r + (i.unclosed ? "" : n)) : t === "comment" ? "/*" + r + (i.unclosed ? "" : "*/") : t === "div" ? (i.before || "") + r + (i.after || "") : Array.isArray(i.nodes) ? (n = Rm(i.nodes, e), t !== "function" ? n : r + "(" + (i.before || "") + n + (i.after || "") + (i.unclosed ? "" : ")")) : r;
    }
    function Rm(i, e) {
      var t, r;
      if (Array.isArray(i)) {
        for (t = "", r = i.length - 1; ~r; r -= 1) t = qm(i[r], e) + t;
        return t;
      }
      return qm(i, e);
    }
    Mm.exports = Rm;
  });
  var Nm = v(function (c4, Fm) {
    l();
    var Un = "-".charCodeAt(0),
      Wn = "+".charCodeAt(0),
      Ko = ".".charCodeAt(0),
      V2 = "e".charCodeAt(0),
      U2 = "E".charCodeAt(0);
    function W2(i) {
      var e = i.charCodeAt(0),
        t;
      if (e === Wn || e === Un) {
        if (t = i.charCodeAt(1), t >= 48 && t <= 57) return !0;
        var r = i.charCodeAt(2);
        return t === Ko && r >= 48 && r <= 57;
      }
      return e === Ko ? (t = i.charCodeAt(1), t >= 48 && t <= 57) : e >= 48 && e <= 57;
    }
    Fm.exports = function (i) {
      var e = 0,
        t = i.length,
        r,
        n,
        a;
      if (t === 0 || !W2(i)) return !1;
      for (r = i.charCodeAt(e), (r === Wn || r === Un) && e++; e < t && (r = i.charCodeAt(e), !(r < 48 || r > 57));) e += 1;
      if (r = i.charCodeAt(e), n = i.charCodeAt(e + 1), r === Ko && n >= 48 && n <= 57) for (e += 2; e < t && (r = i.charCodeAt(e), !(r < 48 || r > 57));) e += 1;
      if (r = i.charCodeAt(e), n = i.charCodeAt(e + 1), a = i.charCodeAt(e + 2), (r === V2 || r === U2) && (n >= 48 && n <= 57 || (n === Wn || n === Un) && a >= 48 && a <= 57)) for (e += n === Wn || n === Un ? 3 : 2; e < t && (r = i.charCodeAt(e), !(r < 48 || r > 57));) e += 1;
      return {
        number: i.slice(0, e),
        unit: i.slice(e)
      };
    };
  });
  var Gn = v(function (p4, jm) {
    l();
    var G2 = Pm(),
      Lm = Im(),
      $m = Bm();
    function ht(i) {
      return this instanceof ht ? (this.nodes = G2(i), this) : new ht(i);
    }
    ht.prototype.toString = function () {
      return Array.isArray(this.nodes) ? $m(this.nodes) : "";
    };
    ht.prototype.walk = function (i, e) {
      return Lm(this.nodes, i, e), this;
    };
    ht.unit = Nm();
    ht.walk = Lm;
    ht.stringify = $m;
    jm.exports = ht;
  });
  var Gm = v(function (d4, Wm) {
    l();
    var _ge3 = ge(),
      H2 = _ge3.list,
      zm = Gn(),
      Y2 = dt(),
      Vm = ii(),
      Um = /*#__PURE__*/function () {
        function Um(e) {
          _classCallCheck(this, Um);
          this.props = ["transition", "transition-property"], this.prefixes = e;
        }
        return _createClass(Um, [{
          key: "add",
          value: function add(e, t) {
            var _this19 = this;
            var r,
              n,
              a = this.prefixes.add[e.prop],
              s = this.ruleVendorPrefixes(e),
              o = s || a && a.prefixes || [],
              u = this.parse(e.value),
              c = u.map(function (m) {
                return _this19.findProp(m);
              }),
              f = [];
            if (c.some(function (m) {
              return m[0] === "-";
            })) return;
            var _iterator178 = _createForOfIteratorHelper(u),
              _step178;
            try {
              for (_iterator178.s(); !(_step178 = _iterator178.n()).done;) {
                var _m7 = _step178.value;
                if (n = this.findProp(_m7), n[0] === "-") continue;
                var b = this.prefixes.add[n];
                if (!(!b || !b.prefixes)) {
                  var _iterator180 = _createForOfIteratorHelper(b.prefixes),
                    _step180;
                  try {
                    for (_iterator180.s(); !(_step180 = _iterator180.n()).done;) {
                      r = _step180.value;
                      if (s && !s.some(function (y) {
                        return r.includes(y);
                      })) continue;
                      var x = this.prefixes.prefixed(n, r);
                      x !== "-ms-transform" && !c.includes(x) && (this.disabled(n, r) || f.push(this.clone(n, x, _m7)));
                    }
                  } catch (err) {
                    _iterator180.e(err);
                  } finally {
                    _iterator180.f();
                  }
                }
              }
            } catch (err) {
              _iterator178.e(err);
            } finally {
              _iterator178.f();
            }
            u = u.concat(f);
            var d = this.stringify(u),
              p = this.stringify(this.cleanFromUnprefixed(u, "-webkit-"));
            if (o.includes("-webkit-") && this.cloneBefore(e, "-webkit-".concat(e.prop), p), this.cloneBefore(e, e.prop, p), o.includes("-o-")) {
              var m = this.stringify(this.cleanFromUnprefixed(u, "-o-"));
              this.cloneBefore(e, "-o-".concat(e.prop), m);
            }
            var _iterator179 = _createForOfIteratorHelper(o),
              _step179;
            try {
              for (_iterator179.s(); !(_step179 = _iterator179.n()).done;) {
                r = _step179.value;
                if (r !== "-webkit-" && r !== "-o-") {
                  var _m8 = this.stringify(this.cleanOtherPrefixes(u, r));
                  this.cloneBefore(e, r + e.prop, _m8);
                }
              }
            } catch (err) {
              _iterator179.e(err);
            } finally {
              _iterator179.f();
            }
            d !== e.value && !this.already(e, e.prop, d) && (this.checkForWarning(t, e), e.cloneBefore(), e.value = d);
          }
        }, {
          key: "findProp",
          value: function findProp(e) {
            var t = e[0].value;
            if (/^\d/.test(t)) {
              var _iterator181 = _createForOfIteratorHelper(e.entries()),
                _step181;
              try {
                for (_iterator181.s(); !(_step181 = _iterator181.n()).done;) {
                  var _step181$value = _slicedToArray(_step181.value, 2),
                    r = _step181$value[0],
                    n = _step181$value[1];
                  if (r !== 0 && n.type === "word") return n.value;
                }
              } catch (err) {
                _iterator181.e(err);
              } finally {
                _iterator181.f();
              }
            }
            return t;
          }
        }, {
          key: "already",
          value: function already(e, t, r) {
            return e.parent.some(function (n) {
              return n.prop === t && n.value === r;
            });
          }
        }, {
          key: "cloneBefore",
          value: function cloneBefore(e, t, r) {
            this.already(e, t, r) || e.cloneBefore({
              prop: t,
              value: r
            });
          }
        }, {
          key: "checkForWarning",
          value: function checkForWarning(e, t) {
            var _this20 = this;
            if (t.prop !== "transition-property") return;
            var r = !1,
              n = !1;
            t.parent.each(function (a) {
              if (a.type !== "decl" || a.prop.indexOf("transition-") !== 0) return;
              var s = H2.comma(a.value);
              if (a.prop === "transition-property") {
                s.forEach(function (o) {
                  var u = _this20.prefixes.add[o];
                  u && u.prefixes && u.prefixes.length > 0 && (r = !0);
                });
                return;
              }
              return n = n || s.length > 1, !1;
            }), r && n && t.warn(e, "Replace transition-property to transition, because Autoprefixer could not support any cases of transition-property and other transition-*");
          }
        }, {
          key: "remove",
          value: function remove(e) {
            var _this21 = this;
            var t = this.parse(e.value);
            t = t.filter(function (s) {
              var o = _this21.prefixes.remove[_this21.findProp(s)];
              return !o || !o.remove;
            });
            var r = this.stringify(t);
            if (e.value === r) return;
            if (t.length === 0) {
              e.remove();
              return;
            }
            var n = e.parent.some(function (s) {
                return s.prop === e.prop && s.value === r;
              }),
              a = e.parent.some(function (s) {
                return s !== e && s.prop === e.prop && s.value.length > r.length;
              });
            if (n || a) {
              e.remove();
              return;
            }
            e.value = r;
          }
        }, {
          key: "parse",
          value: function parse(e) {
            var t = zm(e),
              r = [],
              n = [];
            var _iterator182 = _createForOfIteratorHelper(t.nodes),
              _step182;
            try {
              for (_iterator182.s(); !(_step182 = _iterator182.n()).done;) {
                var a = _step182.value;
                n.push(a), a.type === "div" && a.value === "," && (r.push(n), n = []);
              }
            } catch (err) {
              _iterator182.e(err);
            } finally {
              _iterator182.f();
            }
            return r.push(n), r.filter(function (a) {
              return a.length > 0;
            });
          }
        }, {
          key: "stringify",
          value: function stringify(e) {
            if (e.length === 0) return "";
            var t = [];
            var _iterator183 = _createForOfIteratorHelper(e),
              _step183;
            try {
              for (_iterator183.s(); !(_step183 = _iterator183.n()).done;) {
                var r = _step183.value;
                r[r.length - 1].type !== "div" && r.push(this.div(e)), t = t.concat(r);
              }
            } catch (err) {
              _iterator183.e(err);
            } finally {
              _iterator183.f();
            }
            return t[0].type === "div" && (t = t.slice(1)), t[t.length - 1].type === "div" && (t = t.slice(0, -2 + 1 || 0)), zm.stringify({
              nodes: t
            });
          }
        }, {
          key: "clone",
          value: function clone(e, t, r) {
            var n = [],
              a = !1;
            var _iterator184 = _createForOfIteratorHelper(r),
              _step184;
            try {
              for (_iterator184.s(); !(_step184 = _iterator184.n()).done;) {
                var s = _step184.value;
                !a && s.type === "word" && s.value === e ? (n.push({
                  type: "word",
                  value: t
                }), a = !0) : n.push(s);
              }
            } catch (err) {
              _iterator184.e(err);
            } finally {
              _iterator184.f();
            }
            return n;
          }
        }, {
          key: "div",
          value: function div(e) {
            var _iterator185 = _createForOfIteratorHelper(e),
              _step185;
            try {
              for (_iterator185.s(); !(_step185 = _iterator185.n()).done;) {
                var t = _step185.value;
                var _iterator186 = _createForOfIteratorHelper(t),
                  _step186;
                try {
                  for (_iterator186.s(); !(_step186 = _iterator186.n()).done;) {
                    var r = _step186.value;
                    if (r.type === "div" && r.value === ",") return r;
                  }
                } catch (err) {
                  _iterator186.e(err);
                } finally {
                  _iterator186.f();
                }
              }
            } catch (err) {
              _iterator185.e(err);
            } finally {
              _iterator185.f();
            }
            return {
              type: "div",
              value: ",",
              after: " "
            };
          }
        }, {
          key: "cleanOtherPrefixes",
          value: function cleanOtherPrefixes(e, t) {
            var _this22 = this;
            return e.filter(function (r) {
              var n = Vm.prefix(_this22.findProp(r));
              return n === "" || n === t;
            });
          }
        }, {
          key: "cleanFromUnprefixed",
          value: function cleanFromUnprefixed(e, t) {
            var _this23 = this;
            var r = e.map(function (a) {
                return _this23.findProp(a);
              }).filter(function (a) {
                return a.slice(0, t.length) === t;
              }).map(function (a) {
                return _this23.prefixes.unprefixed(a);
              }),
              n = [];
            var _iterator187 = _createForOfIteratorHelper(e),
              _step187;
            try {
              for (_iterator187.s(); !(_step187 = _iterator187.n()).done;) {
                var a = _step187.value;
                var s = this.findProp(a),
                  o = Vm.prefix(s);
                !r.includes(s) && (o === t || o === "") && n.push(a);
              }
            } catch (err) {
              _iterator187.e(err);
            } finally {
              _iterator187.f();
            }
            return n;
          }
        }, {
          key: "disabled",
          value: function disabled(e, t) {
            var r = ["order", "justify-content", "align-self", "align-content"];
            if (e.includes("flex") || r.includes(e)) {
              if (this.prefixes.options.flexbox === !1) return !0;
              if (this.prefixes.options.flexbox === "no-2009") return t.includes("2009");
            }
          }
        }, {
          key: "ruleVendorPrefixes",
          value: function ruleVendorPrefixes(e) {
            var t = e.parent;
            if (t.type !== "rule") return !1;
            if (!t.selector.includes(":-")) return !1;
            var r = Y2.prefixes().filter(function (n) {
              return t.selector.includes(":" + n);
            });
            return r.length > 0 ? r : !1;
          }
        }]);
      }();
    Wm.exports = Um;
  });
  var Ht = v(function (h4, Ym) {
    l();
    var Q2 = le(),
      Hm = /*#__PURE__*/function () {
        function Hm(e, t, r, n) {
          _classCallCheck(this, Hm);
          this.unprefixed = e, this.prefixed = t, this.string = r || t, this.regexp = n || Q2.regexp(t);
        }
        return _createClass(Hm, [{
          key: "check",
          value: function check(e) {
            return e.includes(this.string) ? !!e.match(this.regexp) : !1;
          }
        }]);
      }();
    Ym.exports = Hm;
  });
  var ke = v(function (m4, Jm) {
    l();
    var J2 = Wt(),
      X2 = Ht(),
      K2 = ii(),
      Z2 = le(),
      Qm = /*#__PURE__*/function (_J) {
        function Qm() {
          _classCallCheck(this, Qm);
          return _callSuper(this, Qm, arguments);
        }
        _inherits(Qm, _J);
        return _createClass(Qm, [{
          key: "check",
          value: function check(e) {
            var t = e.value;
            return t.includes(this.name) ? !!t.match(this.regexp()) : !1;
          }
        }, {
          key: "regexp",
          value: function regexp() {
            return this.regexpCache || (this.regexpCache = Z2.regexp(this.name));
          }
        }, {
          key: "replace",
          value: function replace(e, t) {
            return e.replace(this.regexp(), "$1".concat(t, "$2"));
          }
        }, {
          key: "value",
          value: function value(e) {
            return e.raws.value && e.raws.value.value === e.value ? e.raws.value.raw : e.value;
          }
        }, {
          key: "add",
          value: function add(e, t) {
            e._autoprefixerValues || (e._autoprefixerValues = {});
            var r = e._autoprefixerValues[t] || this.value(e),
              n;
            do if (n = r, r = this.replace(r, t), r === !1) return; while (r !== n);
            e._autoprefixerValues[t] = r;
          }
        }, {
          key: "old",
          value: function old(e) {
            return new X2(this.name, e + this.name);
          }
        }], [{
          key: "save",
          value: function save(e, t) {
            var _this24 = this;
            var r = t.prop,
              n = [];
            var _loop26 = function _loop26() {
                var s = t._autoprefixerValues[a];
                if (s === t.value) return 0; // continue
                var o,
                  u = K2.prefix(r);
                if (u === "-pie-") return 0; // continue
                if (u === a) {
                  o = t.value = s, n.push(o);
                  return 0; // continue
                }
                var c = e.prefixed(r, a),
                  f = t.parent;
                if (!f.every(function (b) {
                  return b.prop !== c;
                })) {
                  n.push(o);
                  return 0; // continue
                }
                var d = s.replace(/\s+/, " ");
                if (f.some(function (b) {
                  return b.prop === t.prop && b.value.replace(/\s+/, " ") === d;
                })) {
                  n.push(o);
                  return 0; // continue
                }
                var m = _this24.clone(t, {
                  value: s
                });
                o = t.parent.insertBefore(t, m), n.push(o);
              },
              _ret2;
            for (var a in t._autoprefixerValues) {
              _ret2 = _loop26();
              if (_ret2 === 0) continue;
            }
            return n;
          }
        }]);
      }(J2);
    Jm.exports = Qm;
  });
  var mt = v(function (g4, Xm) {
    l();
    Xm.exports = {};
  });
  var el = v(function (y4, eg) {
    l();
    var Km = Gn(),
      eA = ke(),
      tA = mt().insertAreas,
      rA = /(^|[^-])linear-gradient\(\s*(top|left|right|bottom)/i,
      iA = /(^|[^-])radial-gradient\(\s*\d+(\w*|%)\s+\d+(\w*|%)\s*,/i,
      nA = /(!\s*)?autoprefixer:\s*ignore\s+next/i,
      sA = /(!\s*)?autoprefixer\s*grid:\s*(on|off|(no-)?autoplace)/i,
      aA = ["width", "height", "min-width", "max-width", "min-height", "max-height", "inline-size", "min-inline-size", "max-inline-size", "block-size", "min-block-size", "max-block-size"];
    function Zo(i) {
      return i.parent.some(function (e) {
        return e.prop === "grid-template" || e.prop === "grid-template-areas";
      });
    }
    function oA(i) {
      var e = i.parent.some(function (r) {
          return r.prop === "grid-template-rows";
        }),
        t = i.parent.some(function (r) {
          return r.prop === "grid-template-columns";
        });
      return e && t;
    }
    var Zm = /*#__PURE__*/function () {
      function Zm(e) {
        _classCallCheck(this, Zm);
        this.prefixes = e;
      }
      return _createClass(Zm, [{
        key: "add",
        value: function add(e, t) {
          var _this25 = this;
          var r = this.prefixes.add["@resolution"],
            n = this.prefixes.add["@keyframes"],
            a = this.prefixes.add["@viewport"],
            s = this.prefixes.add["@supports"];
          e.walkAtRules(function (f) {
            if (f.name === "keyframes") {
              if (!_this25.disabled(f, t)) return n && n.process(f);
            } else if (f.name === "viewport") {
              if (!_this25.disabled(f, t)) return a && a.process(f);
            } else if (f.name === "supports") {
              if (_this25.prefixes.options.supports !== !1 && !_this25.disabled(f, t)) return s.process(f);
            } else if (f.name === "media" && f.params.includes("-resolution") && !_this25.disabled(f, t)) return r && r.process(f);
          }), e.walkRules(function (f) {
            if (!_this25.disabled(f, t)) return _this25.prefixes.add.selectors.map(function (d) {
              return d.process(f, t);
            });
          });
          function o(f) {
            return f.parent.nodes.some(function (d) {
              if (d.type !== "decl") return !1;
              var p = d.prop === "display" && /(inline-)?grid/.test(d.value),
                m = d.prop.startsWith("grid-template"),
                b = /^grid-([A-z]+-)?gap/.test(d.prop);
              return p || m || b;
            });
          }
          function u(f) {
            return f.parent.some(function (d) {
              return d.prop === "display" && /(inline-)?flex/.test(d.value);
            });
          }
          var c = this.gridStatus(e, t) && this.prefixes.add["grid-area"] && this.prefixes.add["grid-area"].prefixes;
          return e.walkDecls(function (f) {
            if (_this25.disabledDecl(f, t)) return;
            var d = f.parent,
              p = f.prop,
              m = f.value;
            if (p === "grid-row-span") {
              t.warn("grid-row-span is not part of final Grid Layout. Use grid-row.", {
                node: f
              });
              return;
            } else if (p === "grid-column-span") {
              t.warn("grid-column-span is not part of final Grid Layout. Use grid-column.", {
                node: f
              });
              return;
            } else if (p === "display" && m === "box") {
              t.warn("You should write display: flex by final spec instead of display: box", {
                node: f
              });
              return;
            } else if (p === "text-emphasis-position") (m === "under" || m === "over") && t.warn("You should use 2 values for text-emphasis-position For example, `under left` instead of just `under`.", {
              node: f
            });else if (/^(align|justify|place)-(items|content)$/.test(p) && u(f)) (m === "start" || m === "end") && t.warn("".concat(m, " value has mixed support, consider using flex-").concat(m, " instead"), {
              node: f
            });else if (p === "text-decoration-skip" && m === "ink") t.warn("Replace text-decoration-skip: ink to text-decoration-skip-ink: auto, because spec had been changed", {
              node: f
            });else {
              if (c && _this25.gridStatus(f, t)) if (f.value === "subgrid" && t.warn("IE does not support subgrid", {
                node: f
              }), /^(align|justify|place)-items$/.test(p) && o(f)) {
                var x = p.replace("-items", "-self");
                t.warn("IE does not support ".concat(p, " on grid containers. Try using ").concat(x, " on child elements instead: ").concat(f.parent.selector, " > * { ").concat(x, ": ").concat(f.value, " }"), {
                  node: f
                });
              } else if (/^(align|justify|place)-content$/.test(p) && o(f)) t.warn("IE does not support ".concat(f.prop, " on grid containers"), {
                node: f
              });else if (p === "display" && f.value === "contents") {
                t.warn("Please do not use display: contents; if you have grid setting enabled", {
                  node: f
                });
                return;
              } else if (f.prop === "grid-gap") {
                var _x14 = _this25.gridStatus(f, t);
                _x14 === "autoplace" && !oA(f) && !Zo(f) ? t.warn("grid-gap only works if grid-template(-areas) is being used or both rows and columns have been declared and cells have not been manually placed inside the explicit grid", {
                  node: f
                }) : (_x14 === !0 || _x14 === "no-autoplace") && !Zo(f) && t.warn("grid-gap only works if grid-template(-areas) is being used", {
                  node: f
                });
              } else if (p === "grid-auto-columns") {
                t.warn("grid-auto-columns is not supported by IE", {
                  node: f
                });
                return;
              } else if (p === "grid-auto-rows") {
                t.warn("grid-auto-rows is not supported by IE", {
                  node: f
                });
                return;
              } else if (p === "grid-auto-flow") {
                var _x15 = d.some(function (w) {
                    return w.prop === "grid-template-rows";
                  }),
                  y = d.some(function (w) {
                    return w.prop === "grid-template-columns";
                  });
                Zo(f) ? t.warn("grid-auto-flow is not supported by IE", {
                  node: f
                }) : m.includes("dense") ? t.warn("grid-auto-flow: dense is not supported by IE", {
                  node: f
                }) : !_x15 && !y && t.warn("grid-auto-flow works only if grid-template-rows and grid-template-columns are present in the same rule", {
                  node: f
                });
                return;
              } else if (m.includes("auto-fit")) {
                t.warn("auto-fit value is not supported by IE", {
                  node: f,
                  word: "auto-fit"
                });
                return;
              } else if (m.includes("auto-fill")) {
                t.warn("auto-fill value is not supported by IE", {
                  node: f,
                  word: "auto-fill"
                });
                return;
              } else p.startsWith("grid-template") && m.includes("[") && t.warn("Autoprefixer currently does not support line names. Try using grid-template-areas instead.", {
                node: f,
                word: "["
              });
              if (m.includes("radial-gradient")) if (iA.test(f.value)) t.warn("Gradient has outdated direction syntax. New syntax is like `closest-side at 0 0` instead of `0 0, closest-side`.", {
                node: f
              });else {
                var _x16 = Km(m);
                var _iterator188 = _createForOfIteratorHelper(_x16.nodes),
                  _step188;
                try {
                  for (_iterator188.s(); !(_step188 = _iterator188.n()).done;) {
                    var _y7 = _step188.value;
                    if (_y7.type === "function" && _y7.value === "radial-gradient") {
                      var _iterator189 = _createForOfIteratorHelper(_y7.nodes),
                        _step189;
                      try {
                        for (_iterator189.s(); !(_step189 = _iterator189.n()).done;) {
                          var w = _step189.value;
                          w.type === "word" && (w.value === "cover" ? t.warn("Gradient has outdated direction syntax. Replace `cover` to `farthest-corner`.", {
                            node: f
                          }) : w.value === "contain" && t.warn("Gradient has outdated direction syntax. Replace `contain` to `closest-side`.", {
                            node: f
                          }));
                        }
                      } catch (err) {
                        _iterator189.e(err);
                      } finally {
                        _iterator189.f();
                      }
                    }
                  }
                } catch (err) {
                  _iterator188.e(err);
                } finally {
                  _iterator188.f();
                }
              }
              m.includes("linear-gradient") && rA.test(m) && t.warn("Gradient has outdated direction syntax. New syntax is like `to left` instead of `right`.", {
                node: f
              });
            }
            aA.includes(f.prop) && (f.value.includes("-fill-available") || (f.value.includes("fill-available") ? t.warn("Replace fill-available to stretch, because spec had been changed", {
              node: f
            }) : f.value.includes("fill") && Km(m).nodes.some(function (y) {
              return y.type === "word" && y.value === "fill";
            }) && t.warn("Replace fill to stretch, because spec had been changed", {
              node: f
            })));
            var b;
            if (f.prop === "transition" || f.prop === "transition-property") return _this25.prefixes.transition.add(f, t);
            if (f.prop === "align-self") {
              if (_this25.displayType(f) !== "grid" && _this25.prefixes.options.flexbox !== !1 && (b = _this25.prefixes.add["align-self"], b && b.prefixes && b.process(f)), _this25.gridStatus(f, t) !== !1 && (b = _this25.prefixes.add["grid-row-align"], b && b.prefixes)) return b.process(f, t);
            } else if (f.prop === "justify-self") {
              if (_this25.gridStatus(f, t) !== !1 && (b = _this25.prefixes.add["grid-column-align"], b && b.prefixes)) return b.process(f, t);
            } else if (f.prop === "place-self") {
              if (b = _this25.prefixes.add["place-self"], b && b.prefixes && _this25.gridStatus(f, t) !== !1) return b.process(f, t);
            } else if (b = _this25.prefixes.add[f.prop], b && b.prefixes) return b.process(f, t);
          }), this.gridStatus(e, t) && tA(e, this.disabled), e.walkDecls(function (f) {
            if (_this25.disabledValue(f, t)) return;
            var d = _this25.prefixes.unprefixed(f.prop),
              p = _this25.prefixes.values("add", d);
            if (Array.isArray(p)) {
              var _iterator190 = _createForOfIteratorHelper(p),
                _step190;
              try {
                for (_iterator190.s(); !(_step190 = _iterator190.n()).done;) {
                  var m = _step190.value;
                  m.process && m.process(f, t);
                }
              } catch (err) {
                _iterator190.e(err);
              } finally {
                _iterator190.f();
              }
            }
            eA.save(_this25.prefixes, f);
          });
        }
      }, {
        key: "remove",
        value: function remove(e, t) {
          var _this26 = this;
          var r = this.prefixes.remove["@resolution"];
          e.walkAtRules(function (n, a) {
            _this26.prefixes.remove["@".concat(n.name)] ? _this26.disabled(n, t) || n.parent.removeChild(a) : n.name === "media" && n.params.includes("-resolution") && r && r.clean(n);
          });
          var _iterator191 = _createForOfIteratorHelper(this.prefixes.remove.selectors),
            _step191;
          try {
            var _loop27 = function _loop27() {
              var n = _step191.value;
              e.walkRules(function (a, s) {
                n.check(a) && (_this26.disabled(a, t) || a.parent.removeChild(s));
              });
            };
            for (_iterator191.s(); !(_step191 = _iterator191.n()).done;) {
              _loop27();
            }
          } catch (err) {
            _iterator191.e(err);
          } finally {
            _iterator191.f();
          }
          return e.walkDecls(function (n, a) {
            if (_this26.disabled(n, t)) return;
            var s = n.parent,
              o = _this26.prefixes.unprefixed(n.prop);
            if ((n.prop === "transition" || n.prop === "transition-property") && _this26.prefixes.transition.remove(n), _this26.prefixes.remove[n.prop] && _this26.prefixes.remove[n.prop].remove) {
              var _u15 = _this26.prefixes.group(n).down(function (c) {
                return _this26.prefixes.normalize(c.prop) === o;
              });
              if (o === "flex-flow" && (_u15 = !0), n.prop === "-webkit-box-orient") {
                var c = {
                  "flex-direction": !0,
                  "flex-flow": !0
                };
                if (!n.parent.some(function (f) {
                  return c[f.prop];
                })) return;
              }
              if (_u15 && !_this26.withHackValue(n)) {
                n.raw("before").includes("\n") && _this26.reduceSpaces(n), s.removeChild(a);
                return;
              }
            }
            var _iterator192 = _createForOfIteratorHelper(_this26.prefixes.values("remove", o)),
              _step192;
            try {
              for (_iterator192.s(); !(_step192 = _iterator192.n()).done;) {
                var _u16 = _step192.value;
                if (!_u16.check || !_u16.check(n.value)) continue;
                if (o = _u16.unprefixed, _this26.prefixes.group(n).down(function (f) {
                  return f.value.includes(o);
                })) {
                  s.removeChild(a);
                  return;
                }
              }
            } catch (err) {
              _iterator192.e(err);
            } finally {
              _iterator192.f();
            }
          });
        }
      }, {
        key: "withHackValue",
        value: function withHackValue(e) {
          return e.prop === "-webkit-background-clip" && e.value === "text";
        }
      }, {
        key: "disabledValue",
        value: function disabledValue(e, t) {
          return this.gridStatus(e, t) === !1 && e.type === "decl" && e.prop === "display" && e.value.includes("grid") || this.prefixes.options.flexbox === !1 && e.type === "decl" && e.prop === "display" && e.value.includes("flex") || e.type === "decl" && e.prop === "content" ? !0 : this.disabled(e, t);
        }
      }, {
        key: "disabledDecl",
        value: function disabledDecl(e, t) {
          if (this.gridStatus(e, t) === !1 && e.type === "decl" && (e.prop.includes("grid") || e.prop === "justify-items")) return !0;
          if (this.prefixes.options.flexbox === !1 && e.type === "decl") {
            var r = ["order", "justify-content", "align-items", "align-content"];
            if (e.prop.includes("flex") || r.includes(e.prop)) return !0;
          }
          return this.disabled(e, t);
        }
      }, {
        key: "disabled",
        value: function disabled(e, t) {
          if (!e) return !1;
          if (e._autoprefixerDisabled !== void 0) return e._autoprefixerDisabled;
          if (e.parent) {
            var n = e.prev();
            if (n && n.type === "comment" && nA.test(n.text)) return e._autoprefixerDisabled = !0, e._autoprefixerSelfDisabled = !0, !0;
          }
          var r = null;
          if (e.nodes) {
            var _n19;
            e.each(function (a) {
              a.type === "comment" && /(!\s*)?autoprefixer:\s*(off|on)/i.test(a.text) && (typeof _n19 != "undefined" ? t.warn("Second Autoprefixer control comment was ignored. Autoprefixer applies control comment to whole block, not to next rules.", {
                node: a
              }) : _n19 = /on/i.test(a.text));
            }), _n19 !== void 0 && (r = !_n19);
          }
          if (!e.nodes || r === null) if (e.parent) {
            var _n20 = this.disabled(e.parent, t);
            e.parent._autoprefixerSelfDisabled === !0 ? r = !1 : r = _n20;
          } else r = !1;
          return e._autoprefixerDisabled = r, r;
        }
      }, {
        key: "reduceSpaces",
        value: function reduceSpaces(e) {
          var t = !1;
          if (this.prefixes.group(e).up(function () {
            return t = !0, !0;
          }), t) return;
          var r = e.raw("before").split("\n"),
            n = r[r.length - 1].length,
            a = !1;
          this.prefixes.group(e).down(function (s) {
            r = s.raw("before").split("\n");
            var o = r.length - 1;
            r[o].length > n && (a === !1 && (a = r[o].length - n), r[o] = r[o].slice(0, -a), s.raws.before = r.join("\n"));
          });
        }
      }, {
        key: "displayType",
        value: function displayType(e) {
          var _iterator193 = _createForOfIteratorHelper(e.parent.nodes),
            _step193;
          try {
            for (_iterator193.s(); !(_step193 = _iterator193.n()).done;) {
              var t = _step193.value;
              if (t.prop === "display") {
                if (t.value.includes("flex")) return "flex";
                if (t.value.includes("grid")) return "grid";
              }
            }
          } catch (err) {
            _iterator193.e(err);
          } finally {
            _iterator193.f();
          }
          return !1;
        }
      }, {
        key: "gridStatus",
        value: function gridStatus(e, t) {
          if (!e) return !1;
          if (e._autoprefixerGridStatus !== void 0) return e._autoprefixerGridStatus;
          var r = null;
          if (e.nodes) {
            var n;
            e.each(function (a) {
              if (a.type === "comment" && sA.test(a.text)) {
                var s = /:\s*autoplace/i.test(a.text),
                  o = /no-autoplace/i.test(a.text);
                typeof n != "undefined" ? t.warn("Second Autoprefixer grid control comment was ignored. Autoprefixer applies control comments to the whole block, not to the next rules.", {
                  node: a
                }) : s ? n = "autoplace" : o ? n = !0 : n = /on/i.test(a.text);
              }
            }), n !== void 0 && (r = n);
          }
          if (e.type === "atrule" && e.name === "supports") {
            var _n21 = e.params;
            _n21.includes("grid") && _n21.includes("auto") && (r = !1);
          }
          if (!e.nodes || r === null) if (e.parent) {
            var _n22 = this.gridStatus(e.parent, t);
            e.parent._autoprefixerSelfDisabled === !0 ? r = !1 : r = _n22;
          } else typeof this.prefixes.options.grid != "undefined" ? r = this.prefixes.options.grid : typeof h.env.AUTOPREFIXER_GRID != "undefined" ? h.env.AUTOPREFIXER_GRID === "autoplace" ? r = "autoplace" : r = !0 : r = !1;
          return e._autoprefixerGridStatus = r, r;
        }
      }]);
    }();
    eg.exports = Zm;
  });
  var rg = v(function (w4, tg) {
    l();
    tg.exports = {
      A: {
        A: {
          "2": "K E F G A B JC"
        },
        B: {
          "1": "C L M H N D O P Q R S T U V W X Y Z a b c d e f g h i j n o p q r s t u v w x y z I"
        },
        C: {
          "1": "2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB 0B dB 1B eB fB gB hB iB jB kB lB mB nB oB m pB qB rB sB tB P Q R 2B S T U V W X Y Z a b c d e f g h i j n o p q r s t u v w x y z I uB 3B 4B",
          "2": "0 1 KC zB J K E F G A B C L M H N D O k l LC MC"
        },
        D: {
          "1": "8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB 0B dB 1B eB fB gB hB iB jB kB lB mB nB oB m pB qB rB sB tB P Q R S T U V W X Y Z a b c d e f g h i j n o p q r s t u v w x y z I uB 3B 4B",
          "2": "0 1 2 3 4 5 6 7 J K E F G A B C L M H N D O k l"
        },
        E: {
          "1": "G A B C L M H D RC 6B vB wB 7B SC TC 8B 9B xB AC yB BC CC DC EC FC GC UC",
          "2": "0 J K E F NC 5B OC PC QC"
        },
        F: {
          "1": "1 2 3 4 5 6 7 8 9 H N D O k l AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB oB m pB qB rB sB tB P Q R 2B S T U V W X Y Z a b c d e f g h i j wB",
          "2": "G B C VC WC XC YC vB HC ZC"
        },
        G: {
          "1": "D fC gC hC iC jC kC lC mC nC oC pC qC rC sC tC 8B 9B xB AC yB BC CC DC EC FC GC",
          "2": "F 5B aC IC bC cC dC eC"
        },
        H: {
          "1": "uC"
        },
        I: {
          "1": "I zC 0C",
          "2": "zB J vC wC xC yC IC"
        },
        J: {
          "2": "E A"
        },
        K: {
          "1": "m",
          "2": "A B C vB HC wB"
        },
        L: {
          "1": "I"
        },
        M: {
          "1": "uB"
        },
        N: {
          "2": "A B"
        },
        O: {
          "1": "xB"
        },
        P: {
          "1": "J k l 1C 2C 3C 4C 5C 6B 6C 7C 8C 9C AD yB BD CD DD"
        },
        Q: {
          "1": "7B"
        },
        R: {
          "1": "ED"
        },
        S: {
          "1": "FD GD"
        }
      },
      B: 4,
      C: "CSS Feature Queries"
    };
  });
  var ag = v(function (b4, sg) {
    l();
    function ig(i) {
      return i[i.length - 1];
    }
    var ng = {
      parse: function parse(i) {
        var e = [""],
          t = [e];
        var _iterator194 = _createForOfIteratorHelper(i),
          _step194;
        try {
          for (_iterator194.s(); !(_step194 = _iterator194.n()).done;) {
            var r = _step194.value;
            if (r === "(") {
              e = [""], ig(t).push(e), t.push(e);
              continue;
            }
            if (r === ")") {
              t.pop(), e = ig(t), e.push("");
              continue;
            }
            e[e.length - 1] += r;
          }
        } catch (err) {
          _iterator194.e(err);
        } finally {
          _iterator194.f();
        }
        return t[0];
      },
      stringify: function stringify(i) {
        var e = "";
        var _iterator195 = _createForOfIteratorHelper(i),
          _step195;
        try {
          for (_iterator195.s(); !(_step195 = _iterator195.n()).done;) {
            var t = _step195.value;
            if (_typeof(t) == "object") {
              e += "(".concat(ng.stringify(t), ")");
              continue;
            }
            e += t;
          }
        } catch (err) {
          _iterator195.e(err);
        } finally {
          _iterator195.f();
        }
        return e;
      }
    };
    sg.exports = ng;
  });
  var cg = v(function (v4, fg) {
    l();
    var lA = rg(),
      _ref337 = ($n(), Ln),
      uA = _ref337.feature,
      _ge4 = ge(),
      fA = _ge4.parse,
      cA = dt(),
      tl = ag(),
      pA = ke(),
      dA = le(),
      og = uA(lA),
      lg = [];
    for (var i in og.stats) {
      var e = og.stats[i];
      for (var t in e) {
        var r = e[t];
        /y/.test(r) && lg.push(i + " " + t);
      }
    }
    var ug = /*#__PURE__*/function () {
      function ug(e, t) {
        _classCallCheck(this, ug);
        this.Prefixes = e, this.all = t;
      }
      return _createClass(ug, [{
        key: "prefixer",
        value: function prefixer() {
          if (this.prefixerCache) return this.prefixerCache;
          var e = this.all.browsers.selected.filter(function (r) {
              return lg.includes(r);
            }),
            t = new cA(this.all.browsers.data, e, this.all.options);
          return this.prefixerCache = new this.Prefixes(this.all.data, t, this.all.options), this.prefixerCache;
        }
      }, {
        key: "parse",
        value: function parse(e) {
          var t = e.split(":"),
            r = t[0],
            n = t[1];
          return n || (n = ""), [r.trim(), n.trim()];
        }
      }, {
        key: "virtual",
        value: function virtual(e) {
          var _this$parse = this.parse(e),
            _this$parse2 = _slicedToArray(_this$parse, 2),
            t = _this$parse2[0],
            r = _this$parse2[1],
            n = fA("a{}").first;
          return n.append({
            prop: t,
            value: r,
            raws: {
              before: ""
            }
          }), n;
        }
      }, {
        key: "prefixed",
        value: function prefixed(e) {
          var t = this.virtual(e);
          if (this.disabled(t.first)) return t.nodes;
          var r = {
              warn: function warn() {
                return null;
              }
            },
            n = this.prefixer().add[t.first.prop];
          n && n.process && n.process(t.first, r);
          var _iterator196 = _createForOfIteratorHelper(t.nodes),
            _step196;
          try {
            for (_iterator196.s(); !(_step196 = _iterator196.n()).done;) {
              var a = _step196.value;
              var _iterator197 = _createForOfIteratorHelper(this.prefixer().values("add", t.first.prop)),
                _step197;
              try {
                for (_iterator197.s(); !(_step197 = _iterator197.n()).done;) {
                  var s = _step197.value;
                  s.process(a);
                }
              } catch (err) {
                _iterator197.e(err);
              } finally {
                _iterator197.f();
              }
              pA.save(this.all, a);
            }
          } catch (err) {
            _iterator196.e(err);
          } finally {
            _iterator196.f();
          }
          return t.nodes;
        }
      }, {
        key: "isNot",
        value: function isNot(e) {
          return typeof e == "string" && /not\s*/i.test(e);
        }
      }, {
        key: "isOr",
        value: function isOr(e) {
          return typeof e == "string" && /\s*or\s*/i.test(e);
        }
      }, {
        key: "isProp",
        value: function isProp(e) {
          return _typeof(e) == "object" && e.length === 1 && typeof e[0] == "string";
        }
      }, {
        key: "isHack",
        value: function isHack(e, t) {
          return !new RegExp("(\\(|\\s)".concat(dA.escapeRegexp(t), ":")).test(e);
        }
      }, {
        key: "toRemove",
        value: function toRemove(e, t) {
          var _this$parse3 = this.parse(e),
            _this$parse4 = _slicedToArray(_this$parse3, 2),
            r = _this$parse4[0],
            n = _this$parse4[1],
            a = this.all.unprefixed(r),
            s = this.all.cleaner();
          if (s.remove[r] && s.remove[r].remove && !this.isHack(t, a)) return !0;
          var _iterator198 = _createForOfIteratorHelper(s.values("remove", a)),
            _step198;
          try {
            for (_iterator198.s(); !(_step198 = _iterator198.n()).done;) {
              var o = _step198.value;
              if (o.check(n)) return !0;
            }
          } catch (err) {
            _iterator198.e(err);
          } finally {
            _iterator198.f();
          }
          return !1;
        }
      }, {
        key: "remove",
        value: function remove(e, t) {
          var r = 0;
          for (; r < e.length;) {
            if (!this.isNot(e[r - 1]) && this.isProp(e[r]) && this.isOr(e[r + 1])) {
              if (this.toRemove(e[r][0], t)) {
                e.splice(r, 2);
                continue;
              }
              r += 2;
              continue;
            }
            _typeof(e[r]) == "object" && (e[r] = this.remove(e[r], t)), r += 1;
          }
          return e;
        }
      }, {
        key: "cleanBrackets",
        value: function cleanBrackets(e) {
          var _this27 = this;
          return e.map(function (t) {
            return _typeof(t) != "object" ? t : t.length === 1 && _typeof(t[0]) == "object" ? _this27.cleanBrackets(t[0]) : _this27.cleanBrackets(t);
          });
        }
      }, {
        key: "convert",
        value: function convert(e) {
          var t = [""];
          var _iterator199 = _createForOfIteratorHelper(e),
            _step199;
          try {
            for (_iterator199.s(); !(_step199 = _iterator199.n()).done;) {
              var _r16 = _step199.value;
              t.push(["".concat(_r16.prop, ": ").concat(_r16.value)]), t.push(" or ");
            }
          } catch (err) {
            _iterator199.e(err);
          } finally {
            _iterator199.f();
          }
          return t[t.length - 1] = "", t;
        }
      }, {
        key: "normalize",
        value: function normalize(e) {
          var _this28 = this;
          if (_typeof(e) != "object") return e;
          if (e = e.filter(function (t) {
            return t !== "";
          }), typeof e[0] == "string") {
            var _t12 = e[0].trim();
            if (_t12.includes(":") || _t12 === "selector" || _t12 === "not selector") return [tl.stringify(e)];
          }
          return e.map(function (t) {
            return _this28.normalize(t);
          });
        }
      }, {
        key: "add",
        value: function add(e, t) {
          var _this29 = this;
          return e.map(function (r) {
            if (_this29.isProp(r)) {
              var n = _this29.prefixed(r[0]);
              return n.length > 1 ? _this29.convert(n) : r;
            }
            return _typeof(r) == "object" ? _this29.add(r, t) : r;
          });
        }
      }, {
        key: "process",
        value: function process(e) {
          var t = tl.parse(e.params);
          t = this.normalize(t), t = this.remove(t, e.params), t = this.add(t, e.params), t = this.cleanBrackets(t), e.params = tl.stringify(t);
        }
      }, {
        key: "disabled",
        value: function disabled(e) {
          if (!this.all.options.grid && (e.prop === "display" && e.value.includes("grid") || e.prop.includes("grid") || e.prop === "justify-items")) return !0;
          if (this.all.options.flexbox === !1) {
            if (e.prop === "display" && e.value.includes("flex")) return !0;
            var _t13 = ["order", "justify-content", "align-items", "align-content"];
            if (e.prop.includes("flex") || _t13.includes(e.prop)) return !0;
          }
          return !1;
        }
      }]);
    }();
    fg.exports = ug;
  });
  var hg = v(function (x4, dg) {
    l();
    var pg = /*#__PURE__*/function () {
      function pg(e, t) {
        _classCallCheck(this, pg);
        this.prefix = t, this.prefixed = e.prefixed(this.prefix), this.regexp = e.regexp(this.prefix), this.prefixeds = e.possible().map(function (r) {
          return [e.prefixed(r), e.regexp(r)];
        }), this.unprefixed = e.name, this.nameRegexp = e.regexp();
      }
      return _createClass(pg, [{
        key: "isHack",
        value: function isHack(e) {
          var t = e.parent.index(e) + 1,
            r = e.parent.nodes;
          for (; t < r.length;) {
            var n = r[t].selector;
            if (!n) return !0;
            if (n.includes(this.unprefixed) && n.match(this.nameRegexp)) return !1;
            var a = !1;
            var _iterator200 = _createForOfIteratorHelper(this.prefixeds),
              _step200;
            try {
              for (_iterator200.s(); !(_step200 = _iterator200.n()).done;) {
                var _step200$value = _slicedToArray(_step200.value, 2),
                  s = _step200$value[0],
                  o = _step200$value[1];
                if (n.includes(s) && n.match(o)) {
                  a = !0;
                  break;
                }
              }
            } catch (err) {
              _iterator200.e(err);
            } finally {
              _iterator200.f();
            }
            if (!a) return !0;
            t += 1;
          }
          return !0;
        }
      }, {
        key: "check",
        value: function check(e) {
          return !(!e.selector.includes(this.prefixed) || !e.selector.match(this.regexp) || this.isHack(e));
        }
      }]);
    }();
    dg.exports = pg;
  });
  var Yt = v(function (k4, gg) {
    l();
    var _ge5 = ge(),
      hA = _ge5.list,
      mA = hg(),
      gA = Wt(),
      yA = dt(),
      wA = le(),
      mg = /*#__PURE__*/function (_gA) {
        function mg(e, t, r) {
          var _this30;
          _classCallCheck(this, mg);
          _this30 = _callSuper(this, mg, [e, t, r]);
          _this30.regexpCache = new Map();
          return _this30;
        }
        _inherits(mg, _gA);
        return _createClass(mg, [{
          key: "check",
          value: function check(e) {
            return e.selector.includes(this.name) ? !!e.selector.match(this.regexp()) : !1;
          }
        }, {
          key: "prefixed",
          value: function prefixed(e) {
            return this.name.replace(/^(\W*)/, "$1".concat(e));
          }
        }, {
          key: "regexp",
          value: function regexp(e) {
            if (!this.regexpCache.has(e)) {
              var t = e ? this.prefixed(e) : this.name;
              this.regexpCache.set(e, new RegExp("(^|[^:\"'=])".concat(wA.escapeRegexp(t)), "gi"));
            }
            return this.regexpCache.get(e);
          }
        }, {
          key: "possible",
          value: function possible() {
            return yA.prefixes();
          }
        }, {
          key: "prefixeds",
          value: function prefixeds(e) {
            var _this31 = this;
            if (e._autoprefixerPrefixeds) {
              if (e._autoprefixerPrefixeds[this.name]) return e._autoprefixerPrefixeds;
            } else e._autoprefixerPrefixeds = {};
            var t = {};
            if (e.selector.includes(",")) {
              var n = hA.comma(e.selector).filter(function (a) {
                return a.includes(_this31.name);
              });
              var _iterator201 = _createForOfIteratorHelper(this.possible()),
                _step201;
              try {
                var _loop28 = function _loop28() {
                  var a = _step201.value;
                  t[a] = n.map(function (s) {
                    return _this31.replace(s, a);
                  }).join(", ");
                };
                for (_iterator201.s(); !(_step201 = _iterator201.n()).done;) {
                  _loop28();
                }
              } catch (err) {
                _iterator201.e(err);
              } finally {
                _iterator201.f();
              }
            } else {
              var _iterator202 = _createForOfIteratorHelper(this.possible()),
                _step202;
              try {
                for (_iterator202.s(); !(_step202 = _iterator202.n()).done;) {
                  var r = _step202.value;
                  t[r] = this.replace(e.selector, r);
                }
              } catch (err) {
                _iterator202.e(err);
              } finally {
                _iterator202.f();
              }
            }
            return e._autoprefixerPrefixeds[this.name] = t, e._autoprefixerPrefixeds;
          }
        }, {
          key: "already",
          value: function already(e, t, r) {
            var n = e.parent.index(e) - 1;
            for (; n >= 0;) {
              var a = e.parent.nodes[n];
              if (a.type !== "rule") return !1;
              var s = !1;
              for (var o in t[this.name]) {
                var _u17 = t[this.name][o];
                if (a.selector === _u17) {
                  if (r === o) return !0;
                  s = !0;
                  break;
                }
              }
              if (!s) return !1;
              n -= 1;
            }
            return !1;
          }
        }, {
          key: "replace",
          value: function replace(e, t) {
            return e.replace(this.regexp(), "$1".concat(this.prefixed(t)));
          }
        }, {
          key: "add",
          value: function add(e, t) {
            var r = this.prefixeds(e);
            if (this.already(e, r, t)) return;
            var n = this.clone(e, {
              selector: r[this.name][t]
            });
            e.parent.insertBefore(e, n);
          }
        }, {
          key: "old",
          value: function old(e) {
            return new mA(this, e);
          }
        }]);
      }(gA);
    gg.exports = mg;
  });
  var bg = v(function (S4, wg) {
    l();
    var bA = Wt(),
      yg = /*#__PURE__*/function (_bA) {
        function yg() {
          _classCallCheck(this, yg);
          return _callSuper(this, yg, arguments);
        }
        _inherits(yg, _bA);
        return _createClass(yg, [{
          key: "add",
          value: function add(e, t) {
            var r = t + e.name;
            if (e.parent.some(function (s) {
              return s.name === r && s.params === e.params;
            })) return;
            var a = this.clone(e, {
              name: r
            });
            return e.parent.insertBefore(e, a);
          }
        }, {
          key: "process",
          value: function process(e) {
            var t = this.parentPrefix(e);
            var _iterator203 = _createForOfIteratorHelper(this.prefixes),
              _step203;
            try {
              for (_iterator203.s(); !(_step203 = _iterator203.n()).done;) {
                var r = _step203.value;
                (!t || t === r) && this.add(e, r);
              }
            } catch (err) {
              _iterator203.e(err);
            } finally {
              _iterator203.f();
            }
          }
        }]);
      }(bA);
    wg.exports = yg;
  });
  var xg = v(function (C4, vg) {
    l();
    var vA = Yt(),
      rl = /*#__PURE__*/function (_vA) {
        function rl() {
          _classCallCheck(this, rl);
          return _callSuper(this, rl, arguments);
        }
        _inherits(rl, _vA);
        return _createClass(rl, [{
          key: "prefixed",
          value: function prefixed(e) {
            return e === "-webkit-" ? ":-webkit-full-screen" : e === "-moz-" ? ":-moz-full-screen" : ":".concat(e, "fullscreen");
          }
        }]);
      }(vA);
    rl.names = [":fullscreen"];
    vg.exports = rl;
  });
  var Sg = v(function (A4, kg) {
    l();
    var xA = Yt(),
      il = /*#__PURE__*/function (_xA) {
        function il() {
          _classCallCheck(this, il);
          return _callSuper(this, il, arguments);
        }
        _inherits(il, _xA);
        return _createClass(il, [{
          key: "possible",
          value: function possible() {
            return _get(_getPrototypeOf(il.prototype), "possible", this).call(this).concat(["-moz- old", "-ms- old"]);
          }
        }, {
          key: "prefixed",
          value: function prefixed(e) {
            return e === "-webkit-" ? "::-webkit-input-placeholder" : e === "-ms-" ? "::-ms-input-placeholder" : e === "-ms- old" ? ":-ms-input-placeholder" : e === "-moz- old" ? ":-moz-placeholder" : "::".concat(e, "placeholder");
          }
        }]);
      }(xA);
    il.names = ["::placeholder"];
    kg.exports = il;
  });
  var Ag = v(function (_4, Cg) {
    l();
    var kA = Yt(),
      nl = /*#__PURE__*/function (_kA) {
        function nl() {
          _classCallCheck(this, nl);
          return _callSuper(this, nl, arguments);
        }
        _inherits(nl, _kA);
        return _createClass(nl, [{
          key: "prefixed",
          value: function prefixed(e) {
            return e === "-ms-" ? ":-ms-input-placeholder" : ":".concat(e, "placeholder-shown");
          }
        }]);
      }(kA);
    nl.names = [":placeholder-shown"];
    Cg.exports = nl;
  });
  var Og = v(function (O4, _g) {
    l();
    var SA = Yt(),
      CA = le(),
      sl = /*#__PURE__*/function (_SA) {
        function sl(e, t, r) {
          var _this32;
          _classCallCheck(this, sl);
          _this32 = _callSuper(this, sl, [e, t, r]);
          _this32.prefixes && (_this32.prefixes = CA.uniq(_this32.prefixes.map(function (n) {
            return "-webkit-";
          })));
          return _this32;
        }
        _inherits(sl, _SA);
        return _createClass(sl, [{
          key: "prefixed",
          value: function prefixed(e) {
            return e === "-webkit-" ? "::-webkit-file-upload-button" : "::".concat(e, "file-selector-button");
          }
        }]);
      }(SA);
    sl.names = ["::file-selector-button"];
    _g.exports = sl;
  });
  var pe = v(function (E4, Eg) {
    l();
    Eg.exports = function (i) {
      var e;
      return i === "-webkit- 2009" || i === "-moz-" ? e = 2009 : i === "-ms-" ? e = 2012 : i === "-webkit-" && (e = "final"), i === "-webkit- 2009" && (i = "-webkit-"), [e, i];
    };
  });
  var Ig = v(function (T4, Dg) {
    l();
    var Tg = ge().list,
      Pg = pe(),
      AA = M(),
      Qt = /*#__PURE__*/function (_AA) {
        function Qt() {
          _classCallCheck(this, Qt);
          return _callSuper(this, Qt, arguments);
        }
        _inherits(Qt, _AA);
        return _createClass(Qt, [{
          key: "prefixed",
          value: function prefixed(e, t) {
            var _Pg, _Pg2;
            var r;
            return (_Pg = Pg(t), _Pg2 = _slicedToArray(_Pg, 2), r = _Pg2[0], t = _Pg2[1]), r === 2009 ? t + "box-flex" : _get(_getPrototypeOf(Qt.prototype), "prefixed", this).call(this, e, t);
          }
        }, {
          key: "normalize",
          value: function normalize() {
            return "flex";
          }
        }, {
          key: "set",
          value: function set(e, t) {
            var r = Pg(t)[0];
            if (r === 2009) return e.value = Tg.space(e.value)[0], e.value = Qt.oldValues[e.value] || e.value, _get(_getPrototypeOf(Qt.prototype), "set", this).call(this, e, t);
            if (r === 2012) {
              var n = Tg.space(e.value);
              n.length === 3 && n[2] === "0" && (e.value = n.slice(0, 2).concat("0px").join(" "));
            }
            return _get(_getPrototypeOf(Qt.prototype), "set", this).call(this, e, t);
          }
        }]);
      }(AA);
    Qt.names = ["flex", "box-flex"];
    Qt.oldValues = {
      auto: "1",
      none: "0"
    };
    Dg.exports = Qt;
  });
  var Mg = v(function (P4, Rg) {
    l();
    var qg = pe(),
      _A = M(),
      al = /*#__PURE__*/function (_A2) {
        function al() {
          _classCallCheck(this, al);
          return _callSuper(this, al, arguments);
        }
        _inherits(al, _A2);
        return _createClass(al, [{
          key: "prefixed",
          value: function prefixed(e, t) {
            var _qg, _qg2;
            var r;
            return (_qg = qg(t), _qg2 = _slicedToArray(_qg, 2), r = _qg2[0], t = _qg2[1]), r === 2009 ? t + "box-ordinal-group" : r === 2012 ? t + "flex-order" : _get(_getPrototypeOf(al.prototype), "prefixed", this).call(this, e, t);
          }
        }, {
          key: "normalize",
          value: function normalize() {
            return "order";
          }
        }, {
          key: "set",
          value: function set(e, t) {
            return qg(t)[0] === 2009 && /\d/.test(e.value) ? (e.value = (parseInt(e.value) + 1).toString(), _get(_getPrototypeOf(al.prototype), "set", this).call(this, e, t)) : _get(_getPrototypeOf(al.prototype), "set", this).call(this, e, t);
          }
        }]);
      }(_A);
    al.names = ["order", "flex-order", "box-ordinal-group"];
    Rg.exports = al;
  });
  var Fg = v(function (D4, Bg) {
    l();
    var OA = M(),
      ol = /*#__PURE__*/function (_OA) {
        function ol() {
          _classCallCheck(this, ol);
          return _callSuper(this, ol, arguments);
        }
        _inherits(ol, _OA);
        return _createClass(ol, [{
          key: "check",
          value: function check(e) {
            var t = e.value;
            return !t.toLowerCase().includes("alpha(") && !t.includes("DXImageTransform.Microsoft") && !t.includes("data:image/svg+xml");
          }
        }]);
      }(OA);
    ol.names = ["filter"];
    Bg.exports = ol;
  });
  var Lg = v(function (I4, Ng) {
    l();
    var EA = M(),
      ll = /*#__PURE__*/function (_EA) {
        function ll() {
          _classCallCheck(this, ll);
          return _callSuper(this, ll, arguments);
        }
        _inherits(ll, _EA);
        return _createClass(ll, [{
          key: "insert",
          value: function insert(e, t, r, n) {
            if (t !== "-ms-") return _get(_getPrototypeOf(ll.prototype), "insert", this).call(this, e, t, r);
            var a = this.clone(e),
              s = e.prop.replace(/end$/, "start"),
              o = t + e.prop.replace(/end$/, "span");
            if (!e.parent.some(function (u) {
              return u.prop === o;
            })) {
              if (a.prop = o, e.value.includes("span")) a.value = e.value.replace(/span\s/i, "");else {
                var _u18;
                if (e.parent.walkDecls(s, function (c) {
                  _u18 = c;
                }), _u18) {
                  var c = Number(e.value) - Number(_u18.value) + "";
                  a.value = c;
                } else e.warn(n, "Can not prefix ".concat(e.prop, " (").concat(s, " is not found)"));
              }
              e.cloneBefore(a);
            }
          }
        }]);
      }(EA);
    ll.names = ["grid-row-end", "grid-column-end"];
    Ng.exports = ll;
  });
  var jg = v(function (q4, $g) {
    l();
    var TA = M(),
      ul = /*#__PURE__*/function (_TA) {
        function ul() {
          _classCallCheck(this, ul);
          return _callSuper(this, ul, arguments);
        }
        _inherits(ul, _TA);
        return _createClass(ul, [{
          key: "check",
          value: function check(e) {
            return !e.value.split(/\s+/).some(function (t) {
              var r = t.toLowerCase();
              return r === "reverse" || r === "alternate-reverse";
            });
          }
        }]);
      }(TA);
    ul.names = ["animation", "animation-direction"];
    $g.exports = ul;
  });
  var Vg = v(function (R4, zg) {
    l();
    var PA = pe(),
      DA = M(),
      fl = /*#__PURE__*/function (_DA) {
        function fl() {
          _classCallCheck(this, fl);
          return _callSuper(this, fl, arguments);
        }
        _inherits(fl, _DA);
        return _createClass(fl, [{
          key: "insert",
          value: function insert(e, t, r) {
            var _PA, _PA2;
            var n;
            if ((_PA = PA(t), _PA2 = _slicedToArray(_PA, 2), n = _PA2[0], t = _PA2[1]), n !== 2009) return _get(_getPrototypeOf(fl.prototype), "insert", this).call(this, e, t, r);
            var a = e.value.split(/\s+/).filter(function (d) {
              return d !== "wrap" && d !== "nowrap" && "wrap-reverse";
            });
            if (a.length === 0 || e.parent.some(function (d) {
              return d.prop === t + "box-orient" || d.prop === t + "box-direction";
            })) return;
            var o = a[0],
              u = o.includes("row") ? "horizontal" : "vertical",
              c = o.includes("reverse") ? "reverse" : "normal",
              f = this.clone(e);
            return f.prop = t + "box-orient", f.value = u, this.needCascade(e) && (f.raws.before = this.calcBefore(r, e, t)), e.parent.insertBefore(e, f), f = this.clone(e), f.prop = t + "box-direction", f.value = c, this.needCascade(e) && (f.raws.before = this.calcBefore(r, e, t)), e.parent.insertBefore(e, f);
          }
        }]);
      }(DA);
    fl.names = ["flex-flow", "box-direction", "box-orient"];
    zg.exports = fl;
  });
  var Wg = v(function (M4, Ug) {
    l();
    var IA = pe(),
      qA = M(),
      cl = /*#__PURE__*/function (_qA) {
        function cl() {
          _classCallCheck(this, cl);
          return _callSuper(this, cl, arguments);
        }
        _inherits(cl, _qA);
        return _createClass(cl, [{
          key: "normalize",
          value: function normalize() {
            return "flex";
          }
        }, {
          key: "prefixed",
          value: function prefixed(e, t) {
            var _IA, _IA2;
            var r;
            return (_IA = IA(t), _IA2 = _slicedToArray(_IA, 2), r = _IA2[0], t = _IA2[1]), r === 2009 ? t + "box-flex" : r === 2012 ? t + "flex-positive" : _get(_getPrototypeOf(cl.prototype), "prefixed", this).call(this, e, t);
          }
        }]);
      }(qA);
    cl.names = ["flex-grow", "flex-positive"];
    Ug.exports = cl;
  });
  var Hg = v(function (B4, Gg) {
    l();
    var RA = pe(),
      MA = M(),
      pl = /*#__PURE__*/function (_MA) {
        function pl() {
          _classCallCheck(this, pl);
          return _callSuper(this, pl, arguments);
        }
        _inherits(pl, _MA);
        return _createClass(pl, [{
          key: "set",
          value: function set(e, t) {
            if (RA(t)[0] !== 2009) return _get(_getPrototypeOf(pl.prototype), "set", this).call(this, e, t);
          }
        }]);
      }(MA);
    pl.names = ["flex-wrap"];
    Gg.exports = pl;
  });
  var Qg = v(function (F4, Yg) {
    l();
    var BA = M(),
      Jt = mt(),
      dl = /*#__PURE__*/function (_BA) {
        function dl() {
          _classCallCheck(this, dl);
          return _callSuper(this, dl, arguments);
        }
        _inherits(dl, _BA);
        return _createClass(dl, [{
          key: "insert",
          value: function insert(e, t, r, n) {
            if (t !== "-ms-") return _get(_getPrototypeOf(dl.prototype), "insert", this).call(this, e, t, r);
            var a = Jt.parse(e),
              _Jt$translate = Jt.translate(a, 0, 2),
              _Jt$translate2 = _slicedToArray(_Jt$translate, 2),
              s = _Jt$translate2[0],
              o = _Jt$translate2[1],
              _Jt$translate3 = Jt.translate(a, 1, 3),
              _Jt$translate4 = _slicedToArray(_Jt$translate3, 2),
              u = _Jt$translate4[0],
              c = _Jt$translate4[1];
            [["grid-row", s], ["grid-row-span", o], ["grid-column", u], ["grid-column-span", c]].forEach(function (_ref338) {
              var _ref339 = _slicedToArray(_ref338, 2),
                f = _ref339[0],
                d = _ref339[1];
              Jt.insertDecl(e, f, d);
            }), Jt.warnTemplateSelectorNotFound(e, n), Jt.warnIfGridRowColumnExists(e, n);
          }
        }]);
      }(BA);
    dl.names = ["grid-area"];
    Yg.exports = dl;
  });
  var Xg = v(function (N4, Jg) {
    l();
    var FA = M(),
      ni = mt(),
      hl = /*#__PURE__*/function (_FA) {
        function hl() {
          _classCallCheck(this, hl);
          return _callSuper(this, hl, arguments);
        }
        _inherits(hl, _FA);
        return _createClass(hl, [{
          key: "insert",
          value: function insert(e, t, r) {
            if (t !== "-ms-") return _get(_getPrototypeOf(hl.prototype), "insert", this).call(this, e, t, r);
            if (e.parent.some(function (s) {
              return s.prop === "-ms-grid-row-align";
            })) return;
            var _ni$parse = ni.parse(e),
              _ni$parse2 = _slicedToArray(_ni$parse, 1),
              _ni$parse2$ = _slicedToArray(_ni$parse2[0], 2),
              n = _ni$parse2$[0],
              a = _ni$parse2$[1];
            a ? (ni.insertDecl(e, "grid-row-align", n), ni.insertDecl(e, "grid-column-align", a)) : (ni.insertDecl(e, "grid-row-align", n), ni.insertDecl(e, "grid-column-align", n));
          }
        }]);
      }(FA);
    hl.names = ["place-self"];
    Jg.exports = hl;
  });
  var Zg = v(function (L4, Kg) {
    l();
    var NA = M(),
      ml = /*#__PURE__*/function (_NA) {
        function ml() {
          _classCallCheck(this, ml);
          return _callSuper(this, ml, arguments);
        }
        _inherits(ml, _NA);
        return _createClass(ml, [{
          key: "check",
          value: function check(e) {
            var t = e.value;
            return !t.includes("/") || t.includes("span");
          }
        }, {
          key: "normalize",
          value: function normalize(e) {
            return e.replace("-start", "");
          }
        }, {
          key: "prefixed",
          value: function prefixed(e, t) {
            var r = _get(_getPrototypeOf(ml.prototype), "prefixed", this).call(this, e, t);
            return t === "-ms-" && (r = r.replace("-start", "")), r;
          }
        }]);
      }(NA);
    ml.names = ["grid-row-start", "grid-column-start"];
    Kg.exports = ml;
  });
  var ry = v(function ($4, ty) {
    l();
    var ey = pe(),
      LA = M(),
      Xt = /*#__PURE__*/function (_LA) {
        function Xt() {
          _classCallCheck(this, Xt);
          return _callSuper(this, Xt, arguments);
        }
        _inherits(Xt, _LA);
        return _createClass(Xt, [{
          key: "check",
          value: function check(e) {
            return e.parent && !e.parent.some(function (t) {
              return t.prop && t.prop.startsWith("grid-");
            });
          }
        }, {
          key: "prefixed",
          value: function prefixed(e, t) {
            var _ey, _ey2;
            var r;
            return (_ey = ey(t), _ey2 = _slicedToArray(_ey, 2), r = _ey2[0], t = _ey2[1]), r === 2012 ? t + "flex-item-align" : _get(_getPrototypeOf(Xt.prototype), "prefixed", this).call(this, e, t);
          }
        }, {
          key: "normalize",
          value: function normalize() {
            return "align-self";
          }
        }, {
          key: "set",
          value: function set(e, t) {
            var r = ey(t)[0];
            if (r === 2012) return e.value = Xt.oldValues[e.value] || e.value, _get(_getPrototypeOf(Xt.prototype), "set", this).call(this, e, t);
            if (r === "final") return _get(_getPrototypeOf(Xt.prototype), "set", this).call(this, e, t);
          }
        }]);
      }(LA);
    Xt.names = ["align-self", "flex-item-align"];
    Xt.oldValues = {
      "flex-end": "end",
      "flex-start": "start"
    };
    ty.exports = Xt;
  });
  var ny = v(function (j4, iy) {
    l();
    var $A = M(),
      jA = le(),
      gl = /*#__PURE__*/function (_$A) {
        function gl(e, t, r) {
          var _this33;
          _classCallCheck(this, gl);
          _this33 = _callSuper(this, gl, [e, t, r]);
          _this33.prefixes && (_this33.prefixes = jA.uniq(_this33.prefixes.map(function (n) {
            return n === "-ms-" ? "-webkit-" : n;
          })));
          return _this33;
        }
        _inherits(gl, _$A);
        return _createClass(gl);
      }($A);
    gl.names = ["appearance"];
    iy.exports = gl;
  });
  var oy = v(function (z4, ay) {
    l();
    var sy = pe(),
      zA = M(),
      yl = /*#__PURE__*/function (_zA) {
        function yl() {
          _classCallCheck(this, yl);
          return _callSuper(this, yl, arguments);
        }
        _inherits(yl, _zA);
        return _createClass(yl, [{
          key: "normalize",
          value: function normalize() {
            return "flex-basis";
          }
        }, {
          key: "prefixed",
          value: function prefixed(e, t) {
            var _sy, _sy2;
            var r;
            return (_sy = sy(t), _sy2 = _slicedToArray(_sy, 2), r = _sy2[0], t = _sy2[1]), r === 2012 ? t + "flex-preferred-size" : _get(_getPrototypeOf(yl.prototype), "prefixed", this).call(this, e, t);
          }
        }, {
          key: "set",
          value: function set(e, t) {
            var _sy3, _sy4;
            var r;
            if ((_sy3 = sy(t), _sy4 = _slicedToArray(_sy3, 2), r = _sy4[0], t = _sy4[1]), r === 2012 || r === "final") return _get(_getPrototypeOf(yl.prototype), "set", this).call(this, e, t);
          }
        }]);
      }(zA);
    yl.names = ["flex-basis", "flex-preferred-size"];
    ay.exports = yl;
  });
  var uy = v(function (V4, ly) {
    l();
    var VA = M(),
      wl = /*#__PURE__*/function (_VA) {
        function wl() {
          _classCallCheck(this, wl);
          return _callSuper(this, wl, arguments);
        }
        _inherits(wl, _VA);
        return _createClass(wl, [{
          key: "normalize",
          value: function normalize() {
            return this.name.replace("box-image", "border");
          }
        }, {
          key: "prefixed",
          value: function prefixed(e, t) {
            var r = _get(_getPrototypeOf(wl.prototype), "prefixed", this).call(this, e, t);
            return t === "-webkit-" && (r = r.replace("border", "box-image")), r;
          }
        }]);
      }(VA);
    wl.names = ["mask-border", "mask-border-source", "mask-border-slice", "mask-border-width", "mask-border-outset", "mask-border-repeat", "mask-box-image", "mask-box-image-source", "mask-box-image-slice", "mask-box-image-width", "mask-box-image-outset", "mask-box-image-repeat"];
    ly.exports = wl;
  });
  var cy = v(function (U4, fy) {
    l();
    var UA = M(),
      Le = /*#__PURE__*/function (_UA) {
        function Le() {
          _classCallCheck(this, Le);
          return _callSuper(this, Le, arguments);
        }
        _inherits(Le, _UA);
        return _createClass(Le, [{
          key: "insert",
          value: function insert(e, t, r) {
            var n = e.prop === "mask-composite",
              a;
            n ? a = e.value.split(",") : a = e.value.match(Le.regexp) || [], a = a.map(function (c) {
              return c.trim();
            }).filter(function (c) {
              return c;
            });
            var s = a.length,
              o;
            if (s && (o = this.clone(e), o.value = a.map(function (c) {
              return Le.oldValues[c] || c;
            }).join(", "), a.includes("intersect") && (o.value += ", xor"), o.prop = t + "mask-composite"), n) return s ? (this.needCascade(e) && (o.raws.before = this.calcBefore(r, e, t)), e.parent.insertBefore(e, o)) : void 0;
            var u = this.clone(e);
            return u.prop = t + u.prop, s && (u.value = u.value.replace(Le.regexp, "")), this.needCascade(e) && (u.raws.before = this.calcBefore(r, e, t)), e.parent.insertBefore(e, u), s ? (this.needCascade(e) && (o.raws.before = this.calcBefore(r, e, t)), e.parent.insertBefore(e, o)) : e;
          }
        }]);
      }(UA);
    Le.names = ["mask", "mask-composite"];
    Le.oldValues = {
      add: "source-over",
      subtract: "source-out",
      intersect: "source-in",
      exclude: "xor"
    };
    Le.regexp = new RegExp("\\s+(".concat(Object.keys(Le.oldValues).join("|"), ")\\b(?!\\))\\s*(?=[,])"), "ig");
    fy.exports = Le;
  });
  var hy = v(function (W4, dy) {
    l();
    var py = pe(),
      WA = M(),
      Kt = /*#__PURE__*/function (_WA) {
        function Kt() {
          _classCallCheck(this, Kt);
          return _callSuper(this, Kt, arguments);
        }
        _inherits(Kt, _WA);
        return _createClass(Kt, [{
          key: "prefixed",
          value: function prefixed(e, t) {
            var _py, _py2;
            var r;
            return (_py = py(t), _py2 = _slicedToArray(_py, 2), r = _py2[0], t = _py2[1]), r === 2009 ? t + "box-align" : r === 2012 ? t + "flex-align" : _get(_getPrototypeOf(Kt.prototype), "prefixed", this).call(this, e, t);
          }
        }, {
          key: "normalize",
          value: function normalize() {
            return "align-items";
          }
        }, {
          key: "set",
          value: function set(e, t) {
            var r = py(t)[0];
            return (r === 2009 || r === 2012) && (e.value = Kt.oldValues[e.value] || e.value), _get(_getPrototypeOf(Kt.prototype), "set", this).call(this, e, t);
          }
        }]);
      }(WA);
    Kt.names = ["align-items", "flex-align", "box-align"];
    Kt.oldValues = {
      "flex-end": "end",
      "flex-start": "start"
    };
    dy.exports = Kt;
  });
  var gy = v(function (G4, my) {
    l();
    var GA = M(),
      bl = /*#__PURE__*/function (_GA) {
        function bl() {
          _classCallCheck(this, bl);
          return _callSuper(this, bl, arguments);
        }
        _inherits(bl, _GA);
        return _createClass(bl, [{
          key: "set",
          value: function set(e, t) {
            return t === "-ms-" && e.value === "contain" && (e.value = "element"), _get(_getPrototypeOf(bl.prototype), "set", this).call(this, e, t);
          }
        }, {
          key: "insert",
          value: function insert(e, t, r) {
            if (!(e.value === "all" && t === "-ms-")) return _get(_getPrototypeOf(bl.prototype), "insert", this).call(this, e, t, r);
          }
        }]);
      }(GA);
    bl.names = ["user-select"];
    my.exports = bl;
  });
  var by = v(function (H4, wy) {
    l();
    var yy = pe(),
      HA = M(),
      vl = /*#__PURE__*/function (_HA) {
        function vl() {
          _classCallCheck(this, vl);
          return _callSuper(this, vl, arguments);
        }
        _inherits(vl, _HA);
        return _createClass(vl, [{
          key: "normalize",
          value: function normalize() {
            return "flex-shrink";
          }
        }, {
          key: "prefixed",
          value: function prefixed(e, t) {
            var _yy, _yy2;
            var r;
            return (_yy = yy(t), _yy2 = _slicedToArray(_yy, 2), r = _yy2[0], t = _yy2[1]), r === 2012 ? t + "flex-negative" : _get(_getPrototypeOf(vl.prototype), "prefixed", this).call(this, e, t);
          }
        }, {
          key: "set",
          value: function set(e, t) {
            var _yy3, _yy4;
            var r;
            if ((_yy3 = yy(t), _yy4 = _slicedToArray(_yy3, 2), r = _yy4[0], t = _yy4[1]), r === 2012 || r === "final") return _get(_getPrototypeOf(vl.prototype), "set", this).call(this, e, t);
          }
        }]);
      }(HA);
    vl.names = ["flex-shrink", "flex-negative"];
    wy.exports = vl;
  });
  var xy = v(function (Y4, vy) {
    l();
    var YA = M(),
      xl = /*#__PURE__*/function (_YA) {
        function xl() {
          _classCallCheck(this, xl);
          return _callSuper(this, xl, arguments);
        }
        _inherits(xl, _YA);
        return _createClass(xl, [{
          key: "prefixed",
          value: function prefixed(e, t) {
            return "".concat(t, "column-").concat(e);
          }
        }, {
          key: "normalize",
          value: function normalize(e) {
            return e.includes("inside") ? "break-inside" : e.includes("before") ? "break-before" : "break-after";
          }
        }, {
          key: "set",
          value: function set(e, t) {
            return (e.prop === "break-inside" && e.value === "avoid-column" || e.value === "avoid-page") && (e.value = "avoid"), _get(_getPrototypeOf(xl.prototype), "set", this).call(this, e, t);
          }
        }, {
          key: "insert",
          value: function insert(e, t, r) {
            if (e.prop !== "break-inside") return _get(_getPrototypeOf(xl.prototype), "insert", this).call(this, e, t, r);
            if (!(/region/i.test(e.value) || /page/i.test(e.value))) return _get(_getPrototypeOf(xl.prototype), "insert", this).call(this, e, t, r);
          }
        }]);
      }(YA);
    xl.names = ["break-inside", "page-break-inside", "column-break-inside", "break-before", "page-break-before", "column-break-before", "break-after", "page-break-after", "column-break-after"];
    vy.exports = xl;
  });
  var Sy = v(function (Q4, ky) {
    l();
    var QA = M(),
      kl = /*#__PURE__*/function (_QA) {
        function kl() {
          _classCallCheck(this, kl);
          return _callSuper(this, kl, arguments);
        }
        _inherits(kl, _QA);
        return _createClass(kl, [{
          key: "prefixed",
          value: function prefixed(e, t) {
            return t + "print-color-adjust";
          }
        }, {
          key: "normalize",
          value: function normalize() {
            return "color-adjust";
          }
        }]);
      }(QA);
    kl.names = ["color-adjust", "print-color-adjust"];
    ky.exports = kl;
  });
  var Ay = v(function (J4, Cy) {
    l();
    var JA = M(),
      Zt = /*#__PURE__*/function (_JA) {
        function Zt() {
          _classCallCheck(this, Zt);
          return _callSuper(this, Zt, arguments);
        }
        _inherits(Zt, _JA);
        return _createClass(Zt, [{
          key: "insert",
          value: function insert(e, t, r) {
            if (t === "-ms-") {
              var n = this.set(this.clone(e), t);
              this.needCascade(e) && (n.raws.before = this.calcBefore(r, e, t));
              var a = "ltr";
              return e.parent.nodes.forEach(function (s) {
                s.prop === "direction" && (s.value === "rtl" || s.value === "ltr") && (a = s.value);
              }), n.value = Zt.msValues[a][e.value] || e.value, e.parent.insertBefore(e, n);
            }
            return _get(_getPrototypeOf(Zt.prototype), "insert", this).call(this, e, t, r);
          }
        }]);
      }(JA);
    Zt.names = ["writing-mode"];
    Zt.msValues = {
      ltr: {
        "horizontal-tb": "lr-tb",
        "vertical-rl": "tb-rl",
        "vertical-lr": "tb-lr"
      },
      rtl: {
        "horizontal-tb": "rl-tb",
        "vertical-rl": "bt-rl",
        "vertical-lr": "bt-lr"
      }
    };
    Cy.exports = Zt;
  });
  var Oy = v(function (X4, _y) {
    l();
    var XA = M(),
      Sl = /*#__PURE__*/function (_XA) {
        function Sl() {
          _classCallCheck(this, Sl);
          return _callSuper(this, Sl, arguments);
        }
        _inherits(Sl, _XA);
        return _createClass(Sl, [{
          key: "set",
          value: function set(e, t) {
            return e.value = e.value.replace(/\s+fill(\s)/, "$1"), _get(_getPrototypeOf(Sl.prototype), "set", this).call(this, e, t);
          }
        }]);
      }(XA);
    Sl.names = ["border-image"];
    _y.exports = Sl;
  });
  var Py = v(function (K4, Ty) {
    l();
    var Ey = pe(),
      KA = M(),
      er = /*#__PURE__*/function (_KA) {
        function er() {
          _classCallCheck(this, er);
          return _callSuper(this, er, arguments);
        }
        _inherits(er, _KA);
        return _createClass(er, [{
          key: "prefixed",
          value: function prefixed(e, t) {
            var _Ey, _Ey2;
            var r;
            return (_Ey = Ey(t), _Ey2 = _slicedToArray(_Ey, 2), r = _Ey2[0], t = _Ey2[1]), r === 2012 ? t + "flex-line-pack" : _get(_getPrototypeOf(er.prototype), "prefixed", this).call(this, e, t);
          }
        }, {
          key: "normalize",
          value: function normalize() {
            return "align-content";
          }
        }, {
          key: "set",
          value: function set(e, t) {
            var r = Ey(t)[0];
            if (r === 2012) return e.value = er.oldValues[e.value] || e.value, _get(_getPrototypeOf(er.prototype), "set", this).call(this, e, t);
            if (r === "final") return _get(_getPrototypeOf(er.prototype), "set", this).call(this, e, t);
          }
        }]);
      }(KA);
    er.names = ["align-content", "flex-line-pack"];
    er.oldValues = {
      "flex-end": "end",
      "flex-start": "start",
      "space-between": "justify",
      "space-around": "distribute"
    };
    Ty.exports = er;
  });
  var Iy = v(function (Z4, Dy) {
    l();
    var ZA = M(),
      Se = /*#__PURE__*/function (_ZA) {
        function Se() {
          _classCallCheck(this, Se);
          return _callSuper(this, Se, arguments);
        }
        _inherits(Se, _ZA);
        return _createClass(Se, [{
          key: "prefixed",
          value: function prefixed(e, t) {
            return t === "-moz-" ? t + (Se.toMozilla[e] || e) : _get(_getPrototypeOf(Se.prototype), "prefixed", this).call(this, e, t);
          }
        }, {
          key: "normalize",
          value: function normalize(e) {
            return Se.toNormal[e] || e;
          }
        }]);
      }(ZA);
    Se.names = ["border-radius"];
    Se.toMozilla = {};
    Se.toNormal = {};
    for (var _i26 = 0, _arr3 = ["top", "bottom"]; _i26 < _arr3.length; _i26++) {
      var i = _arr3[_i26];
      for (var _i27 = 0, _arr4 = ["left", "right"]; _i27 < _arr4.length; _i27++) {
        var e = _arr4[_i27];
        var t = "border-".concat(i, "-").concat(e, "-radius"),
          r = "border-radius-".concat(i).concat(e);
        Se.names.push(t), Se.names.push(r), Se.toMozilla[t] = r, Se.toNormal[r] = t;
      }
    }
    Dy.exports = Se;
  });
  var Ry = v(function (eI, qy) {
    l();
    var e_ = M(),
      Cl = /*#__PURE__*/function (_e_) {
        function Cl() {
          _classCallCheck(this, Cl);
          return _callSuper(this, Cl, arguments);
        }
        _inherits(Cl, _e_);
        return _createClass(Cl, [{
          key: "prefixed",
          value: function prefixed(e, t) {
            return e.includes("-start") ? t + e.replace("-block-start", "-before") : t + e.replace("-block-end", "-after");
          }
        }, {
          key: "normalize",
          value: function normalize(e) {
            return e.includes("-before") ? e.replace("-before", "-block-start") : e.replace("-after", "-block-end");
          }
        }]);
      }(e_);
    Cl.names = ["border-block-start", "border-block-end", "margin-block-start", "margin-block-end", "padding-block-start", "padding-block-end", "border-before", "border-after", "margin-before", "margin-after", "padding-before", "padding-after"];
    qy.exports = Cl;
  });
  var By = v(function (tI, My) {
    l();
    var t_ = M(),
      _mt = mt(),
      r_ = _mt.parseTemplate,
      i_ = _mt.warnMissedAreas,
      n_ = _mt.getGridGap,
      s_ = _mt.warnGridGap,
      a_ = _mt.inheritGridGap,
      Al = /*#__PURE__*/function (_t_) {
        function Al() {
          _classCallCheck(this, Al);
          return _callSuper(this, Al, arguments);
        }
        _inherits(Al, _t_);
        return _createClass(Al, [{
          key: "insert",
          value: function insert(e, t, r, n) {
            if (t !== "-ms-") return _get(_getPrototypeOf(Al.prototype), "insert", this).call(this, e, t, r);
            if (e.parent.some(function (m) {
              return m.prop === "-ms-grid-rows";
            })) return;
            var a = n_(e),
              s = a_(e, a),
              _r_ = r_({
                decl: e,
                gap: s || a
              }),
              o = _r_.rows,
              u = _r_.columns,
              c = _r_.areas,
              f = Object.keys(c).length > 0,
              d = Boolean(o),
              p = Boolean(u);
            return s_({
              gap: a,
              hasColumns: p,
              decl: e,
              result: n
            }), i_(c, e, n), (d && p || f) && e.cloneBefore({
              prop: "-ms-grid-rows",
              value: o,
              raws: {}
            }), p && e.cloneBefore({
              prop: "-ms-grid-columns",
              value: u,
              raws: {}
            }), e;
          }
        }]);
      }(t_);
    Al.names = ["grid-template"];
    My.exports = Al;
  });
  var Ny = v(function (rI, Fy) {
    l();
    var o_ = M(),
      _l = /*#__PURE__*/function (_o_) {
        function _l() {
          _classCallCheck(this, _l);
          return _callSuper(this, _l, arguments);
        }
        _inherits(_l, _o_);
        return _createClass(_l, [{
          key: "prefixed",
          value: function prefixed(e, t) {
            return t + e.replace("-inline", "");
          }
        }, {
          key: "normalize",
          value: function normalize(e) {
            return e.replace(/(margin|padding|border)-(start|end)/, "$1-inline-$2");
          }
        }]);
      }(o_);
    _l.names = ["border-inline-start", "border-inline-end", "margin-inline-start", "margin-inline-end", "padding-inline-start", "padding-inline-end", "border-start", "border-end", "margin-start", "margin-end", "padding-start", "padding-end"];
    Fy.exports = _l;
  });
  var $y = v(function (iI, Ly) {
    l();
    var l_ = M(),
      Ol = /*#__PURE__*/function (_l_) {
        function Ol() {
          _classCallCheck(this, Ol);
          return _callSuper(this, Ol, arguments);
        }
        _inherits(Ol, _l_);
        return _createClass(Ol, [{
          key: "check",
          value: function check(e) {
            return !e.value.includes("flex-") && e.value !== "baseline";
          }
        }, {
          key: "prefixed",
          value: function prefixed(e, t) {
            return t + "grid-row-align";
          }
        }, {
          key: "normalize",
          value: function normalize() {
            return "align-self";
          }
        }]);
      }(l_);
    Ol.names = ["grid-row-align"];
    Ly.exports = Ol;
  });
  var zy = v(function (nI, jy) {
    l();
    var u_ = M(),
      tr = /*#__PURE__*/function (_u_) {
        function tr() {
          _classCallCheck(this, tr);
          return _callSuper(this, tr, arguments);
        }
        _inherits(tr, _u_);
        return _createClass(tr, [{
          key: "keyframeParents",
          value: function keyframeParents(e) {
            var t = e.parent;
            for (; t;) {
              if (t.type === "atrule" && t.name === "keyframes") return !0;
              var _t14 = t;
              t = _t14.parent;
            }
            return !1;
          }
        }, {
          key: "contain3d",
          value: function contain3d(e) {
            if (e.prop === "transform-origin") return !1;
            var _iterator204 = _createForOfIteratorHelper(tr.functions3d),
              _step204;
            try {
              for (_iterator204.s(); !(_step204 = _iterator204.n()).done;) {
                var t = _step204.value;
                if (e.value.includes("".concat(t, "("))) return !0;
              }
            } catch (err) {
              _iterator204.e(err);
            } finally {
              _iterator204.f();
            }
            return !1;
          }
        }, {
          key: "set",
          value: function set(e, t) {
            return e = _get(_getPrototypeOf(tr.prototype), "set", this).call(this, e, t), t === "-ms-" && (e.value = e.value.replace(/rotatez/gi, "rotate")), e;
          }
        }, {
          key: "insert",
          value: function insert(e, t, r) {
            if (t === "-ms-") {
              if (!this.contain3d(e) && !this.keyframeParents(e)) return _get(_getPrototypeOf(tr.prototype), "insert", this).call(this, e, t, r);
            } else if (t === "-o-") {
              if (!this.contain3d(e)) return _get(_getPrototypeOf(tr.prototype), "insert", this).call(this, e, t, r);
            } else return _get(_getPrototypeOf(tr.prototype), "insert", this).call(this, e, t, r);
          }
        }]);
      }(u_);
    tr.names = ["transform", "transform-origin"];
    tr.functions3d = ["matrix3d", "translate3d", "translateZ", "scale3d", "scaleZ", "rotate3d", "rotateX", "rotateY", "perspective"];
    jy.exports = tr;
  });
  var Wy = v(function (sI, Uy) {
    l();
    var Vy = pe(),
      f_ = M(),
      El = /*#__PURE__*/function (_f_) {
        function El() {
          _classCallCheck(this, El);
          return _callSuper(this, El, arguments);
        }
        _inherits(El, _f_);
        return _createClass(El, [{
          key: "normalize",
          value: function normalize() {
            return "flex-direction";
          }
        }, {
          key: "insert",
          value: function insert(e, t, r) {
            var _Vy, _Vy2;
            var n;
            if ((_Vy = Vy(t), _Vy2 = _slicedToArray(_Vy, 2), n = _Vy2[0], t = _Vy2[1]), n !== 2009) return _get(_getPrototypeOf(El.prototype), "insert", this).call(this, e, t, r);
            if (e.parent.some(function (f) {
              return f.prop === t + "box-orient" || f.prop === t + "box-direction";
            })) return;
            var s = e.value,
              o,
              u;
            s === "inherit" || s === "initial" || s === "unset" ? (o = s, u = s) : (o = s.includes("row") ? "horizontal" : "vertical", u = s.includes("reverse") ? "reverse" : "normal");
            var c = this.clone(e);
            return c.prop = t + "box-orient", c.value = o, this.needCascade(e) && (c.raws.before = this.calcBefore(r, e, t)), e.parent.insertBefore(e, c), c = this.clone(e), c.prop = t + "box-direction", c.value = u, this.needCascade(e) && (c.raws.before = this.calcBefore(r, e, t)), e.parent.insertBefore(e, c);
          }
        }, {
          key: "old",
          value: function old(e, t) {
            var _Vy3, _Vy4;
            var r;
            return (_Vy3 = Vy(t), _Vy4 = _slicedToArray(_Vy3, 2), r = _Vy4[0], t = _Vy4[1]), r === 2009 ? [t + "box-orient", t + "box-direction"] : _get(_getPrototypeOf(El.prototype), "old", this).call(this, e, t);
          }
        }]);
      }(f_);
    El.names = ["flex-direction", "box-direction", "box-orient"];
    Uy.exports = El;
  });
  var Hy = v(function (aI, Gy) {
    l();
    var c_ = M(),
      Tl = /*#__PURE__*/function (_c_) {
        function Tl() {
          _classCallCheck(this, Tl);
          return _callSuper(this, Tl, arguments);
        }
        _inherits(Tl, _c_);
        return _createClass(Tl, [{
          key: "check",
          value: function check(e) {
            return e.value === "pixelated";
          }
        }, {
          key: "prefixed",
          value: function prefixed(e, t) {
            return t === "-ms-" ? "-ms-interpolation-mode" : _get(_getPrototypeOf(Tl.prototype), "prefixed", this).call(this, e, t);
          }
        }, {
          key: "set",
          value: function set(e, t) {
            return t !== "-ms-" ? _get(_getPrototypeOf(Tl.prototype), "set", this).call(this, e, t) : (e.prop = "-ms-interpolation-mode", e.value = "nearest-neighbor", e);
          }
        }, {
          key: "normalize",
          value: function normalize() {
            return "image-rendering";
          }
        }, {
          key: "process",
          value: function process(e, t) {
            return _get(_getPrototypeOf(Tl.prototype), "process", this).call(this, e, t);
          }
        }]);
      }(c_);
    Tl.names = ["image-rendering", "interpolation-mode"];
    Gy.exports = Tl;
  });
  var Qy = v(function (oI, Yy) {
    l();
    var p_ = M(),
      d_ = le(),
      Pl = /*#__PURE__*/function (_p_) {
        function Pl(e, t, r) {
          var _this34;
          _classCallCheck(this, Pl);
          _this34 = _callSuper(this, Pl, [e, t, r]);
          _this34.prefixes && (_this34.prefixes = d_.uniq(_this34.prefixes.map(function (n) {
            return n === "-ms-" ? "-webkit-" : n;
          })));
          return _this34;
        }
        _inherits(Pl, _p_);
        return _createClass(Pl);
      }(p_);
    Pl.names = ["backdrop-filter"];
    Yy.exports = Pl;
  });
  var Xy = v(function (lI, Jy) {
    l();
    var h_ = M(),
      m_ = le(),
      Dl = /*#__PURE__*/function (_h_) {
        function Dl(e, t, r) {
          var _this35;
          _classCallCheck(this, Dl);
          _this35 = _callSuper(this, Dl, [e, t, r]);
          _this35.prefixes && (_this35.prefixes = m_.uniq(_this35.prefixes.map(function (n) {
            return n === "-ms-" ? "-webkit-" : n;
          })));
          return _this35;
        }
        _inherits(Dl, _h_);
        return _createClass(Dl, [{
          key: "check",
          value: function check(e) {
            return e.value.toLowerCase() === "text";
          }
        }]);
      }(h_);
    Dl.names = ["background-clip"];
    Jy.exports = Dl;
  });
  var Zy = v(function (uI, Ky) {
    l();
    var g_ = M(),
      y_ = ["none", "underline", "overline", "line-through", "blink", "inherit", "initial", "unset"],
      Il = /*#__PURE__*/function (_g_) {
        function Il() {
          _classCallCheck(this, Il);
          return _callSuper(this, Il, arguments);
        }
        _inherits(Il, _g_);
        return _createClass(Il, [{
          key: "check",
          value: function check(e) {
            return e.value.split(/\s+/).some(function (t) {
              return !y_.includes(t);
            });
          }
        }]);
      }(g_);
    Il.names = ["text-decoration"];
    Ky.exports = Il;
  });
  var rw = v(function (fI, tw) {
    l();
    var ew = pe(),
      w_ = M(),
      rr = /*#__PURE__*/function (_w_) {
        function rr() {
          _classCallCheck(this, rr);
          return _callSuper(this, rr, arguments);
        }
        _inherits(rr, _w_);
        return _createClass(rr, [{
          key: "prefixed",
          value: function prefixed(e, t) {
            var _ew, _ew2;
            var r;
            return (_ew = ew(t), _ew2 = _slicedToArray(_ew, 2), r = _ew2[0], t = _ew2[1]), r === 2009 ? t + "box-pack" : r === 2012 ? t + "flex-pack" : _get(_getPrototypeOf(rr.prototype), "prefixed", this).call(this, e, t);
          }
        }, {
          key: "normalize",
          value: function normalize() {
            return "justify-content";
          }
        }, {
          key: "set",
          value: function set(e, t) {
            var r = ew(t)[0];
            if (r === 2009 || r === 2012) {
              var n = rr.oldValues[e.value] || e.value;
              if (e.value = n, r !== 2009 || n !== "distribute") return _get(_getPrototypeOf(rr.prototype), "set", this).call(this, e, t);
            } else if (r === "final") return _get(_getPrototypeOf(rr.prototype), "set", this).call(this, e, t);
          }
        }]);
      }(w_);
    rr.names = ["justify-content", "flex-pack", "box-pack"];
    rr.oldValues = {
      "flex-end": "end",
      "flex-start": "start",
      "space-between": "justify",
      "space-around": "distribute"
    };
    tw.exports = rr;
  });
  var nw = v(function (cI, iw) {
    l();
    var b_ = M(),
      ql = /*#__PURE__*/function (_b_) {
        function ql() {
          _classCallCheck(this, ql);
          return _callSuper(this, ql, arguments);
        }
        _inherits(ql, _b_);
        return _createClass(ql, [{
          key: "set",
          value: function set(e, t) {
            var r = e.value.toLowerCase();
            return t === "-webkit-" && !r.includes(" ") && r !== "contain" && r !== "cover" && (e.value = e.value + " " + e.value), _get(_getPrototypeOf(ql.prototype), "set", this).call(this, e, t);
          }
        }]);
      }(b_);
    ql.names = ["background-size"];
    iw.exports = ql;
  });
  var aw = v(function (pI, sw) {
    l();
    var v_ = M(),
      Rl = mt(),
      Ml = /*#__PURE__*/function (_v_) {
        function Ml() {
          _classCallCheck(this, Ml);
          return _callSuper(this, Ml, arguments);
        }
        _inherits(Ml, _v_);
        return _createClass(Ml, [{
          key: "insert",
          value: function insert(e, t, r) {
            if (t !== "-ms-") return _get(_getPrototypeOf(Ml.prototype), "insert", this).call(this, e, t, r);
            var n = Rl.parse(e),
              _Rl$translate = Rl.translate(n, 0, 1),
              _Rl$translate2 = _slicedToArray(_Rl$translate, 2),
              a = _Rl$translate2[0],
              s = _Rl$translate2[1];
            n[0] && n[0].includes("span") && (s = n[0].join("").replace(/\D/g, "")), [[e.prop, a], ["".concat(e.prop, "-span"), s]].forEach(function (_ref340) {
              var _ref341 = _slicedToArray(_ref340, 2),
                u = _ref341[0],
                c = _ref341[1];
              Rl.insertDecl(e, u, c);
            });
          }
        }]);
      }(v_);
    Ml.names = ["grid-row", "grid-column"];
    sw.exports = Ml;
  });
  var uw = v(function (dI, lw) {
    l();
    var x_ = M(),
      _mt2 = mt(),
      ow = _mt2.prefixTrackProp,
      k_ = _mt2.prefixTrackValue,
      S_ = _mt2.autoplaceGridItems,
      C_ = _mt2.getGridGap,
      A_ = _mt2.inheritGridGap,
      __ = el(),
      Bl = /*#__PURE__*/function (_x_) {
        function Bl() {
          _classCallCheck(this, Bl);
          return _callSuper(this, Bl, arguments);
        }
        _inherits(Bl, _x_);
        return _createClass(Bl, [{
          key: "prefixed",
          value: function prefixed(e, t) {
            return t === "-ms-" ? ow({
              prop: e,
              prefix: t
            }) : _get(_getPrototypeOf(Bl.prototype), "prefixed", this).call(this, e, t);
          }
        }, {
          key: "normalize",
          value: function normalize(e) {
            return e.replace(/^grid-(rows|columns)/, "grid-template-$1");
          }
        }, {
          key: "insert",
          value: function insert(e, t, r, n) {
            if (t !== "-ms-") return _get(_getPrototypeOf(Bl.prototype), "insert", this).call(this, e, t, r);
            var a = e.parent,
              s = e.prop,
              o = e.value,
              u = s.includes("rows"),
              c = s.includes("columns"),
              f = a.some(function (k) {
                return k.prop === "grid-template" || k.prop === "grid-template-areas";
              });
            if (f && u) return !1;
            var d = new __({
                options: {}
              }),
              p = d.gridStatus(a, n),
              m = C_(e);
            m = A_(e, m) || m;
            var b = u ? m.row : m.column;
            (p === "no-autoplace" || p === !0) && !f && (b = null);
            var x = k_({
              value: o,
              gap: b
            });
            e.cloneBefore({
              prop: ow({
                prop: s,
                prefix: t
              }),
              value: x
            });
            var y = a.nodes.find(function (k) {
                return k.prop === "grid-auto-flow";
              }),
              w = "row";
            if (y && !d.disabled(y, n) && (w = y.value.trim()), p === "autoplace") {
              var k = a.nodes.find(function (_) {
                return _.prop === "grid-template-rows";
              });
              if (!k && f) return;
              if (!k && !f) {
                e.warn(n, "Autoplacement does not work without grid-template-rows property");
                return;
              }
              !a.nodes.find(function (_) {
                return _.prop === "grid-template-columns";
              }) && !f && e.warn(n, "Autoplacement does not work without grid-template-columns property"), c && !f && S_(e, n, m, w);
            }
          }
        }]);
      }(x_);
    Bl.names = ["grid-template-rows", "grid-template-columns", "grid-rows", "grid-columns"];
    lw.exports = Bl;
  });
  var cw = v(function (hI, fw) {
    l();
    var O_ = M(),
      Fl = /*#__PURE__*/function (_O_) {
        function Fl() {
          _classCallCheck(this, Fl);
          return _callSuper(this, Fl, arguments);
        }
        _inherits(Fl, _O_);
        return _createClass(Fl, [{
          key: "check",
          value: function check(e) {
            return !e.value.includes("flex-") && e.value !== "baseline";
          }
        }, {
          key: "prefixed",
          value: function prefixed(e, t) {
            return t + "grid-column-align";
          }
        }, {
          key: "normalize",
          value: function normalize() {
            return "justify-self";
          }
        }]);
      }(O_);
    Fl.names = ["grid-column-align"];
    fw.exports = Fl;
  });
  var dw = v(function (mI, pw) {
    l();
    var E_ = M(),
      Nl = /*#__PURE__*/function (_E_) {
        function Nl() {
          _classCallCheck(this, Nl);
          return _callSuper(this, Nl, arguments);
        }
        _inherits(Nl, _E_);
        return _createClass(Nl, [{
          key: "prefixed",
          value: function prefixed(e, t) {
            return t + "scroll-chaining";
          }
        }, {
          key: "normalize",
          value: function normalize() {
            return "overscroll-behavior";
          }
        }, {
          key: "set",
          value: function set(e, t) {
            return e.value === "auto" ? e.value = "chained" : (e.value === "none" || e.value === "contain") && (e.value = "none"), _get(_getPrototypeOf(Nl.prototype), "set", this).call(this, e, t);
          }
        }]);
      }(E_);
    Nl.names = ["overscroll-behavior", "scroll-chaining"];
    pw.exports = Nl;
  });
  var gw = v(function (gI, mw) {
    l();
    var T_ = M(),
      _mt3 = mt(),
      P_ = _mt3.parseGridAreas,
      D_ = _mt3.warnMissedAreas,
      I_ = _mt3.prefixTrackProp,
      hw = _mt3.prefixTrackValue,
      q_ = _mt3.getGridGap,
      R_ = _mt3.warnGridGap,
      M_ = _mt3.inheritGridGap;
    function B_(i) {
      return i.trim().slice(1, -1).split(/["']\s*["']?/g);
    }
    var Ll = /*#__PURE__*/function (_T_) {
      function Ll() {
        _classCallCheck(this, Ll);
        return _callSuper(this, Ll, arguments);
      }
      _inherits(Ll, _T_);
      return _createClass(Ll, [{
        key: "insert",
        value: function insert(e, t, r, n) {
          if (t !== "-ms-") return _get(_getPrototypeOf(Ll.prototype), "insert", this).call(this, e, t, r);
          var a = !1,
            s = !1,
            o = e.parent,
            u = q_(e);
          u = M_(e, u) || u, o.walkDecls(/-ms-grid-rows/, function (d) {
            return d.remove();
          }), o.walkDecls(/grid-template-(rows|columns)/, function (d) {
            if (d.prop === "grid-template-rows") {
              s = !0;
              var p = d.prop,
                m = d.value;
              d.cloneBefore({
                prop: I_({
                  prop: p,
                  prefix: t
                }),
                value: hw({
                  value: m,
                  gap: u.row
                })
              });
            } else a = !0;
          });
          var c = B_(e.value);
          a && !s && u.row && c.length > 1 && e.cloneBefore({
            prop: "-ms-grid-rows",
            value: hw({
              value: "repeat(".concat(c.length, ", auto)"),
              gap: u.row
            }),
            raws: {}
          }), R_({
            gap: u,
            hasColumns: a,
            decl: e,
            result: n
          });
          var f = P_({
            rows: c,
            gap: u
          });
          return D_(f, e, n), e;
        }
      }]);
    }(T_);
    Ll.names = ["grid-template-areas"];
    mw.exports = Ll;
  });
  var ww = v(function (yI, yw) {
    l();
    var F_ = M(),
      $l = /*#__PURE__*/function (_F_) {
        function $l() {
          _classCallCheck(this, $l);
          return _callSuper(this, $l, arguments);
        }
        _inherits($l, _F_);
        return _createClass($l, [{
          key: "set",
          value: function set(e, t) {
            return t === "-webkit-" && (e.value = e.value.replace(/\s*(right|left)\s*/i, "")), _get(_getPrototypeOf($l.prototype), "set", this).call(this, e, t);
          }
        }]);
      }(F_);
    $l.names = ["text-emphasis-position"];
    yw.exports = $l;
  });
  var vw = v(function (wI, bw) {
    l();
    var N_ = M(),
      jl = /*#__PURE__*/function (_N_) {
        function jl() {
          _classCallCheck(this, jl);
          return _callSuper(this, jl, arguments);
        }
        _inherits(jl, _N_);
        return _createClass(jl, [{
          key: "set",
          value: function set(e, t) {
            return e.prop === "text-decoration-skip-ink" && e.value === "auto" ? (e.prop = t + "text-decoration-skip", e.value = "ink", e) : _get(_getPrototypeOf(jl.prototype), "set", this).call(this, e, t);
          }
        }]);
      }(N_);
    jl.names = ["text-decoration-skip-ink", "text-decoration-skip"];
    bw.exports = jl;
  });
  var _w = v(function (bI, Aw) {
    l();
    "use strict";
    Aw.exports = {
      wrap: xw,
      limit: kw,
      validate: Sw,
      test: zl,
      curry: L_,
      name: Cw
    };
    function xw(i, e, t) {
      var r = e - i;
      return ((t - i) % r + r) % r + i;
    }
    function kw(i, e, t) {
      return Math.max(i, Math.min(e, t));
    }
    function Sw(i, e, t, r, n) {
      if (!zl(i, e, t, r, n)) throw new Error(t + " is outside of range [" + i + "," + e + ")");
      return t;
    }
    function zl(i, e, t, r, n) {
      return !(t < i || t > e || n && t === e || r && t === i);
    }
    function Cw(i, e, t, r) {
      return (t ? "(" : "[") + i + "," + e + (r ? ")" : "]");
    }
    function L_(i, e, t, r) {
      var n = Cw.bind(null, i, e, t, r);
      return {
        wrap: xw.bind(null, i, e),
        limit: kw.bind(null, i, e),
        validate: function validate(a) {
          return Sw(i, e, a, t, r);
        },
        test: function test(a) {
          return zl(i, e, a, t, r);
        },
        toString: n,
        name: n
      };
    }
  });
  var Tw = v(function (vI, Ew) {
    l();
    var Vl = Gn(),
      $_ = _w(),
      j_ = Ht(),
      z_ = ke(),
      V_ = le(),
      Ow = /top|left|right|bottom/gi,
      Qe = /*#__PURE__*/function (_z_) {
        function Qe() {
          _classCallCheck(this, Qe);
          return _callSuper(this, Qe, arguments);
        }
        _inherits(Qe, _z_);
        return _createClass(Qe, [{
          key: "replace",
          value: function replace(e, t) {
            var r = Vl(e);
            var _iterator205 = _createForOfIteratorHelper(r.nodes),
              _step205;
            try {
              for (_iterator205.s(); !(_step205 = _iterator205.n()).done;) {
                var n = _step205.value;
                if (n.type === "function" && n.value === this.name) if (n.nodes = this.newDirection(n.nodes), n.nodes = this.normalize(n.nodes), t === "-webkit- old") {
                  if (!this.oldWebkit(n)) return !1;
                } else n.nodes = this.convertDirection(n.nodes), n.value = t + n.value;
              }
            } catch (err) {
              _iterator205.e(err);
            } finally {
              _iterator205.f();
            }
            return r.toString();
          }
        }, {
          key: "replaceFirst",
          value: function replaceFirst(e) {
            for (var _len14 = arguments.length, t = new Array(_len14 > 1 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) {
              t[_key14 - 1] = arguments[_key14];
            }
            return t.map(function (n) {
              return n === " " ? {
                type: "space",
                value: n
              } : {
                type: "word",
                value: n
              };
            }).concat(e.slice(1));
          }
        }, {
          key: "normalizeUnit",
          value: function normalizeUnit(e, t) {
            return "".concat(parseFloat(e) / t * 360, "deg");
          }
        }, {
          key: "normalize",
          value: function normalize(e) {
            if (!e[0]) return e;
            if (/-?\d+(.\d+)?grad/.test(e[0].value)) e[0].value = this.normalizeUnit(e[0].value, 400);else if (/-?\d+(.\d+)?rad/.test(e[0].value)) e[0].value = this.normalizeUnit(e[0].value, 2 * Math.PI);else if (/-?\d+(.\d+)?turn/.test(e[0].value)) e[0].value = this.normalizeUnit(e[0].value, 1);else if (e[0].value.includes("deg")) {
              var t = parseFloat(e[0].value);
              t = $_.wrap(0, 360, t), e[0].value = "".concat(t, "deg");
            }
            return e[0].value === "0deg" ? e = this.replaceFirst(e, "to", " ", "top") : e[0].value === "90deg" ? e = this.replaceFirst(e, "to", " ", "right") : e[0].value === "180deg" ? e = this.replaceFirst(e, "to", " ", "bottom") : e[0].value === "270deg" && (e = this.replaceFirst(e, "to", " ", "left")), e;
          }
        }, {
          key: "newDirection",
          value: function newDirection(e) {
            if (e[0].value === "to" || (Ow.lastIndex = 0, !Ow.test(e[0].value))) return e;
            e.unshift({
              type: "word",
              value: "to"
            }, {
              type: "space",
              value: " "
            });
            for (var t = 2; t < e.length && e[t].type !== "div"; t++) e[t].type === "word" && (e[t].value = this.revertDirection(e[t].value));
            return e;
          }
        }, {
          key: "isRadial",
          value: function isRadial(e) {
            var t = "before";
            var _iterator206 = _createForOfIteratorHelper(e),
              _step206;
            try {
              for (_iterator206.s(); !(_step206 = _iterator206.n()).done;) {
                var r = _step206.value;
                if (t === "before" && r.type === "space") t = "at";else if (t === "at" && r.value === "at") t = "after";else {
                  if (t === "after" && r.type === "space") return !0;
                  if (r.type === "div") break;
                  t = "before";
                }
              }
            } catch (err) {
              _iterator206.e(err);
            } finally {
              _iterator206.f();
            }
            return !1;
          }
        }, {
          key: "convertDirection",
          value: function convertDirection(e) {
            return e.length > 0 && (e[0].value === "to" ? this.fixDirection(e) : e[0].value.includes("deg") ? this.fixAngle(e) : this.isRadial(e) && this.fixRadial(e)), e;
          }
        }, {
          key: "fixDirection",
          value: function fixDirection(e) {
            e.splice(0, 2);
            var _iterator207 = _createForOfIteratorHelper(e),
              _step207;
            try {
              for (_iterator207.s(); !(_step207 = _iterator207.n()).done;) {
                var t = _step207.value;
                if (t.type === "div") break;
                t.type === "word" && (t.value = this.revertDirection(t.value));
              }
            } catch (err) {
              _iterator207.e(err);
            } finally {
              _iterator207.f();
            }
          }
        }, {
          key: "fixAngle",
          value: function fixAngle(e) {
            var t = e[0].value;
            t = parseFloat(t), t = Math.abs(450 - t) % 360, t = this.roundFloat(t, 3), e[0].value = "".concat(t, "deg");
          }
        }, {
          key: "fixRadial",
          value: function fixRadial(e) {
            var t = [],
              r = [],
              n,
              a,
              s,
              o,
              u;
            for (o = 0; o < e.length - 2; o++) if (n = e[o], a = e[o + 1], s = e[o + 2], n.type === "space" && a.value === "at" && s.type === "space") {
              u = o + 3;
              break;
            } else t.push(n);
            var c;
            for (o = u; o < e.length; o++) if (e[o].type === "div") {
              c = e[o];
              break;
            } else r.push(e[o]);
            e.splice.apply(e, [0, o].concat(r, [c], t));
          }
        }, {
          key: "revertDirection",
          value: function revertDirection(e) {
            return Qe.directions[e.toLowerCase()] || e;
          }
        }, {
          key: "roundFloat",
          value: function roundFloat(e, t) {
            return parseFloat(e.toFixed(t));
          }
        }, {
          key: "oldWebkit",
          value: function oldWebkit(e) {
            var t = e.nodes,
              r = Vl.stringify(e.nodes);
            if (this.name !== "linear-gradient" || t[0] && t[0].value.includes("deg") || r.includes("px") || r.includes("-corner") || r.includes("-side")) return !1;
            var n = [[]];
            var _iterator208 = _createForOfIteratorHelper(t),
              _step208;
            try {
              for (_iterator208.s(); !(_step208 = _iterator208.n()).done;) {
                var _a16 = _step208.value;
                n[n.length - 1].push(_a16), _a16.type === "div" && _a16.value === "," && n.push([]);
              }
            } catch (err) {
              _iterator208.e(err);
            } finally {
              _iterator208.f();
            }
            this.oldDirection(n), this.colorStops(n), e.nodes = [];
            for (var _i28 = 0, _n23 = n; _i28 < _n23.length; _i28++) {
              var a = _n23[_i28];
              e.nodes = e.nodes.concat(a);
            }
            return e.nodes.unshift({
              type: "word",
              value: "linear"
            }, this.cloneDiv(e.nodes)), e.value = "-webkit-gradient", !0;
          }
        }, {
          key: "oldDirection",
          value: function oldDirection(e) {
            var t = this.cloneDiv(e[0]);
            if (e[0][0].value !== "to") return e.unshift([{
              type: "word",
              value: Qe.oldDirections.bottom
            }, t]);
            {
              var r = [];
              var _iterator209 = _createForOfIteratorHelper(e[0].slice(2)),
                _step209;
              try {
                for (_iterator209.s(); !(_step209 = _iterator209.n()).done;) {
                  var a = _step209.value;
                  a.type === "word" && r.push(a.value.toLowerCase());
                }
              } catch (err) {
                _iterator209.e(err);
              } finally {
                _iterator209.f();
              }
              r = r.join(" ");
              var n = Qe.oldDirections[r] || r;
              return e[0] = [{
                type: "word",
                value: n
              }, t], e[0];
            }
          }
        }, {
          key: "cloneDiv",
          value: function cloneDiv(e) {
            var _iterator210 = _createForOfIteratorHelper(e),
              _step210;
            try {
              for (_iterator210.s(); !(_step210 = _iterator210.n()).done;) {
                var t = _step210.value;
                if (t.type === "div" && t.value === ",") return t;
              }
            } catch (err) {
              _iterator210.e(err);
            } finally {
              _iterator210.f();
            }
            return {
              type: "div",
              value: ",",
              after: " "
            };
          }
        }, {
          key: "colorStops",
          value: function colorStops(e) {
            var t = [];
            for (var r = 0; r < e.length; r++) {
              var n = void 0,
                a = e[r],
                s = void 0;
              if (r === 0) continue;
              var o = Vl.stringify(a[0]);
              a[1] && a[1].type === "word" ? n = a[1].value : a[2] && a[2].type === "word" && (n = a[2].value);
              var _u19 = void 0;
              r === 1 && (!n || n === "0%") ? _u19 = "from(".concat(o, ")") : r === e.length - 1 && (!n || n === "100%") ? _u19 = "to(".concat(o, ")") : n ? _u19 = "color-stop(".concat(n, ", ").concat(o, ")") : _u19 = "color-stop(".concat(o, ")");
              var c = a[a.length - 1];
              e[r] = [{
                type: "word",
                value: _u19
              }], c.type === "div" && c.value === "," && (s = e[r].push(c)), t.push(s);
            }
            return t;
          }
        }, {
          key: "old",
          value: function old(e) {
            if (e === "-webkit-") {
              var t = this.name === "linear-gradient" ? "linear" : "radial",
                r = "-gradient",
                n = V_.regexp("-webkit-(".concat(t, "-gradient|gradient\\(\\s*").concat(t, ")"), !1);
              return new j_(this.name, e + this.name, r, n);
            } else return _get(_getPrototypeOf(Qe.prototype), "old", this).call(this, e);
          }
        }, {
          key: "add",
          value: function add(e, t) {
            var r = e.prop;
            if (r.includes("mask")) {
              if (t === "-webkit-" || t === "-webkit- old") return _get(_getPrototypeOf(Qe.prototype), "add", this).call(this, e, t);
            } else if (r === "list-style" || r === "list-style-image" || r === "content") {
              if (t === "-webkit-" || t === "-webkit- old") return _get(_getPrototypeOf(Qe.prototype), "add", this).call(this, e, t);
            } else return _get(_getPrototypeOf(Qe.prototype), "add", this).call(this, e, t);
          }
        }]);
      }(z_);
    Qe.names = ["linear-gradient", "repeating-linear-gradient", "radial-gradient", "repeating-radial-gradient"];
    Qe.directions = {
      top: "bottom",
      left: "right",
      bottom: "top",
      right: "left"
    };
    Qe.oldDirections = {
      top: "left bottom, left top",
      left: "right top, left top",
      bottom: "left top, left bottom",
      right: "left top, right top",
      "top right": "left bottom, right top",
      "top left": "right bottom, left top",
      "right top": "left bottom, right top",
      "right bottom": "left top, right bottom",
      "bottom right": "left top, right bottom",
      "bottom left": "right top, left bottom",
      "left top": "right bottom, left top",
      "left bottom": "right top, left bottom"
    };
    Ew.exports = Qe;
  });
  var Iw = v(function (xI, Dw) {
    l();
    var U_ = Ht(),
      W_ = ke();
    function Pw(i) {
      return new RegExp("(^|[\\s,(])(".concat(i, "($|[\\s),]))"), "gi");
    }
    var Ul = /*#__PURE__*/function (_W_) {
      function Ul() {
        _classCallCheck(this, Ul);
        return _callSuper(this, Ul, arguments);
      }
      _inherits(Ul, _W_);
      return _createClass(Ul, [{
        key: "regexp",
        value: function regexp() {
          return this.regexpCache || (this.regexpCache = Pw(this.name)), this.regexpCache;
        }
      }, {
        key: "isStretch",
        value: function isStretch() {
          return this.name === "stretch" || this.name === "fill" || this.name === "fill-available";
        }
      }, {
        key: "replace",
        value: function replace(e, t) {
          return t === "-moz-" && this.isStretch() ? e.replace(this.regexp(), "$1-moz-available$3") : t === "-webkit-" && this.isStretch() ? e.replace(this.regexp(), "$1-webkit-fill-available$3") : _get(_getPrototypeOf(Ul.prototype), "replace", this).call(this, e, t);
        }
      }, {
        key: "old",
        value: function old(e) {
          var t = e + this.name;
          return this.isStretch() && (e === "-moz-" ? t = "-moz-available" : e === "-webkit-" && (t = "-webkit-fill-available")), new U_(this.name, t, t, Pw(t));
        }
      }, {
        key: "add",
        value: function add(e, t) {
          if (!(e.prop.includes("grid") && t !== "-webkit-")) return _get(_getPrototypeOf(Ul.prototype), "add", this).call(this, e, t);
        }
      }]);
    }(W_);
    Ul.names = ["max-content", "min-content", "fit-content", "fill", "fill-available", "stretch"];
    Dw.exports = Ul;
  });
  var Mw = v(function (kI, Rw) {
    l();
    var qw = Ht(),
      G_ = ke(),
      Wl = /*#__PURE__*/function (_G_) {
        function Wl() {
          _classCallCheck(this, Wl);
          return _callSuper(this, Wl, arguments);
        }
        _inherits(Wl, _G_);
        return _createClass(Wl, [{
          key: "replace",
          value: function replace(e, t) {
            return t === "-webkit-" ? e.replace(this.regexp(), "$1-webkit-optimize-contrast") : t === "-moz-" ? e.replace(this.regexp(), "$1-moz-crisp-edges") : _get(_getPrototypeOf(Wl.prototype), "replace", this).call(this, e, t);
          }
        }, {
          key: "old",
          value: function old(e) {
            return e === "-webkit-" ? new qw(this.name, "-webkit-optimize-contrast") : e === "-moz-" ? new qw(this.name, "-moz-crisp-edges") : _get(_getPrototypeOf(Wl.prototype), "old", this).call(this, e);
          }
        }]);
      }(G_);
    Wl.names = ["pixelated"];
    Rw.exports = Wl;
  });
  var Fw = v(function (SI, Bw) {
    l();
    var H_ = ke(),
      Gl = /*#__PURE__*/function (_H_) {
        function Gl() {
          _classCallCheck(this, Gl);
          return _callSuper(this, Gl, arguments);
        }
        _inherits(Gl, _H_);
        return _createClass(Gl, [{
          key: "replace",
          value: function replace(e, t) {
            var r = _get(_getPrototypeOf(Gl.prototype), "replace", this).call(this, e, t);
            return t === "-webkit-" && (r = r.replace(/("[^"]+"|'[^']+')(\s+\d+\w)/gi, "url($1)$2")), r;
          }
        }]);
      }(H_);
    Gl.names = ["image-set"];
    Bw.exports = Gl;
  });
  var Lw = v(function (CI, Nw) {
    l();
    var Y_ = ge().list,
      Q_ = ke(),
      Hl = /*#__PURE__*/function (_Q_) {
        function Hl() {
          _classCallCheck(this, Hl);
          return _callSuper(this, Hl, arguments);
        }
        _inherits(Hl, _Q_);
        return _createClass(Hl, [{
          key: "replace",
          value: function replace(e, t) {
            var _this36 = this;
            return Y_.space(e).map(function (r) {
              if (r.slice(0, +_this36.name.length + 1) !== _this36.name + "(") return r;
              var n = r.lastIndexOf(")"),
                a = r.slice(n + 1),
                s = r.slice(_this36.name.length + 1, n);
              if (t === "-webkit-") {
                var o = s.match(/\d*.?\d+%?/);
                o ? (s = s.slice(o[0].length).trim(), s += ", ".concat(o[0])) : s += ", 0.5";
              }
              return t + _this36.name + "(" + s + ")" + a;
            }).join(" ");
          }
        }]);
      }(Q_);
    Hl.names = ["cross-fade"];
    Nw.exports = Hl;
  });
  var jw = v(function (AI, $w) {
    l();
    var J_ = pe(),
      X_ = Ht(),
      K_ = ke(),
      Yl = /*#__PURE__*/function (_K_) {
        function Yl(e, t) {
          var _this37;
          _classCallCheck(this, Yl);
          _this37 = _callSuper(this, Yl, [e, t]);
          e === "display-flex" && (_this37.name = "flex");
          return _this37;
        }
        _inherits(Yl, _K_);
        return _createClass(Yl, [{
          key: "check",
          value: function check(e) {
            return e.prop === "display" && e.value === this.name;
          }
        }, {
          key: "prefixed",
          value: function prefixed(e) {
            var _J_, _J_2;
            var t, r;
            return (_J_ = J_(e), _J_2 = _slicedToArray(_J_, 2), t = _J_2[0], e = _J_2[1]), t === 2009 ? this.name === "flex" ? r = "box" : r = "inline-box" : t === 2012 ? this.name === "flex" ? r = "flexbox" : r = "inline-flexbox" : t === "final" && (r = this.name), e + r;
          }
        }, {
          key: "replace",
          value: function replace(e, t) {
            return this.prefixed(t);
          }
        }, {
          key: "old",
          value: function old(e) {
            var t = this.prefixed(e);
            if (!!t) return new X_(this.name, t);
          }
        }]);
      }(K_);
    Yl.names = ["display-flex", "inline-flex"];
    $w.exports = Yl;
  });
  var Vw = v(function (_I, zw) {
    l();
    var Z_ = ke(),
      Ql = /*#__PURE__*/function (_Z_) {
        function Ql(e, t) {
          var _this38;
          _classCallCheck(this, Ql);
          _this38 = _callSuper(this, Ql, [e, t]);
          e === "display-grid" && (_this38.name = "grid");
          return _this38;
        }
        _inherits(Ql, _Z_);
        return _createClass(Ql, [{
          key: "check",
          value: function check(e) {
            return e.prop === "display" && e.value === this.name;
          }
        }]);
      }(Z_);
    Ql.names = ["display-grid", "inline-grid"];
    zw.exports = Ql;
  });
  var Ww = v(function (OI, Uw) {
    l();
    var e5 = ke(),
      Jl = /*#__PURE__*/function (_e27) {
        function Jl(e, t) {
          var _this39;
          _classCallCheck(this, Jl);
          _this39 = _callSuper(this, Jl, [e, t]);
          e === "filter-function" && (_this39.name = "filter");
          return _this39;
        }
        _inherits(Jl, _e27);
        return _createClass(Jl);
      }(e5);
    Jl.names = ["filter", "filter-function"];
    Uw.exports = Jl;
  });
  var Qw = v(function (EI, Yw) {
    l();
    var Gw = ii(),
      B = M(),
      Hw = Em(),
      t5 = Gm(),
      r5 = el(),
      i5 = cg(),
      Xl = dt(),
      ir = Yt(),
      n5 = bg(),
      $e = ke(),
      nr = le(),
      s5 = xg(),
      a5 = Sg(),
      o5 = Ag(),
      l5 = Og(),
      u5 = Ig(),
      f5 = Mg(),
      c5 = Fg(),
      p5 = Lg(),
      d5 = jg(),
      h5 = Vg(),
      m5 = Wg(),
      g5 = Hg(),
      y5 = Qg(),
      w5 = Xg(),
      b5 = Zg(),
      v5 = ry(),
      x5 = ny(),
      k5 = oy(),
      S5 = uy(),
      C5 = cy(),
      A5 = hy(),
      _5 = gy(),
      O5 = by(),
      E5 = xy(),
      T5 = Sy(),
      P5 = Ay(),
      D5 = Oy(),
      I5 = Py(),
      q5 = Iy(),
      R5 = Ry(),
      M5 = By(),
      B5 = Ny(),
      F5 = $y(),
      N5 = zy(),
      L5 = Wy(),
      $5 = Hy(),
      j5 = Qy(),
      z5 = Xy(),
      V5 = Zy(),
      U5 = rw(),
      W5 = nw(),
      G5 = aw(),
      H5 = uw(),
      Y5 = cw(),
      Q5 = dw(),
      J5 = gw(),
      X5 = ww(),
      K5 = vw(),
      Z5 = Tw(),
      eO = Iw(),
      tO = Mw(),
      rO = Fw(),
      iO = Lw(),
      nO = jw(),
      sO = Vw(),
      aO = Ww();
    ir.hack(s5);
    ir.hack(a5);
    ir.hack(o5);
    ir.hack(l5);
    B.hack(u5);
    B.hack(f5);
    B.hack(c5);
    B.hack(p5);
    B.hack(d5);
    B.hack(h5);
    B.hack(m5);
    B.hack(g5);
    B.hack(y5);
    B.hack(w5);
    B.hack(b5);
    B.hack(v5);
    B.hack(x5);
    B.hack(k5);
    B.hack(S5);
    B.hack(C5);
    B.hack(A5);
    B.hack(_5);
    B.hack(O5);
    B.hack(E5);
    B.hack(T5);
    B.hack(P5);
    B.hack(D5);
    B.hack(I5);
    B.hack(q5);
    B.hack(R5);
    B.hack(M5);
    B.hack(B5);
    B.hack(F5);
    B.hack(N5);
    B.hack(L5);
    B.hack($5);
    B.hack(j5);
    B.hack(z5);
    B.hack(V5);
    B.hack(U5);
    B.hack(W5);
    B.hack(G5);
    B.hack(H5);
    B.hack(Y5);
    B.hack(Q5);
    B.hack(J5);
    B.hack(X5);
    B.hack(K5);
    $e.hack(Z5);
    $e.hack(eO);
    $e.hack(tO);
    $e.hack(rO);
    $e.hack(iO);
    $e.hack(nO);
    $e.hack(sO);
    $e.hack(aO);
    var Kl = new Map(),
      si = /*#__PURE__*/function () {
        function si(e, t) {
          var _this$preprocess, _this$preprocess2;
          var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          _classCallCheck(this, si);
          this.data = e, this.browsers = t, this.options = r, (_this$preprocess = this.preprocess(this.select(this.data)), _this$preprocess2 = _slicedToArray(_this$preprocess, 2), this.add = _this$preprocess2[0], this.remove = _this$preprocess2[1]), this.transition = new t5(this), this.processor = new r5(this);
        }
        return _createClass(si, [{
          key: "cleaner",
          value: function cleaner() {
            if (this.cleanerCache) return this.cleanerCache;
            if (this.browsers.selected.length) {
              var e = new Xl(this.browsers.data, []);
              this.cleanerCache = new si(this.data, e, this.options);
            } else return this;
            return this.cleanerCache;
          }
        }, {
          key: "select",
          value: function select(e) {
            var _this40 = this;
            var t = {
              add: {},
              remove: {}
            };
            var _loop29 = function _loop29() {
              var n = e[r],
                a = n.browsers.map(function (u) {
                  var c = u.split(" ");
                  return {
                    browser: "".concat(c[0], " ").concat(c[1]),
                    note: c[2]
                  };
                }),
                s = a.filter(function (u) {
                  return u.note;
                }).map(function (u) {
                  return "".concat(_this40.browsers.prefix(u.browser), " ").concat(u.note);
                });
              s = nr.uniq(s), a = a.filter(function (u) {
                return _this40.browsers.isSelected(u.browser);
              }).map(function (u) {
                var c = _this40.browsers.prefix(u.browser);
                return u.note ? "".concat(c, " ").concat(u.note) : c;
              }), a = _this40.sort(nr.uniq(a)), _this40.options.flexbox === "no-2009" && (a = a.filter(function (u) {
                return !u.includes("2009");
              }));
              var o = n.browsers.map(function (u) {
                return _this40.browsers.prefix(u);
              });
              n.mistakes && (o = o.concat(n.mistakes)), o = o.concat(s), o = nr.uniq(o), a.length ? (t.add[r] = a, a.length < o.length && (t.remove[r] = o.filter(function (u) {
                return !a.includes(u);
              }))) : t.remove[r] = o;
            };
            for (var r in e) {
              _loop29();
            }
            return t;
          }
        }, {
          key: "sort",
          value: function sort(e) {
            return e.sort(function (t, r) {
              var n = nr.removeNote(t).length,
                a = nr.removeNote(r).length;
              return n === a ? r.length - t.length : a - n;
            });
          }
        }, {
          key: "preprocess",
          value: function preprocess(e) {
            var t = {
              selectors: [],
              "@supports": new i5(si, this)
            };
            for (var n in e.add) {
              var a = e.add[n];
              if (n === "@keyframes" || n === "@viewport") t[n] = new n5(n, a, this);else if (n === "@resolution") t[n] = new Hw(n, a, this);else if (this.data[n].selector) t.selectors.push(ir.load(n, a, this));else {
                var s = this.data[n].props;
                if (s) {
                  var o = $e.load(n, a, this);
                  var _iterator211 = _createForOfIteratorHelper(s),
                    _step211;
                  try {
                    for (_iterator211.s(); !(_step211 = _iterator211.n()).done;) {
                      var _u20 = _step211.value;
                      t[_u20] || (t[_u20] = {
                        values: []
                      }), t[_u20].values.push(o);
                    }
                  } catch (err) {
                    _iterator211.e(err);
                  } finally {
                    _iterator211.f();
                  }
                } else {
                  var _o10 = t[n] && t[n].values || [];
                  t[n] = B.load(n, a, this), t[n].values = _o10;
                }
              }
            }
            var r = {
              selectors: []
            };
            for (var _n24 in e.remove) {
              var _a17 = e.remove[_n24];
              if (this.data[_n24].selector) {
                var _s18 = ir.load(_n24, _a17);
                var _iterator212 = _createForOfIteratorHelper(_a17),
                  _step212;
                try {
                  for (_iterator212.s(); !(_step212 = _iterator212.n()).done;) {
                    var _o11 = _step212.value;
                    r.selectors.push(_s18.old(_o11));
                  }
                } catch (err) {
                  _iterator212.e(err);
                } finally {
                  _iterator212.f();
                }
              } else if (_n24 === "@keyframes" || _n24 === "@viewport") {
                var _iterator213 = _createForOfIteratorHelper(_a17),
                  _step213;
                try {
                  for (_iterator213.s(); !(_step213 = _iterator213.n()).done;) {
                    var _s19 = _step213.value;
                    var _o12 = "@".concat(_s19).concat(_n24.slice(1));
                    r[_o12] = {
                      remove: !0
                    };
                  }
                } catch (err) {
                  _iterator213.e(err);
                } finally {
                  _iterator213.f();
                }
              } else if (_n24 === "@resolution") r[_n24] = new Hw(_n24, _a17, this);else {
                var _s20 = this.data[_n24].props;
                if (_s20) {
                  var _o13 = $e.load(_n24, [], this);
                  var _iterator214 = _createForOfIteratorHelper(_a17),
                    _step214;
                  try {
                    for (_iterator214.s(); !(_step214 = _iterator214.n()).done;) {
                      var _u21 = _step214.value;
                      var c = _o13.old(_u21);
                      if (c) {
                        var _iterator215 = _createForOfIteratorHelper(_s20),
                          _step215;
                        try {
                          for (_iterator215.s(); !(_step215 = _iterator215.n()).done;) {
                            var f = _step215.value;
                            r[f] || (r[f] = {}), r[f].values || (r[f].values = []), r[f].values.push(c);
                          }
                        } catch (err) {
                          _iterator215.e(err);
                        } finally {
                          _iterator215.f();
                        }
                      }
                    }
                  } catch (err) {
                    _iterator214.e(err);
                  } finally {
                    _iterator214.f();
                  }
                } else {
                  var _iterator216 = _createForOfIteratorHelper(_a17),
                    _step216;
                  try {
                    for (_iterator216.s(); !(_step216 = _iterator216.n()).done;) {
                      var _o14 = _step216.value;
                      var _u22 = this.decl(_n24).old(_n24, _o14);
                      if (_n24 === "align-self") {
                        var _c6 = t[_n24] && t[_n24].prefixes;
                        if (_c6) {
                          if (_o14 === "-webkit- 2009" && _c6.includes("-webkit-")) continue;
                          if (_o14 === "-webkit-" && _c6.includes("-webkit- 2009")) continue;
                        }
                      }
                      var _iterator217 = _createForOfIteratorHelper(_u22),
                        _step217;
                      try {
                        for (_iterator217.s(); !(_step217 = _iterator217.n()).done;) {
                          var _c7 = _step217.value;
                          r[_c7] || (r[_c7] = {}), r[_c7].remove = !0;
                        }
                      } catch (err) {
                        _iterator217.e(err);
                      } finally {
                        _iterator217.f();
                      }
                    }
                  } catch (err) {
                    _iterator216.e(err);
                  } finally {
                    _iterator216.f();
                  }
                }
              }
            }
            return [t, r];
          }
        }, {
          key: "decl",
          value: function decl(e) {
            return Kl.has(e) || Kl.set(e, B.load(e)), Kl.get(e);
          }
        }, {
          key: "unprefixed",
          value: function unprefixed(e) {
            var t = this.normalize(Gw.unprefixed(e));
            return t === "flex-direction" && (t = "flex-flow"), t;
          }
        }, {
          key: "normalize",
          value: function normalize(e) {
            return this.decl(e).normalize(e);
          }
        }, {
          key: "prefixed",
          value: function prefixed(e, t) {
            return e = Gw.unprefixed(e), this.decl(e).prefixed(e, t);
          }
        }, {
          key: "values",
          value: function values(e, t) {
            var r = this[e],
              n = r["*"] && r["*"].values,
              a = r[t] && r[t].values;
            return n && a ? nr.uniq(n.concat(a)) : n || a || [];
          }
        }, {
          key: "group",
          value: function group(e) {
            var _this41 = this;
            var t = e.parent,
              r = t.index(e),
              n = t.nodes.length,
              a = this.unprefixed(e.prop),
              s = function s(o, u) {
                for (r += o; r >= 0 && r < n;) {
                  var c = t.nodes[r];
                  if (c.type === "decl") {
                    if (o === -1 && c.prop === a && !Xl.withPrefix(c.value) || _this41.unprefixed(c.prop) !== a) break;
                    if (u(c) === !0) return !0;
                    if (o === 1 && c.prop === a && !Xl.withPrefix(c.value)) break;
                  }
                  r += o;
                }
                return !1;
              };
            return {
              up: function up(o) {
                return s(-1, o);
              },
              down: function down(o) {
                return s(1, o);
              }
            };
          }
        }]);
      }();
    Yw.exports = si;
  });
  var Xw = v(function (TI, Jw) {
    l();
    Jw.exports = {
      "backdrop-filter": {
        feature: "css-backdrop-filter",
        browsers: ["ios_saf 16.1", "ios_saf 16.3", "ios_saf 16.4", "ios_saf 16.5", "safari 16.5"]
      },
      element: {
        props: ["background", "background-image", "border-image", "mask", "list-style", "list-style-image", "content", "mask-image"],
        feature: "css-element-function",
        browsers: ["firefox 114"]
      },
      "user-select": {
        mistakes: ["-khtml-"],
        feature: "user-select-none",
        browsers: ["ios_saf 16.1", "ios_saf 16.3", "ios_saf 16.4", "ios_saf 16.5", "safari 16.5"]
      },
      "background-clip": {
        feature: "background-clip-text",
        browsers: ["and_chr 114", "and_uc 15.5", "chrome 109", "chrome 113", "chrome 114", "edge 114", "opera 99", "samsung 21"]
      },
      hyphens: {
        feature: "css-hyphens",
        browsers: ["ios_saf 16.1", "ios_saf 16.3", "ios_saf 16.4", "ios_saf 16.5", "safari 16.5"]
      },
      fill: {
        props: ["width", "min-width", "max-width", "height", "min-height", "max-height", "inline-size", "min-inline-size", "max-inline-size", "block-size", "min-block-size", "max-block-size", "grid", "grid-template", "grid-template-rows", "grid-template-columns", "grid-auto-columns", "grid-auto-rows"],
        feature: "intrinsic-width",
        browsers: ["and_chr 114", "and_uc 15.5", "chrome 109", "chrome 113", "chrome 114", "edge 114", "opera 99", "samsung 21"]
      },
      "fill-available": {
        props: ["width", "min-width", "max-width", "height", "min-height", "max-height", "inline-size", "min-inline-size", "max-inline-size", "block-size", "min-block-size", "max-block-size", "grid", "grid-template", "grid-template-rows", "grid-template-columns", "grid-auto-columns", "grid-auto-rows"],
        feature: "intrinsic-width",
        browsers: ["and_chr 114", "and_uc 15.5", "chrome 109", "chrome 113", "chrome 114", "edge 114", "opera 99", "samsung 21"]
      },
      stretch: {
        props: ["width", "min-width", "max-width", "height", "min-height", "max-height", "inline-size", "min-inline-size", "max-inline-size", "block-size", "min-block-size", "max-block-size", "grid", "grid-template", "grid-template-rows", "grid-template-columns", "grid-auto-columns", "grid-auto-rows"],
        feature: "intrinsic-width",
        browsers: ["firefox 114"]
      },
      "fit-content": {
        props: ["width", "min-width", "max-width", "height", "min-height", "max-height", "inline-size", "min-inline-size", "max-inline-size", "block-size", "min-block-size", "max-block-size", "grid", "grid-template", "grid-template-rows", "grid-template-columns", "grid-auto-columns", "grid-auto-rows"],
        feature: "intrinsic-width",
        browsers: ["firefox 114"]
      },
      "text-decoration-style": {
        feature: "text-decoration",
        browsers: ["ios_saf 16.1", "ios_saf 16.3", "ios_saf 16.4", "ios_saf 16.5"]
      },
      "text-decoration-color": {
        feature: "text-decoration",
        browsers: ["ios_saf 16.1", "ios_saf 16.3", "ios_saf 16.4", "ios_saf 16.5"]
      },
      "text-decoration-line": {
        feature: "text-decoration",
        browsers: ["ios_saf 16.1", "ios_saf 16.3", "ios_saf 16.4", "ios_saf 16.5"]
      },
      "text-decoration": {
        feature: "text-decoration",
        browsers: ["ios_saf 16.1", "ios_saf 16.3", "ios_saf 16.4", "ios_saf 16.5"]
      },
      "text-decoration-skip": {
        feature: "text-decoration",
        browsers: ["ios_saf 16.1", "ios_saf 16.3", "ios_saf 16.4", "ios_saf 16.5"]
      },
      "text-decoration-skip-ink": {
        feature: "text-decoration",
        browsers: ["ios_saf 16.1", "ios_saf 16.3", "ios_saf 16.4", "ios_saf 16.5"]
      },
      "text-size-adjust": {
        feature: "text-size-adjust",
        browsers: ["ios_saf 16.1", "ios_saf 16.3", "ios_saf 16.4", "ios_saf 16.5"]
      },
      "mask-clip": {
        feature: "css-masks",
        browsers: ["and_chr 114", "and_uc 15.5", "chrome 109", "chrome 113", "chrome 114", "edge 114", "opera 99", "samsung 21"]
      },
      "mask-composite": {
        feature: "css-masks",
        browsers: ["and_chr 114", "and_uc 15.5", "chrome 109", "chrome 113", "chrome 114", "edge 114", "opera 99", "samsung 21"]
      },
      "mask-image": {
        feature: "css-masks",
        browsers: ["and_chr 114", "and_uc 15.5", "chrome 109", "chrome 113", "chrome 114", "edge 114", "opera 99", "samsung 21"]
      },
      "mask-origin": {
        feature: "css-masks",
        browsers: ["and_chr 114", "and_uc 15.5", "chrome 109", "chrome 113", "chrome 114", "edge 114", "opera 99", "samsung 21"]
      },
      "mask-repeat": {
        feature: "css-masks",
        browsers: ["and_chr 114", "and_uc 15.5", "chrome 109", "chrome 113", "chrome 114", "edge 114", "opera 99", "samsung 21"]
      },
      "mask-border-repeat": {
        feature: "css-masks",
        browsers: ["and_chr 114", "and_uc 15.5", "chrome 109", "chrome 113", "chrome 114", "edge 114", "opera 99", "samsung 21"]
      },
      "mask-border-source": {
        feature: "css-masks",
        browsers: ["and_chr 114", "and_uc 15.5", "chrome 109", "chrome 113", "chrome 114", "edge 114", "opera 99", "samsung 21"]
      },
      mask: {
        feature: "css-masks",
        browsers: ["and_chr 114", "and_uc 15.5", "chrome 109", "chrome 113", "chrome 114", "edge 114", "opera 99", "samsung 21"]
      },
      "mask-position": {
        feature: "css-masks",
        browsers: ["and_chr 114", "and_uc 15.5", "chrome 109", "chrome 113", "chrome 114", "edge 114", "opera 99", "samsung 21"]
      },
      "mask-size": {
        feature: "css-masks",
        browsers: ["and_chr 114", "and_uc 15.5", "chrome 109", "chrome 113", "chrome 114", "edge 114", "opera 99", "samsung 21"]
      },
      "mask-border": {
        feature: "css-masks",
        browsers: ["and_chr 114", "and_uc 15.5", "chrome 109", "chrome 113", "chrome 114", "edge 114", "opera 99", "samsung 21"]
      },
      "mask-border-outset": {
        feature: "css-masks",
        browsers: ["and_chr 114", "and_uc 15.5", "chrome 109", "chrome 113", "chrome 114", "edge 114", "opera 99", "samsung 21"]
      },
      "mask-border-width": {
        feature: "css-masks",
        browsers: ["and_chr 114", "and_uc 15.5", "chrome 109", "chrome 113", "chrome 114", "edge 114", "opera 99", "samsung 21"]
      },
      "mask-border-slice": {
        feature: "css-masks",
        browsers: ["and_chr 114", "and_uc 15.5", "chrome 109", "chrome 113", "chrome 114", "edge 114", "opera 99", "samsung 21"]
      },
      "clip-path": {
        feature: "css-clip-path",
        browsers: ["samsung 21"]
      },
      "box-decoration-break": {
        feature: "css-boxdecorationbreak",
        browsers: ["and_chr 114", "and_uc 15.5", "chrome 109", "chrome 113", "chrome 114", "edge 114", "ios_saf 16.1", "ios_saf 16.3", "ios_saf 16.4", "ios_saf 16.5", "opera 99", "safari 16.5", "samsung 21"]
      },
      appearance: {
        feature: "css-appearance",
        browsers: ["samsung 21"]
      },
      "image-set": {
        props: ["background", "background-image", "border-image", "cursor", "mask", "mask-image", "list-style", "list-style-image", "content"],
        feature: "css-image-set",
        browsers: ["and_uc 15.5", "chrome 109", "samsung 21"]
      },
      "cross-fade": {
        props: ["background", "background-image", "border-image", "mask", "list-style", "list-style-image", "content", "mask-image"],
        feature: "css-cross-fade",
        browsers: ["and_chr 114", "and_uc 15.5", "chrome 109", "chrome 113", "chrome 114", "edge 114", "opera 99", "samsung 21"]
      },
      isolate: {
        props: ["unicode-bidi"],
        feature: "css-unicode-bidi",
        browsers: ["ios_saf 16.1", "ios_saf 16.3", "ios_saf 16.4", "ios_saf 16.5", "safari 16.5"]
      },
      "color-adjust": {
        feature: "css-color-adjust",
        browsers: ["chrome 109", "chrome 113", "chrome 114", "edge 114", "opera 99"]
      }
    };
  });
  var Zw = v(function (PI, Kw) {
    l();
    Kw.exports = {};
  });
  var ib = v(function (DI, rb) {
    l();
    var oO = zo(),
      _ref342 = ($n(), Ln),
      lO = _ref342.agents,
      Zl = hm(),
      uO = dt(),
      fO = Qw(),
      cO = Xw(),
      pO = Zw(),
      eb = {
        browsers: lO,
        prefixes: cO
      },
      tb = "\n  Replace Autoprefixer `browsers` option to Browserslist config.\n  Use `browserslist` key in `package.json` or `.browserslistrc` file.\n\n  Using `browsers` option can cause errors. Browserslist config can\n  be used for Babel, Autoprefixer, postcss-normalize and other tools.\n\n  If you really need to use option, rename it to `overrideBrowserslist`.\n\n  Learn more at:\n  https://github.com/browserslist/browserslist#readme\n  https://twitter.com/browserslist\n\n";
    function dO(i) {
      return Object.prototype.toString.apply(i) === "[object Object]";
    }
    var eu = new Map();
    function hO(i, e) {
      e.browsers.selected.length !== 0 && (e.add.selectors.length > 0 || Object.keys(e.add).length > 2 || i.warn("Autoprefixer target browsers do not need any prefixes.You do not need Autoprefixer anymore.\nCheck your Browserslist config to be sure that your targets are set up correctly.\n\n  Learn more at:\n  https://github.com/postcss/autoprefixer#readme\n  https://github.com/browserslist/browserslist#readme\n\n"));
    }
    rb.exports = sr;
    function sr() {
      for (var _len15 = arguments.length, i = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
        i[_key15] = arguments[_key15];
      }
      var e;
      if (i.length === 1 && dO(i[0]) ? (e = i[0], i = void 0) : i.length === 0 || i.length === 1 && !i[0] ? i = void 0 : i.length <= 2 && (Array.isArray(i[0]) || !i[0]) ? (e = i[1], i = i[0]) : _typeof(i[i.length - 1]) == "object" && (e = i.pop()), e || (e = {}), e.browser) throw new Error("Change `browser` option to `overrideBrowserslist` in Autoprefixer");
      if (e.browserslist) throw new Error("Change `browserslist` option to `overrideBrowserslist` in Autoprefixer");
      e.overrideBrowserslist ? i = e.overrideBrowserslist : e.browsers && (typeof console != "undefined" && console.warn && (Zl.red ? console.warn(Zl.red(tb.replace(/`[^`]+`/g, function (n) {
        return Zl.yellow(n.slice(1, -1));
      }))) : console.warn(tb)), i = e.browsers);
      var t = {
        ignoreUnknownVersions: e.ignoreUnknownVersions,
        stats: e.stats,
        env: e.env
      };
      function r(n) {
        var a = eb,
          s = new uO(a.browsers, i, n, t),
          o = s.selected.join(", ") + JSON.stringify(e);
        return eu.has(o) || eu.set(o, new fO(a.prefixes, s, e)), eu.get(o);
      }
      return {
        postcssPlugin: "autoprefixer",
        prepare: function prepare(n) {
          var a = r({
            from: n.opts.from,
            env: e.env
          });
          return {
            OnceExit: function OnceExit(s) {
              hO(n, a), e.remove !== !1 && a.processor.remove(s, n), e.add !== !1 && a.processor.add(s, n);
            }
          };
        },
        info: function info(n) {
          return n = n || {}, n.from = n.from || h.cwd(), pO(r(n));
        },
        options: e,
        browsers: i
      };
    }
    sr.postcss = !0;
    sr.data = eb;
    sr.defaults = oO.defaults;
    sr.info = function () {
      return sr().info();
    };
  });
  var nb = {};
  Ae(nb, {
    "default": function _default() {
      return mO;
    }
  });
  var mO,
    sb = C(function () {
      l();
      mO = [];
    });
  var ob = {};
  Ae(ob, {
    "default": function _default() {
      return gO;
    }
  });
  var ab,
    gO,
    lb = C(function () {
      l();
      hi();
      ab = X(bi()), gO = Ze(ab["default"].theme);
    });
  var fb = {};
  Ae(fb, {
    "default": function _default() {
      return yO;
    }
  });
  var ub,
    yO,
    cb = C(function () {
      l();
      hi();
      ub = X(bi()), yO = Ze(ub["default"]);
    });
  l();
  "use strict";
  var wO = Je(pm()),
    bO = Je(ge()),
    vO = Je(ib()),
    xO = Je((sb(), nb)),
    kO = Je((lb(), ob)),
    SO = Je((cb(), fb)),
    CO = Je((Zn(), bu)),
    AO = Je((mo(), ho)),
    _O = Je((hs(), Ku));
  function Je(i) {
    return i && i.__esModule ? i : {
      "default": i
    };
  }
  console.warn("cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation");
  var Hn = "tailwind",
    tu = "text/tailwindcss",
    pb = "/template.html",
    kt,
    db = !0,
    hb = 0,
    ru = new Set(),
    iu,
    mb = "",
    gb = function gb() {
      var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
      return {
        get: function get(e, t) {
          return (!i || t === "config") && _typeof(e[t]) == "object" && e[t] !== null ? new Proxy(e[t], gb()) : e[t];
        },
        set: function set(e, t, r) {
          return e[t] = r, (!i || t === "config") && nu(!0), !0;
        }
      };
    };
  window[Hn] = new Proxy({
    config: {},
    defaultTheme: kO["default"],
    defaultConfig: SO["default"],
    colors: CO["default"],
    plugin: AO["default"],
    resolveConfig: _O["default"]
  }, gb(!0));
  function yb(i) {
    iu.observe(i, {
      attributes: !0,
      attributeFilter: ["type"],
      characterData: !0,
      subtree: !0,
      childList: !0
    });
  }
  new MutationObserver( /*#__PURE__*/function () {
    var _ref343 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(i) {
      var e, _iterator218, _step218, t, _iterator219, _step219, _t15, _iterator220, _step220, r;
      return _regeneratorRuntime().wrap(function _callee10$(_context27) {
        while (1) switch (_context27.prev = _context27.next) {
          case 0:
            e = !1;
            if (!iu) {
              iu = new MutationObserver( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
                return _regeneratorRuntime().wrap(function _callee9$(_context26) {
                  while (1) switch (_context26.prev = _context26.next) {
                    case 0:
                      _context26.next = 2;
                      return nu(!0);
                    case 2:
                      return _context26.abrupt("return", _context26.sent);
                    case 3:
                    case "end":
                      return _context26.stop();
                  }
                }, _callee9);
              })));
              _iterator218 = _createForOfIteratorHelper(document.querySelectorAll("style[type=\"".concat(tu, "\"]")));
              try {
                for (_iterator218.s(); !(_step218 = _iterator218.n()).done;) {
                  t = _step218.value;
                  yb(t);
                }
              } catch (err) {
                _iterator218.e(err);
              } finally {
                _iterator218.f();
              }
            }
            _iterator219 = _createForOfIteratorHelper(i);
            try {
              for (_iterator219.s(); !(_step219 = _iterator219.n()).done;) {
                _t15 = _step219.value;
                _iterator220 = _createForOfIteratorHelper(_t15.addedNodes);
                try {
                  for (_iterator220.s(); !(_step220 = _iterator220.n()).done;) {
                    r = _step220.value;
                    r.nodeType === 1 && r.tagName === "STYLE" && r.getAttribute("type") === tu && (yb(r), e = !0);
                  }
                } catch (err) {
                  _iterator220.e(err);
                } finally {
                  _iterator220.f();
                }
              }
            } catch (err) {
              _iterator219.e(err);
            } finally {
              _iterator219.f();
            }
            _context27.next = 6;
            return nu(e);
          case 6:
          case "end":
            return _context27.stop();
        }
      }, _callee10);
    }));
    return function (_x17) {
      return _ref343.apply(this, arguments);
    };
  }()).observe(document.documentElement, {
    attributes: !0,
    attributeFilter: ["class"],
    childList: !0,
    subtree: !0
  });
  function nu() {
    return _nu.apply(this, arguments);
  }
  function _nu() {
    _nu = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
      var i,
        e,
        _iterator221,
        _step221,
        _r17,
        t,
        _iterator222,
        _step222,
        _r18,
        _iterator224,
        _step224,
        _n25,
        _iterator223,
        _step223,
        n,
        _yield$process,
        r,
        _args28 = arguments;
      return _regeneratorRuntime().wrap(function _callee11$(_context28) {
        while (1) switch (_context28.prev = _context28.next) {
          case 0:
            i = _args28.length > 0 && _args28[0] !== undefined ? _args28[0] : !1;
            i && (hb++, ru.clear());
            e = "";
            _iterator221 = _createForOfIteratorHelper(document.querySelectorAll("style[type=\"".concat(tu, "\"]")));
            try {
              for (_iterator221.s(); !(_step221 = _iterator221.n()).done;) {
                _r17 = _step221.value;
                e += _r17.textContent;
              }
            } catch (err) {
              _iterator221.e(err);
            } finally {
              _iterator221.f();
            }
            t = new Set();
            _iterator222 = _createForOfIteratorHelper(document.querySelectorAll("[class]"));
            try {
              for (_iterator222.s(); !(_step222 = _iterator222.n()).done;) {
                _r18 = _step222.value;
                _iterator224 = _createForOfIteratorHelper(_r18.classList);
                try {
                  for (_iterator224.s(); !(_step224 = _iterator224.n()).done;) {
                    _n25 = _step224.value;
                    ru.has(_n25) || t.add(_n25);
                  }
                } catch (err) {
                  _iterator224.e(err);
                } finally {
                  _iterator224.f();
                }
              }
            } catch (err) {
              _iterator222.e(err);
            } finally {
              _iterator222.f();
            }
            if (!(document.body && (db || t.size > 0 || e !== mb || !kt || !kt.isConnected))) {
              _context28.next = 17;
              break;
            }
            _iterator223 = _createForOfIteratorHelper(t);
            try {
              for (_iterator223.s(); !(_step223 = _iterator223.n()).done;) {
                n = _step223.value;
                ru.add(n);
              }
            } catch (err) {
              _iterator223.e(err);
            } finally {
              _iterator223.f();
            }
            db = !1, mb = e, self[pb] = Array.from(t).join(" ");
            _context28.next = 14;
            return (0, bO["default"])([(0, wO["default"])(_objectSpread(_objectSpread({}, window[Hn].config), {}, {
              _hash: hb,
              content: {
                files: [pb],
                extract: {
                  html: function html(n) {
                    return n.split(" ");
                  }
                }
              },
              plugins: [].concat(_toConsumableArray(xO["default"]), _toConsumableArray(Array.isArray(window[Hn].config.plugins) ? window[Hn].config.plugins : []))
            })), (0, vO["default"])({
              remove: !1
            })]).process("@tailwind base;@tailwind components;@tailwind utilities;".concat(e));
          case 14:
            _yield$process = _context28.sent;
            r = _yield$process.css;
            (!kt || !kt.isConnected) && (kt = document.createElement("style"), document.head.append(kt)), kt.textContent = r;
          case 17:
          case "end":
            return _context28.stop();
        }
      }, _callee11);
    }));
    return _nu.apply(this, arguments);
  }
})();
/*! https://mths.be/cssesc v3.0.0 by @mathias */

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.7.1
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-08-28T13:37Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket trac-14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var version = "3.7.1",

	rhtmlSuffix = /HTML$/i,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},


	// Retrieve the text value of an array of DOM nodes
	text: function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {

			// If no nodeType, this is expected to be an array
			while ( ( node = elem[ i++ ] ) ) {

				// Do not traverse comment nodes
				ret += jQuery.text( node );
			}
		}
		if ( nodeType === 1 || nodeType === 11 ) {
			return elem.textContent;
		}
		if ( nodeType === 9 ) {
			return elem.documentElement.textContent;
		}
		if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}

		// Do not include comment or processing instruction nodes

		return ret;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	isXMLDoc: function( elem ) {
		var namespace = elem && elem.namespaceURI,
			docElem = elem && ( elem.ownerDocument || elem ).documentElement;

		// Assume HTML when documentElement doesn't yet exist, such as inside
		// document fragments.
		return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}


function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var pop = arr.pop;


var sort = arr.sort;


var splice = arr.splice;


var whitespace = "[\\x20\\t\\r\\n\\f]";


var rtrimCSS = new RegExp(
	"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
	"g"
);




// Note: an element does not contain itself
jQuery.contains = function( a, b ) {
	var bup = b && b.parentNode;

	return a === bup || !!( bup && bup.nodeType === 1 && (

		// Support: IE 9 - 11+
		// IE doesn't have `contains` on SVG.
		a.contains ?
			a.contains( bup ) :
			a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
	) );
};




// CSS string/identifier serialization
// https://drafts.csswg.org/cssom/#common-serializing-idioms
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

function fcssescape( ch, asCodePoint ) {
	if ( asCodePoint ) {

		// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
		if ( ch === "\0" ) {
			return "\uFFFD";
		}

		// Control characters and (dependent upon position) numbers get escaped as code points
		return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
	}

	// Other potentially-special ASCII characters get backslash-escaped
	return "\\" + ch;
}

jQuery.escapeSelector = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};




var preferredDoc = document,
	pushNative = push;

( function() {

var i,
	Expr,
	outermostContext,
	sortInput,
	hasDuplicate,
	push = pushNative,

	// Local document vars
	document,
	documentElement,
	documentIsHTML,
	rbuggyQSA,
	matches,

	// Instance-specific data
	expando = jQuery.expando,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
		"loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
		whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		ID: new RegExp( "^#(" + identifier + ")" ),
		CLASS: new RegExp( "^\\.(" + identifier + ")" ),
		TAG: new RegExp( "^(" + identifier + "|[*])" ),
		ATTR: new RegExp( "^" + attributes ),
		PSEUDO: new RegExp( "^" + pseudos ),
		CHILD: new RegExp(
			"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
				whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
				whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		needsContext: new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		if ( nonHex ) {

			// Strip the backslash prefix from a non-hex escape sequence
			return nonHex;
		}

		// Replace a hexadecimal escape sequence with the encoded Unicode code point
		// Support: IE <=11+
		// For values outside the Basic Multilingual Plane (BMP), manually construct a
		// surrogate pair
		return high < 0 ?
			String.fromCharCode( high + 0x10000 ) :
			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes; see `setDocument`.
	// Support: IE 9 - 11+, Edge 12 - 18+
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE/Edge.
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && nodeName( elem, "fieldset" );
		},
		{ dir: "parentNode", next: "legend" }
	);

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android <=4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = {
		apply: function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		},
		call: function( target ) {
			pushNative.apply( target, slice.call( arguments, 1 ) );
		}
	};
}

function find( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE 9 only
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								push.call( results, elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE 9 only
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							find.contains( context, elem ) &&
							elem.id === m ) {

							push.call( results, elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( !nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when
					// strict-comparing two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( newContext != context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = jQuery.escapeSelector( nid );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrimCSS, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties
		// (see https://github.com/jquery/sizzle/issues/157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by jQuery selector module
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		return nodeName( elem, "input" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
			elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11+
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a jQuery selector context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [node] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
function setDocument( node ) {
	var subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	documentElement = document.documentElement;
	documentIsHTML = !jQuery.isXMLDoc( document );

	// Support: iOS 7 only, IE 9 - 11+
	// Older browsers didn't support unprefixed `matches`.
	matches = documentElement.matches ||
		documentElement.webkitMatchesSelector ||
		documentElement.msMatchesSelector;

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors
	// (see trac-13936).
	// Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
	// all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
	if ( documentElement.msMatchesSelector &&

		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 9 - 11+, Edge 12 - 18+
		subWindow.addEventListener( "unload", unloadHandler );
	}

	// Support: IE <10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		documentElement.appendChild( el ).id = jQuery.expando;
		return !document.getElementsByName ||
			!document.getElementsByName( jQuery.expando ).length;
	} );

	// Support: IE 9 only
	// Check to see if it's possible to do matchesSelector
	// on a disconnected node.
	support.disconnectedMatch = assert( function( el ) {
		return matches.call( el, "*" );
	} );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// IE/Edge don't support the :scope pseudo-class.
	support.scope = assert( function() {
		return document.querySelectorAll( ":scope" );
	} );

	// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
	// Make sure the `:has()` argument is parsed unforgivingly.
	// We include `*` in the test to detect buggy implementations that are
	// _selectively_ forgiving (specifically when the list includes at least
	// one valid selector).
	// Note that we treat complete lack of support for `:has()` as if it were
	// spec-compliant support, which is fine because use of `:has()` in such
	// environments will fail in the qSA path and fall back to jQuery traversal
	// anyway.
	support.cssHas = assert( function() {
		try {
			document.querySelector( ":has(*,:jqfake)" );
			return false;
		} catch ( e ) {
			return true;
		}
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter.ID = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter.ID =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find.TAG = function( tag, context ) {
		if ( typeof context.getElementsByTagName !== "undefined" ) {
			return context.getElementsByTagName( tag );

		// DocumentFragment nodes don't have gEBTN
		} else {
			return context.querySelectorAll( tag );
		}
	};

	// Class
	Expr.find.CLASS = function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	rbuggyQSA = [];

	// Build QSA regex
	// Regex strategy adopted from Diego Perini
	assert( function( el ) {

		var input;

		documentElement.appendChild( el ).innerHTML =
			"<a id='" + expando + "' href='' disabled='disabled'></a>" +
			"<select id='" + expando + "-\r\\' disabled='disabled'>" +
			"<option selected=''></option></select>";

		// Support: iOS <=7 - 8 only
		// Boolean attributes and "value" are not treated correctly in some XML documents
		if ( !el.querySelectorAll( "[selected]" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
		}

		// Support: iOS <=7 - 8 only
		if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
			rbuggyQSA.push( "~=" );
		}

		// Support: iOS 8 only
		// https://bugs.webkit.org/show_bug.cgi?id=136851
		// In-page `selector#id sibling-combinator selector` fails
		if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
			rbuggyQSA.push( ".#.+[+~]" );
		}

		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		if ( !el.querySelectorAll( ":checked" ).length ) {
			rbuggyQSA.push( ":checked" );
		}

		// Support: Windows 8 Native Apps
		// The type and name attributes are restricted during .innerHTML assignment
		input = document.createElement( "input" );
		input.setAttribute( "type", "hidden" );
		el.appendChild( input ).setAttribute( "name", "D" );

		// Support: IE 9 - 11+
		// IE's :disabled selector does not pick up the children of disabled fieldsets
		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		documentElement.appendChild( el ).disabled = true;
		if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
			rbuggyQSA.push( ":enabled", ":disabled" );
		}

		// Support: IE 11+, Edge 15 - 18+
		// IE 11/Edge don't find elements on a `[name='']` query in some cases.
		// Adding a temporary attribute to the document before the selection works
		// around the issue.
		// Interestingly, IE 10 & older don't seem to have the issue.
		input = document.createElement( "input" );
		input.setAttribute( "name", "" );
		el.appendChild( input );
		if ( !el.querySelectorAll( "[name='']" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
				whitespace + "*(?:''|\"\")" );
		}
	} );

	if ( !support.cssHas ) {

		// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
		// Our regular `try-catch` mechanism fails to detect natively-unsupported
		// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
		// in browsers that parse the `:has()` argument as a forgiving selector list.
		// https://drafts.csswg.org/selectors/#relational now requires the argument
		// to be parsed unforgivingly, but browsers have not yet fully adjusted.
		rbuggyQSA.push( ":has" );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a === document || a.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b === document || b.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	};

	return document;
}

find.matches = function( expr, elements ) {
	return find( expr, null, null, elements );
};

find.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return find( expr, document, null, [ elem ] ).length > 0;
};

find.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return jQuery.contains( context, elem );
};


find.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (see trac-13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	if ( val !== undefined ) {
		return val;
	}

	return elem.getAttribute( name );
};

find.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
jQuery.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	//
	// Support: Android <=4.0+
	// Testing for detecting duplicates is unpredictable so instead assume we can't
	// depend on duplicate detection in all browsers without a stable sort.
	hasDuplicate = !support.sortStable;
	sortInput = !support.sortStable && slice.call( results, 0 );
	sort.call( results, sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			splice.call( results, duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

jQuery.fn.uniqueSort = function() {
	return this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );
};

Expr = jQuery.expr = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		ATTR: function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
				.replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		CHILD: function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					find.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
				);
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

			// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				find.error( match[ 0 ] );
			}

			return match;
		},

		PSEUDO: function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		TAG: function( nodeNameSelector ) {
			var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return nodeName( elem, expectedNodeName );
				};
		},

		CLASS: function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace + ")" + className +
					"(" + whitespace + "|$)" ) ) &&
				classCache( className, function( elem ) {
					return pattern.test(
						typeof elem.className === "string" && elem.className ||
							typeof elem.getAttribute !== "undefined" &&
								elem.getAttribute( "class" ) ||
							""
					);
				} );
		},

		ATTR: function( name, operator, check ) {
			return function( elem ) {
				var result = find.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				if ( operator === "=" ) {
					return result === check;
				}
				if ( operator === "!=" ) {
					return result !== check;
				}
				if ( operator === "^=" ) {
					return check && result.indexOf( check ) === 0;
				}
				if ( operator === "*=" ) {
					return check && result.indexOf( check ) > -1;
				}
				if ( operator === "$=" ) {
					return check && result.slice( -check.length ) === check;
				}
				if ( operator === "~=" ) {
					return ( " " + result.replace( rwhitespace, " " ) + " " )
						.indexOf( check ) > -1;
				}
				if ( operator === "|=" ) {
					return result === check || result.slice( 0, check.length + 1 ) === check + "-";
				}

				return false;
			};
		},

		CHILD: function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || ( parent[ expando ] = {} );
							cache = outerCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {
								outerCache = elem[ expando ] || ( elem[ expando ] = {} );
								cache = outerCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );
											outerCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		PSEUDO: function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// https://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					find.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as jQuery does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		not: markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrimCSS, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element
					// (see https://github.com/jquery/sizzle/issues/299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		has: markFunction( function( selector ) {
			return function( elem ) {
				return find( selector, elem ).length > 0;
			};
		} ),

		contains: markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// https://www.w3.org/TR/selectors/#lang-pseudo
		lang: markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				find.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		target: function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		root: function( elem ) {
			return elem === documentElement;
		},

		focus: function( elem ) {
			return elem === safeActiveElement() &&
				document.hasFocus() &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		enabled: createDisabledPseudo( false ),
		disabled: createDisabledPseudo( true ),

		checked: function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			return ( nodeName( elem, "input" ) && !!elem.checked ) ||
				( nodeName( elem, "option" ) && !!elem.selected );
		},

		selected: function( elem ) {

			// Support: IE <=11+
			// Accessing the selectedIndex property
			// forces the browser to treat the default option as
			// selected when in an optgroup.
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		empty: function( elem ) {

			// https://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		parent: function( elem ) {
			return !Expr.pseudos.empty( elem );
		},

		// Element/input types
		header: function( elem ) {
			return rheader.test( elem.nodeName );
		},

		input: function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		button: function( elem ) {
			return nodeName( elem, "input" ) && elem.type === "button" ||
				nodeName( elem, "button" );
		},

		text: function( elem ) {
			var attr;
			return nodeName( elem, "input" ) && elem.type === "text" &&

				// Support: IE <10 only
				// New HTML5 attribute values (e.g., "search") appear
				// with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		first: createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		last: createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		even: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		odd: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i;

			if ( argument < 0 ) {
				i = argument + length;
			} else if ( argument > length ) {
				i = length;
			} else {
				i = argument;
			}

			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos.nth = Expr.pseudos.eq;

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrimCSS, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	if ( parseOnly ) {
		return soFar.length;
	}

	return soFar ?
		find.error( selector ) :

		// Cache the tokens
		tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						if ( skip && nodeName( elem, skip ) ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = outerCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							outerCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		find( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem, matcherOut,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed ||
				multipleContexts( selector || "*",
					context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems;

		if ( matcher ) {

			// If we have a postFinder, or filtered seed, or non-seed postFilter
			// or preexisting results,
			matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results;

			// Find primary matches
			matcher( matcherIn, matcherOut, context, xml );
		} else {
			matcherOut = matcherIn;
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			var ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element
			// (see https://github.com/jquery/sizzle/issues/299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 )
							.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrimCSS, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find.TAG( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: iOS <=7 - 9 only
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
			// elements by id. (see trac-14142)
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							push.call( results, elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					jQuery.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

function compile( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
}

/**
 * A low-level selection function that works with jQuery's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with jQuery selector compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find.ID(
				token.matches[ 0 ].replace( runescape, funescape ),
				context
			) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) &&
						testContext( context.parentNode ) || context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
}

// One-time assignments

// Support: Android <=4.0 - 4.1+
// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Initialize against the default document
setDocument();

// Support: Android <=4.0 - 4.1+
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

jQuery.find = find;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.unique = jQuery.uniqueSort;

// These have always been private, but they used to be documented as part of
// Sizzle so let's maintain them for now for backwards compatibility purposes.
find.compile = compile;
find.select = select;
find.setDocument = setDocument;
find.tokenize = tokenize;

find.escape = jQuery.escapeSelector;
find.getText = jQuery.text;
find.isXML = jQuery.isXMLDoc;
find.selectors = jQuery.expr;
find.support = jQuery.support;
find.uniqueSort = jQuery.uniqueSort;

	/* eslint-enable */

} )();


var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
	// Strict HTML recognition (trac-11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to jQuery#find
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.error );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the error, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getErrorHook ) {
									process.error = jQuery.Deferred.getErrorHook();

								// The deprecated alias of the above. While the name suggests
								// returning the stack, not an error instance, jQuery just passes
								// it directly to `console.warn` so both will work; an instance
								// just better cooperates with source maps.
								} else if ( jQuery.Deferred.getStackHook ) {
									process.error = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

// If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
// captured before the async barrier to get the original error cause
// which may otherwise be hidden.
jQuery.Deferred.exceptionHook = function( error, asyncError ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message,
			error.stack, asyncError );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See trac-6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (trac-9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see trac-8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (trac-14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (trac-11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (trac-14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (trac-13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (trac-12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (trac-13208)
				// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (trac-13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", true );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, isSetup ) {

	// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
	if ( !isSetup ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				if ( !saved ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					this[ type ]();
					result = dataPriv.get( this, type );
					dataPriv.set( this, type, false );

					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						return result;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering
				// the native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved ) {

				// ...and capture the result
				dataPriv.set( this, type, jQuery.event.trigger(
					saved[ 0 ],
					saved.slice( 1 ),
					this
				) );

				// Abort handling of the native event by all jQuery handlers while allowing
				// native handlers on the same element to run. On target, this is achieved
				// by stopping immediate propagation just on the jQuery event. However,
				// the native event is re-wrapped by a jQuery one on each level of the
				// propagation so the only way to stop it for jQuery is to stop it for
				// everyone via native `stopPropagation()`. This is not a problem for
				// focus/blur which don't bubble, but it does also stop click on checkboxes
				// and radios. We accept this limitation.
				event.stopPropagation();
				event.isImmediatePropagationStopped = returnTrue;
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (trac-504, trac-13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {

	function focusMappedHandler( nativeEvent ) {
		if ( document.documentMode ) {

			// Support: IE 11+
			// Attach a single focusin/focusout handler on the document while someone wants
			// focus/blur. This is because the former are synchronous in IE while the latter
			// are async. In other browsers, all those handlers are invoked synchronously.

			// `handle` from private data would already wrap the event, but we need
			// to change the `type` here.
			var handle = dataPriv.get( this, "handle" ),
				event = jQuery.event.fix( nativeEvent );
			event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
			event.isSimulated = true;

			// First, handle focusin/focusout
			handle( nativeEvent );

			// ...then, handle focus/blur
			//
			// focus/blur don't bubble while focusin/focusout do; simulate the former by only
			// invoking the handler at the lower level.
			if ( event.target === event.currentTarget ) {

				// The setup part calls `leverageNative`, which, in turn, calls
				// `jQuery.event.add`, so event handle will already have been set
				// by this point.
				handle( event );
			}
		} else {

			// For non-IE browsers, attach a single capturing handler on the document
			// while someone wants focusin/focusout.
			jQuery.event.simulate( delegateType, nativeEvent.target,
				jQuery.event.fix( nativeEvent ) );
		}
	}

	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			var attaches;

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, true );

			if ( document.documentMode ) {

				// Support: IE 9 - 11+
				// We use the same native handler for focusin & focus (and focusout & blur)
				// so we need to coordinate setup & teardown parts between those events.
				// Use `delegateType` as the key as `type` is already used by `leverageNative`.
				attaches = dataPriv.get( this, delegateType );
				if ( !attaches ) {
					this.addEventListener( delegateType, focusMappedHandler );
				}
				dataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );
			} else {

				// Return false to allow normal processing in the caller
				return false;
			}
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		teardown: function() {
			var attaches;

			if ( document.documentMode ) {
				attaches = dataPriv.get( this, delegateType ) - 1;
				if ( !attaches ) {
					this.removeEventListener( delegateType, focusMappedHandler );
					dataPriv.remove( this, delegateType );
				} else {
					dataPriv.set( this, delegateType, attaches );
				}
			} else {

				// Return false to indicate standard teardown should be applied
				return false;
			}
		},

		// Suppress native focus or blur if we're currently inside
		// a leveraged native-event stack
		_default: function( event ) {
			return dataPriv.get( event.target, type );
		},

		delegateType: delegateType
	};

	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	//
	// Support: IE 9 - 11+
	// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
	// attach a single handler for both events in IE.
	jQuery.event.special[ delegateType ] = {
		setup: function() {

			// Handle: regular nodes (via `this.ownerDocument`), window
			// (via `this.document`) & document (via `this`).
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType );

			// Support: IE 9 - 11+
			// We use the same native handler for focusin & focus (and focusout & blur)
			// so we need to coordinate setup & teardown parts between those events.
			// Use `delegateType` as the key as `type` is already used by `leverageNative`.
			if ( !attaches ) {
				if ( document.documentMode ) {
					this.addEventListener( delegateType, focusMappedHandler );
				} else {
					doc.addEventListener( type, focusMappedHandler, true );
				}
			}
			dataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );
		},
		teardown: function() {
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType ) - 1;

			if ( !attaches ) {
				if ( document.documentMode ) {
					this.removeEventListener( delegateType, focusMappedHandler );
				} else {
					doc.removeEventListener( type, focusMappedHandler, true );
				}
				dataPriv.remove( dataHolder, delegateType );
			} else {
				dataPriv.set( dataHolder, delegateType, attaches );
			}
		}
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

	rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (trac-8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Re-enable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {

							// Unwrap a CDATA section containing script contents. This shouldn't be
							// needed as in XML documents they're already not visible when
							// inspecting element contents and in HTML documents they have no
							// meaning but we're preserving that logic for backwards compatibility.
							// This will be removed completely in 4.0. See gh-4904.
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew jQuery#find here for performance reasons:
			// https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var rcustomProp = /^--/;


var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (trac-8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "box-sizing:content-box;border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is `display: block`
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		isCustomProp = rcustomProp.test( name ),

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, trac-12537)
	//   .css('--customProperty) (gh-3144)
	if ( computed ) {

		// Support: IE <=9 - 11+
		// IE only supports `"float"` in `getPropertyValue`; in computed styles
		// it's only available as `"cssFloat"`. We no longer modify properties
		// sent to `.css()` apart from camelCasing, so we need to check both.
		// Normally, this would create difference in behavior: if
		// `getPropertyValue` returns an empty string, the value returned
		// by `.css()` would be `undefined`. This is usually the case for
		// disconnected elements. However, in IE even disconnected elements
		// with no styles return `"none"` for `getPropertyValue( "float" )`
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( isCustomProp && ret ) {

			// Support: Firefox 105+, Chrome <=105+
			// Spec requires trimming whitespace for custom properties (gh-4926).
			// Firefox only trims leading whitespace. Chrome just collapses
			// both leading & trailing whitespace to a single space.
			//
			// Fall back to `undefined` if empty string returned.
			// This collapses a missing definition with property defined
			// and set to an empty string but there's no standard API
			// allowing us to differentiate them without a performance penalty
			// and returning `undefined` aligns with older jQuery.
			//
			// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
			// as whitespace while CSS does not, but this is not a problem
			// because CSS preprocessing replaces them with U+000A LINE FEED
			// (which *is* CSS whitespace)
			// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
			ret = ret.replace( rtrimCSS, "$1" ) || undefined;
		}

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0,
		marginDelta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		// Count margin delta separately to only add it after scroll gutter adjustment.
		// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
		if ( box === "margin" ) {
			marginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta + marginDelta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		animationIterationCount: true,
		aspectRatio: true,
		borderImageSlice: true,
		columnCount: true,
		flexGrow: true,
		flexShrink: true,
		fontWeight: true,
		gridArea: true,
		gridColumn: true,
		gridColumnEnd: true,
		gridColumnStart: true,
		gridRow: true,
		gridRowEnd: true,
		gridRowStart: true,
		lineHeight: true,
		opacity: true,
		order: true,
		orphans: true,
		scale: true,
		widows: true,
		zIndex: true,
		zoom: true,

		// SVG-related
		fillOpacity: true,
		floodOpacity: true,
		stopOpacity: true,
		strokeMiterlimit: true,
		strokeOpacity: true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (trac-7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug trac-9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (trac-7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// Use proper attribute retrieval (trac-12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];
						if ( cur.indexOf( " " + className + " " ) < 0 ) {
							cur += className + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );

				// This expression is here for better compressibility (see addClass)
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];

						// Remove *all* instances
						while ( cur.indexOf( " " + className + " " ) > -1 ) {
							cur = cur.replace( " " + className + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var classNames, className, i, self,
			type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		classNames = classesToArray( value );

		return this.each( function() {
			if ( isValidValue ) {

				// Toggle individual class names
				self = jQuery( this );

				for ( i = 0; i < classNames.length; i++ ) {
					className = classNames[ i ];

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (trac-14686, trac-14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (trac-2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (trac-9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (trac-6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// trac-7653, trac-8125, trac-8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes trac-9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (trac-10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket trac-12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// trac-9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (trac-11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// trac-1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see trac-8605, trac-14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// trac-14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this
			.on( "mouseenter", fnOver )
			.on( "mouseleave", fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
// Require that the "whitespace run" starts from a non-whitespace
// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "$1" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (trac-13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./resources/js/lib sync recursive":
/*!********************************!*\
  !*** ./resources/js/lib/ sync ***!
  \********************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./resources/js/lib sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "./node_modules/datatables.net-buttons-dt/js/buttons.dataTables.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/datatables.net-buttons-dt/js/buttons.dataTables.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var datatables_net_dt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! datatables.net-dt */ "./node_modules/datatables.net-dt/js/dataTables.dataTables.mjs");
/* harmony import */ var datatables_net_buttons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! datatables.net-buttons */ "./node_modules/datatables.net-buttons/js/dataTables.buttons.mjs");
/*! DataTables styling wrapper for Buttons
 * © SpryMedia Ltd - datatables.net/license
 */





// Allow reassignment of the $ variable
let $ = jquery__WEBPACK_IMPORTED_MODULE_0__;



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (datatables_net_dt__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/datatables.net-buttons/js/dataTables.buttons.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/datatables.net-buttons/js/dataTables.buttons.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var datatables_net__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! datatables.net */ "./node_modules/datatables.net/js/dataTables.mjs");
/*! Buttons for DataTables 3.0.2
 * © SpryMedia Ltd - datatables.net/license
 */




// Allow reassignment of the $ variable
let $ = jquery__WEBPACK_IMPORTED_MODULE_0__;


// Used for namespacing events added to the document by each instance, so they
// can be removed on destroy
var _instCounter = 0;

// Button namespacing counter for namespacing events on individual buttons
var _buttonCounter = 0;

var _dtButtons = datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].ext.buttons;

// Custom entity decoder for data export
var _entityDecoder = null;

// Allow for jQuery slim
function _fadeIn(el, duration, fn) {
	if ($.fn.animate) {
		el.stop().fadeIn(duration, fn);
	}
	else {
		el.css('display', 'block');

		if (fn) {
			fn.call(el);
		}
	}
}

function _fadeOut(el, duration, fn) {
	if ($.fn.animate) {
		el.stop().fadeOut(duration, fn);
	}
	else {
		el.css('display', 'none');

		if (fn) {
			fn.call(el);
		}
	}
}

/**
 * [Buttons description]
 * @param {[type]}
 * @param {[type]}
 */
var Buttons = function (dt, config) {
	if (!datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].versionCheck('2')) {
		throw 'Warning: Buttons requires DataTables 2 or newer';
	}

	// If not created with a `new` keyword then we return a wrapper function that
	// will take the settings object for a DT. This allows easy use of new instances
	// with the `layout` option - e.g. `topLeft: $.fn.dataTable.Buttons( ... )`.
	if (!(this instanceof Buttons)) {
		return function (settings) {
			return new Buttons(settings, dt).container();
		};
	}

	// If there is no config set it to an empty object
	if (typeof config === 'undefined') {
		config = {};
	}

	// Allow a boolean true for defaults
	if (config === true) {
		config = {};
	}

	// For easy configuration of buttons an array can be given
	if (Array.isArray(config)) {
		config = { buttons: config };
	}

	this.c = $.extend(true, {}, Buttons.defaults, config);

	// Don't want a deep copy for the buttons
	if (config.buttons) {
		this.c.buttons = config.buttons;
	}

	this.s = {
		dt: new datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api(dt),
		buttons: [],
		listenKeys: '',
		namespace: 'dtb' + _instCounter++
	};

	this.dom = {
		container: $('<' + this.c.dom.container.tag + '/>').addClass(
			this.c.dom.container.className
		)
	};

	this._constructor();
};

$.extend(Buttons.prototype, {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Public methods
	 */

	/**
	 * Get the action of a button
	 * @param  {int|string} Button index
	 * @return {function}
	 */ /**
	 * Set the action of a button
	 * @param  {node} node Button element
	 * @param  {function} action Function to set
	 * @return {Buttons} Self for chaining
	 */
	action: function (node, action) {
		var button = this._nodeToButton(node);

		if (action === undefined) {
			return button.conf.action;
		}

		button.conf.action = action;

		return this;
	},

	/**
	 * Add an active class to the button to make to look active or get current
	 * active state.
	 * @param  {node} node Button element
	 * @param  {boolean} [flag] Enable / disable flag
	 * @return {Buttons} Self for chaining or boolean for getter
	 */
	active: function (node, flag) {
		var button = this._nodeToButton(node);
		var klass = this.c.dom.button.active;
		var jqNode = $(button.node);

		if (
			button.inCollection &&
			this.c.dom.collection.button &&
			this.c.dom.collection.button.active !== undefined
		) {
			klass = this.c.dom.collection.button.active;
		}

		if (flag === undefined) {
			return jqNode.hasClass(klass);
		}

		jqNode.toggleClass(klass, flag === undefined ? true : flag);

		return this;
	},

	/**
	 * Add a new button
	 * @param {object} config Button configuration object, base string name or function
	 * @param {int|string} [idx] Button index for where to insert the button
	 * @param {boolean} [draw=true] Trigger a draw. Set a false when adding
	 *   lots of buttons, until the last button.
	 * @return {Buttons} Self for chaining
	 */
	add: function (config, idx, draw) {
		var buttons = this.s.buttons;

		if (typeof idx === 'string') {
			var split = idx.split('-');
			var base = this.s;

			for (var i = 0, ien = split.length - 1; i < ien; i++) {
				base = base.buttons[split[i] * 1];
			}

			buttons = base.buttons;
			idx = split[split.length - 1] * 1;
		}

		this._expandButton(
			buttons,
			config,
			config !== undefined ? config.split : undefined,
			(config === undefined ||
				config.split === undefined ||
				config.split.length === 0) &&
				base !== undefined,
			false,
			idx
		);

		if (draw === undefined || draw === true) {
			this._draw();
		}

		return this;
	},

	/**
	 * Clear buttons from a collection and then insert new buttons
	 */
	collectionRebuild: function (node, newButtons) {
		var button = this._nodeToButton(node);

		if (newButtons !== undefined) {
			var i;
			// Need to reverse the array
			for (i = button.buttons.length - 1; i >= 0; i--) {
				this.remove(button.buttons[i].node);
			}

			// If the collection has prefix and / or postfix buttons we need to add them in
			if (button.conf.prefixButtons) {
				newButtons.unshift.apply(newButtons, button.conf.prefixButtons);
			}

			if (button.conf.postfixButtons) {
				newButtons.push.apply(newButtons, button.conf.postfixButtons);
			}

			for (i = 0; i < newButtons.length; i++) {
				var newBtn = newButtons[i];

				this._expandButton(
					button.buttons,
					newBtn,
					newBtn !== undefined &&
						newBtn.config !== undefined &&
						newBtn.config.split !== undefined,
					true,
					newBtn.parentConf !== undefined &&
						newBtn.parentConf.split !== undefined,
					null,
					newBtn.parentConf
				);
			}
		}

		this._draw(button.collection, button.buttons);
	},

	/**
	 * Get the container node for the buttons
	 * @return {jQuery} Buttons node
	 */
	container: function () {
		return this.dom.container;
	},

	/**
	 * Disable a button
	 * @param  {node} node Button node
	 * @return {Buttons} Self for chaining
	 */
	disable: function (node) {
		var button = this._nodeToButton(node);

		$(button.node)
			.addClass(this.c.dom.button.disabled)
			.prop('disabled', true);

		return this;
	},

	/**
	 * Destroy the instance, cleaning up event handlers and removing DOM
	 * elements
	 * @return {Buttons} Self for chaining
	 */
	destroy: function () {
		// Key event listener
		$('body').off('keyup.' + this.s.namespace);

		// Individual button destroy (so they can remove their own events if
		// needed). Take a copy as the array is modified by `remove`
		var buttons = this.s.buttons.slice();
		var i, ien;

		for (i = 0, ien = buttons.length; i < ien; i++) {
			this.remove(buttons[i].node);
		}

		// Container
		this.dom.container.remove();

		// Remove from the settings object collection
		var buttonInsts = this.s.dt.settings()[0];

		for (i = 0, ien = buttonInsts.length; i < ien; i++) {
			if (buttonInsts.inst === this) {
				buttonInsts.splice(i, 1);
				break;
			}
		}

		return this;
	},

	/**
	 * Enable / disable a button
	 * @param  {node} node Button node
	 * @param  {boolean} [flag=true] Enable / disable flag
	 * @return {Buttons} Self for chaining
	 */
	enable: function (node, flag) {
		if (flag === false) {
			return this.disable(node);
		}

		var button = this._nodeToButton(node);
		$(button.node)
			.removeClass(this.c.dom.button.disabled)
			.prop('disabled', false);

		return this;
	},

	/**
	 * Get a button's index
	 *
	 * This is internally recursive
	 * @param {element} node Button to get the index of
	 * @return {string} Button index
	 */
	index: function (node, nested, buttons) {
		if (!nested) {
			nested = '';
			buttons = this.s.buttons;
		}

		for (var i = 0, ien = buttons.length; i < ien; i++) {
			var inner = buttons[i].buttons;

			if (buttons[i].node === node) {
				return nested + i;
			}

			if (inner && inner.length) {
				var match = this.index(node, i + '-', inner);

				if (match !== null) {
					return match;
				}
			}
		}

		return null;
	},

	/**
	 * Get the instance name for the button set selector
	 * @return {string} Instance name
	 */
	name: function () {
		return this.c.name;
	},

	/**
	 * Get a button's node of the buttons container if no button is given
	 * @param  {node} [node] Button node
	 * @return {jQuery} Button element, or container
	 */
	node: function (node) {
		if (!node) {
			return this.dom.container;
		}

		var button = this._nodeToButton(node);
		return $(button.node);
	},

	/**
	 * Set / get a processing class on the selected button
	 * @param {element} node Triggering button node
	 * @param  {boolean} flag true to add, false to remove, undefined to get
	 * @return {boolean|Buttons} Getter value or this if a setter.
	 */
	processing: function (node, flag) {
		var dt = this.s.dt;
		var button = this._nodeToButton(node);

		if (flag === undefined) {
			return $(button.node).hasClass('processing');
		}

		$(button.node).toggleClass('processing', flag);

		$(dt.table().node()).triggerHandler('buttons-processing.dt', [
			flag,
			dt.button(node),
			dt,
			$(node),
			button.conf
		]);

		return this;
	},

	/**
	 * Remove a button.
	 * @param  {node} node Button node
	 * @return {Buttons} Self for chaining
	 */
	remove: function (node) {
		var button = this._nodeToButton(node);
		var host = this._nodeToHost(node);
		var dt = this.s.dt;

		// Remove any child buttons first
		if (button.buttons.length) {
			for (var i = button.buttons.length - 1; i >= 0; i--) {
				this.remove(button.buttons[i].node);
			}
		}

		button.conf.destroying = true;

		// Allow the button to remove event handlers, etc
		if (button.conf.destroy) {
			button.conf.destroy.call(dt.button(node), dt, $(node), button.conf);
		}

		this._removeKey(button.conf);

		$(button.node).remove();

		var idx = $.inArray(button, host);
		host.splice(idx, 1);

		return this;
	},

	/**
	 * Get the text for a button
	 * @param  {int|string} node Button index
	 * @return {string} Button text
	 */ /**
	 * Set the text for a button
	 * @param  {int|string|function} node Button index
	 * @param  {string} label Text
	 * @return {Buttons} Self for chaining
	 */
	text: function (node, label) {
		var button = this._nodeToButton(node);
		var textNode = button.textNode;
		var dt = this.s.dt;
		var jqNode = $(button.node);
		var text = function (opt) {
			return typeof opt === 'function'
				? opt(dt, jqNode, button.conf)
				: opt;
		};

		if (label === undefined) {
			return text(button.conf.text);
		}

		button.conf.text = label;
		textNode.html(text(label));

		return this;
	},

	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Constructor
	 */

	/**
	 * Buttons constructor
	 * @private
	 */
	_constructor: function () {
		var that = this;
		var dt = this.s.dt;
		var dtSettings = dt.settings()[0];
		var buttons = this.c.buttons;

		if (!dtSettings._buttons) {
			dtSettings._buttons = [];
		}

		dtSettings._buttons.push({
			inst: this,
			name: this.c.name
		});

		for (var i = 0, ien = buttons.length; i < ien; i++) {
			this.add(buttons[i]);
		}

		dt.on('destroy', function (e, settings) {
			if (settings === dtSettings) {
				that.destroy();
			}
		});

		// Global key event binding to listen for button keys
		$('body').on('keyup.' + this.s.namespace, function (e) {
			if (
				!document.activeElement ||
				document.activeElement === document.body
			) {
				// SUse a string of characters for fast lookup of if we need to
				// handle this
				var character = String.fromCharCode(e.keyCode).toLowerCase();

				if (that.s.listenKeys.toLowerCase().indexOf(character) !== -1) {
					that._keypress(character, e);
				}
			}
		});
	},

	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private methods
	 */

	/**
	 * Add a new button to the key press listener
	 * @param {object} conf Resolved button configuration object
	 * @private
	 */
	_addKey: function (conf) {
		if (conf.key) {
			this.s.listenKeys += $.isPlainObject(conf.key)
				? conf.key.key
				: conf.key;
		}
	},

	/**
	 * Insert the buttons into the container. Call without parameters!
	 * @param  {node} [container] Recursive only - Insert point
	 * @param  {array} [buttons] Recursive only - Buttons array
	 * @private
	 */
	_draw: function (container, buttons) {
		if (!container) {
			container = this.dom.container;
			buttons = this.s.buttons;
		}

		container.children().detach();

		for (var i = 0, ien = buttons.length; i < ien; i++) {
			container.append(buttons[i].inserter);
			container.append(' ');

			if (buttons[i].buttons && buttons[i].buttons.length) {
				this._draw(buttons[i].collection, buttons[i].buttons);
			}
		}
	},

	/**
	 * Create buttons from an array of buttons
	 * @param  {array} attachTo Buttons array to attach to
	 * @param  {object} button Button definition
	 * @param  {boolean} inCollection true if the button is in a collection
	 * @private
	 */
	_expandButton: function (
		attachTo,
		button,
		split,
		inCollection,
		inSplit,
		attachPoint,
		parentConf
	) {
		var dt = this.s.dt;
		var isSplit = false;
		var domCollection = this.c.dom.collection;
		var buttons = !Array.isArray(button) ? [button] : button;

		if (button === undefined) {
			buttons = !Array.isArray(split) ? [split] : split;
		}

		for (var i = 0, ien = buttons.length; i < ien; i++) {
			var conf = this._resolveExtends(buttons[i]);

			if (!conf) {
				continue;
			}

			isSplit = conf.config && conf.config.split ? true : false;

			// If the configuration is an array, then expand the buttons at this
			// point
			if (Array.isArray(conf)) {
				this._expandButton(
					attachTo,
					conf,
					built !== undefined && built.conf !== undefined
						? built.conf.split
						: undefined,
					inCollection,
					parentConf !== undefined && parentConf.split !== undefined,
					attachPoint,
					parentConf
				);
				continue;
			}

			var built = this._buildButton(
				conf,
				inCollection,
				conf.split !== undefined ||
					(conf.config !== undefined &&
						conf.config.split !== undefined),
				inSplit
			);
			if (!built) {
				continue;
			}

			if (attachPoint !== undefined && attachPoint !== null) {
				attachTo.splice(attachPoint, 0, built);
				attachPoint++;
			}
			else {
				attachTo.push(built);
			}

			// Create the dropdown for a collection
			if (built.conf.buttons) {
				built.collection = $(
					'<' + domCollection.container.content.tag + '/>'
				);
				built.conf._collection = built.collection;

				$(built.node).append(domCollection.action.dropHtml);

				this._expandButton(
					built.buttons,
					built.conf.buttons,
					built.conf.split,
					!isSplit,
					isSplit,
					attachPoint,
					built.conf
				);
			}

			// And the split collection
			if (built.conf.split) {
				built.collection = $('<' + domCollection.container.tag + '/>');
				built.conf._collection = built.collection;

				for (var j = 0; j < built.conf.split.length; j++) {
					var item = built.conf.split[j];

					if (typeof item === 'object') {
						item.parent = parentConf;

						if (item.collectionLayout === undefined) {
							item.collectionLayout = built.conf.collectionLayout;
						}

						if (item.dropup === undefined) {
							item.dropup = built.conf.dropup;
						}

						if (item.fade === undefined) {
							item.fade = built.conf.fade;
						}
					}
				}

				this._expandButton(
					built.buttons,
					built.conf.buttons,
					built.conf.split,
					!isSplit,
					isSplit,
					attachPoint,
					built.conf
				);
			}

			built.conf.parent = parentConf;

			// init call is made here, rather than buildButton as it needs to
			// be selectable, and for that it needs to be in the buttons array
			if (conf.init) {
				conf.init.call(dt.button(built.node), dt, $(built.node), conf);
			}
		}
	},

	/**
	 * Create an individual button
	 * @param  {object} config            Resolved button configuration
	 * @param  {boolean} inCollection `true` if a collection button
	 * @return {object} Completed button description object
	 * @private
	 */
	_buildButton: function (config, inCollection, isSplit, inSplit) {
		var that = this;
		var configDom = this.c.dom;
		var textNode;
		var dt = this.s.dt;
		var text = function (opt) {
			return typeof opt === 'function' ? opt(dt, button, config) : opt;
		};

		// Create an object that describes the button which can be in `dom.button`, or
		// `dom.collection.button` or `dom.split.button` or `dom.collection.split.button`!
		// Each should extend from `dom.button`.
		var dom = $.extend(true, {}, configDom.button);

		if (inCollection && isSplit && configDom.collection.split) {
			$.extend(true, dom, configDom.collection.split.action);
		}
		else if (inSplit || inCollection) {
			$.extend(true, dom, configDom.collection.button);
		}
		else if (isSplit) {
			$.extend(true, dom, configDom.split.button);
		}

		// Spacers don't do much other than insert an element into the DOM
		if (config.spacer) {
			var spacer = $('<' + dom.spacer.tag + '/>')
				.addClass(
					'dt-button-spacer ' +
						config.style +
						' ' +
						dom.spacer.className
				)
				.html(text(config.text));

			return {
				conf: config,
				node: spacer,
				inserter: spacer,
				buttons: [],
				inCollection: inCollection,
				isSplit: isSplit,
				collection: null,
				textNode: spacer
			};
		}

		// Make sure that the button is available based on whatever requirements
		// it has. For example, PDF button require pdfmake
		if (
			config.available &&
			!config.available(dt, config) &&
			!config.html
		) {
			return false;
		}

		var button;

		if (!config.html) {
			var run = function (e, dt, button, config, done) {
				config.action.call(dt.button(button), e, dt, button, config, done);

				$(dt.table().node()).triggerHandler('buttons-action.dt', [
					dt.button(button),
					dt,
					button,
					config
				]);
			};

			var action = function(e, dt, button, config) {
				if (config.async) {
					that.processing(button[0], true);

					setTimeout(function () {
						run(e, dt, button, config, function () {
							that.processing(button[0], false);
						});
					}, config.async);
				}
				else {
					run(e, dt, button, config, function () {});
				}
			}

			var tag = config.tag || dom.tag;
			var clickBlurs =
				config.clickBlurs === undefined ? true : config.clickBlurs;

			button = $('<' + tag + '/>')
				.addClass(dom.className)
				.attr('tabindex', this.s.dt.settings()[0].iTabIndex)
				.attr('aria-controls', this.s.dt.table().node().id)
				.on('click.dtb', function (e) {
					e.preventDefault();

					if (!button.hasClass(dom.disabled) && config.action) {
						action(e, dt, button, config);
					}

					if (clickBlurs) {
						button.trigger('blur');
					}
				})
				.on('keypress.dtb', function (e) {
					if (e.keyCode === 13) {
						e.preventDefault();

						if (!button.hasClass(dom.disabled) && config.action) {
							action(e, dt, button, config);
						}
					}
				});

			// Make `a` tags act like a link
			if (tag.toLowerCase() === 'a') {
				button.attr('href', '#');
			}

			// Button tags should have `type=button` so they don't have any default behaviour
			if (tag.toLowerCase() === 'button') {
				button.attr('type', 'button');
			}

			if (dom.liner.tag) {
				var liner = $('<' + dom.liner.tag + '/>')
					.html(text(config.text))
					.addClass(dom.liner.className);

				if (dom.liner.tag.toLowerCase() === 'a') {
					liner.attr('href', '#');
				}

				button.append(liner);
				textNode = liner;
			}
			else {
				button.html(text(config.text));
				textNode = button;
			}

			if (config.enabled === false) {
				button.addClass(dom.disabled);
			}

			if (config.className) {
				button.addClass(config.className);
			}

			if (config.titleAttr) {
				button.attr('title', text(config.titleAttr));
			}

			if (config.attr) {
				button.attr(config.attr);
			}

			if (!config.namespace) {
				config.namespace = '.dt-button-' + _buttonCounter++;
			}

			if (config.config !== undefined && config.config.split) {
				config.split = config.config.split;
			}
		}
		else {
			button = $(config.html);
		}

		var buttonContainer = this.c.dom.buttonContainer;
		var inserter;
		if (buttonContainer && buttonContainer.tag) {
			inserter = $('<' + buttonContainer.tag + '/>')
				.addClass(buttonContainer.className)
				.append(button);
		}
		else {
			inserter = button;
		}

		this._addKey(config);

		// Style integration callback for DOM manipulation
		// Note that this is _not_ documented. It is currently
		// for style integration only
		if (this.c.buttonCreated) {
			inserter = this.c.buttonCreated(config, inserter);
		}

		var splitDiv;

		if (isSplit) {
			var dropdownConf = inCollection
				? $.extend(true, this.c.dom.split, this.c.dom.collection.split)
				: this.c.dom.split;
			var wrapperConf = dropdownConf.wrapper;

			splitDiv = $('<' + wrapperConf.tag + '/>')
				.addClass(wrapperConf.className)
				.append(button);

			var dropButtonConfig = $.extend(config, {
				align: dropdownConf.dropdown.align,
				attr: {
					'aria-haspopup': 'dialog',
					'aria-expanded': false
				},
				className: dropdownConf.dropdown.className,
				closeButton: false,
				splitAlignClass: dropdownConf.dropdown.splitAlignClass,
				text: dropdownConf.dropdown.text
			});

			this._addKey(dropButtonConfig);

			var splitAction = function (e, dt, button, config) {
				_dtButtons.split.action.call(
					dt.button(splitDiv),
					e,
					dt,
					button,
					config
				);

				$(dt.table().node()).triggerHandler('buttons-action.dt', [
					dt.button(button),
					dt,
					button,
					config
				]);
				button.attr('aria-expanded', true);
			};

			var dropButton = $(
				'<button class="' +
					dropdownConf.dropdown.className +
					' dt-button"></button>'
			)
				.html(dropdownConf.dropdown.dropHtml)
				.on('click.dtb', function (e) {
					e.preventDefault();
					e.stopPropagation();

					if (!dropButton.hasClass(dom.disabled)) {
						splitAction(e, dt, dropButton, dropButtonConfig);
					}
					if (clickBlurs) {
						dropButton.trigger('blur');
					}
				})
				.on('keypress.dtb', function (e) {
					if (e.keyCode === 13) {
						e.preventDefault();

						if (!dropButton.hasClass(dom.disabled)) {
							splitAction(e, dt, dropButton, dropButtonConfig);
						}
					}
				});

			if (config.split.length === 0) {
				dropButton.addClass('dtb-hide-drop');
			}

			splitDiv.append(dropButton).attr(dropButtonConfig.attr);
		}

		return {
			conf: config,
			node: isSplit ? splitDiv.get(0) : button.get(0),
			inserter: isSplit ? splitDiv : inserter,
			buttons: [],
			inCollection: inCollection,
			isSplit: isSplit,
			inSplit: inSplit,
			collection: null,
			textNode: textNode
		};
	},

	/**
	 * Get the button object from a node (recursive)
	 * @param  {node} node Button node
	 * @param  {array} [buttons] Button array, uses base if not defined
	 * @return {object} Button object
	 * @private
	 */
	_nodeToButton: function (node, buttons) {
		if (!buttons) {
			buttons = this.s.buttons;
		}

		for (var i = 0, ien = buttons.length; i < ien; i++) {
			if (buttons[i].node === node) {
				return buttons[i];
			}

			if (buttons[i].buttons.length) {
				var ret = this._nodeToButton(node, buttons[i].buttons);

				if (ret) {
					return ret;
				}
			}
		}
	},

	/**
	 * Get container array for a button from a button node (recursive)
	 * @param  {node} node Button node
	 * @param  {array} [buttons] Button array, uses base if not defined
	 * @return {array} Button's host array
	 * @private
	 */
	_nodeToHost: function (node, buttons) {
		if (!buttons) {
			buttons = this.s.buttons;
		}

		for (var i = 0, ien = buttons.length; i < ien; i++) {
			if (buttons[i].node === node) {
				return buttons;
			}

			if (buttons[i].buttons.length) {
				var ret = this._nodeToHost(node, buttons[i].buttons);

				if (ret) {
					return ret;
				}
			}
		}
	},

	/**
	 * Handle a key press - determine if any button's key configured matches
	 * what was typed and trigger the action if so.
	 * @param  {string} character The character pressed
	 * @param  {object} e Key event that triggered this call
	 * @private
	 */
	_keypress: function (character, e) {
		// Check if this button press already activated on another instance of Buttons
		if (e._buttonsHandled) {
			return;
		}

		var run = function (conf, node) {
			if (!conf.key) {
				return;
			}

			if (conf.key === character) {
				e._buttonsHandled = true;
				$(node).click();
			}
			else if ($.isPlainObject(conf.key)) {
				if (conf.key.key !== character) {
					return;
				}

				if (conf.key.shiftKey && !e.shiftKey) {
					return;
				}

				if (conf.key.altKey && !e.altKey) {
					return;
				}

				if (conf.key.ctrlKey && !e.ctrlKey) {
					return;
				}

				if (conf.key.metaKey && !e.metaKey) {
					return;
				}

				// Made it this far - it is good
				e._buttonsHandled = true;
				$(node).click();
			}
		};

		var recurse = function (a) {
			for (var i = 0, ien = a.length; i < ien; i++) {
				run(a[i].conf, a[i].node);

				if (a[i].buttons.length) {
					recurse(a[i].buttons);
				}
			}
		};

		recurse(this.s.buttons);
	},

	/**
	 * Remove a key from the key listener for this instance (to be used when a
	 * button is removed)
	 * @param  {object} conf Button configuration
	 * @private
	 */
	_removeKey: function (conf) {
		if (conf.key) {
			var character = $.isPlainObject(conf.key) ? conf.key.key : conf.key;

			// Remove only one character, as multiple buttons could have the
			// same listening key
			var a = this.s.listenKeys.split('');
			var idx = $.inArray(character, a);
			a.splice(idx, 1);
			this.s.listenKeys = a.join('');
		}
	},

	/**
	 * Resolve a button configuration
	 * @param  {string|function|object} conf Button config to resolve
	 * @return {object} Button configuration
	 * @private
	 */
	_resolveExtends: function (conf) {
		var that = this;
		var dt = this.s.dt;
		var i, ien;
		var toConfObject = function (base) {
			var loop = 0;

			// Loop until we have resolved to a button configuration, or an
			// array of button configurations (which will be iterated
			// separately)
			while (!$.isPlainObject(base) && !Array.isArray(base)) {
				if (base === undefined) {
					return;
				}

				if (typeof base === 'function') {
					base = base.call(that, dt, conf);

					if (!base) {
						return false;
					}
				}
				else if (typeof base === 'string') {
					if (!_dtButtons[base]) {
						return { html: base };
					}

					base = _dtButtons[base];
				}

				loop++;
				if (loop > 30) {
					// Protect against misconfiguration killing the browser
					throw 'Buttons: Too many iterations';
				}
			}

			return Array.isArray(base) ? base : $.extend({}, base);
		};

		conf = toConfObject(conf);

		while (conf && conf.extend) {
			// Use `toConfObject` in case the button definition being extended
			// is itself a string or a function
			if (!_dtButtons[conf.extend]) {
				throw 'Cannot extend unknown button type: ' + conf.extend;
			}

			var objArray = toConfObject(_dtButtons[conf.extend]);
			if (Array.isArray(objArray)) {
				return objArray;
			}
			else if (!objArray) {
				// This is a little brutal as it might be possible to have a
				// valid button without the extend, but if there is no extend
				// then the host button would be acting in an undefined state
				return false;
			}

			// Stash the current class name
			var originalClassName = objArray.className;

			if (conf.config !== undefined && objArray.config !== undefined) {
				conf.config = $.extend({}, objArray.config, conf.config);
			}

			conf = $.extend({}, objArray, conf);

			// The extend will have overwritten the original class name if the
			// `conf` object also assigned a class, but we want to concatenate
			// them so they are list that is combined from all extended buttons
			if (originalClassName && conf.className !== originalClassName) {
				conf.className = originalClassName + ' ' + conf.className;
			}

			// Although we want the `conf` object to overwrite almost all of
			// the properties of the object being extended, the `extend`
			// property should come from the object being extended
			conf.extend = objArray.extend;
		}

		// Buttons to be added to a collection  -gives the ability to define
		// if buttons should be added to the start or end of a collection
		var postfixButtons = conf.postfixButtons;
		if (postfixButtons) {
			if (!conf.buttons) {
				conf.buttons = [];
			}

			for (i = 0, ien = postfixButtons.length; i < ien; i++) {
				conf.buttons.push(postfixButtons[i]);
			}
		}

		var prefixButtons = conf.prefixButtons;
		if (prefixButtons) {
			if (!conf.buttons) {
				conf.buttons = [];
			}

			for (i = 0, ien = prefixButtons.length; i < ien; i++) {
				conf.buttons.splice(i, 0, prefixButtons[i]);
			}
		}

		return conf;
	},

	/**
	 * Display (and replace if there is an existing one) a popover attached to a button
	 * @param {string|node} content Content to show
	 * @param {DataTable.Api} hostButton DT API instance of the button
	 * @param {object} inOpts Options (see object below for all options)
	 */
	_popover: function (content, hostButton, inOpts) {
		var dt = hostButton;
		var c = this.c;
		var closed = false;
		var options = $.extend(
			{
				align: 'button-left', // button-right, dt-container, split-left, split-right
				autoClose: false,
				background: true,
				backgroundClassName: 'dt-button-background',
				closeButton: true,
				containerClassName: c.dom.collection.container.className,
				contentClassName: c.dom.collection.container.content.className,
				collectionLayout: '',
				collectionTitle: '',
				dropup: false,
				fade: 400,
				popoverTitle: '',
				rightAlignClassName: 'dt-button-right',
				tag: c.dom.collection.container.tag
			},
			inOpts
		);

		var containerSelector =
			options.tag + '.' + options.containerClassName.replace(/ /g, '.');
		var hostNode = hostButton.node();

		var close = function () {
			closed = true;

			_fadeOut($(containerSelector), options.fade, function () {
				$(this).detach();
			});

			$(
				dt
					.buttons('[aria-haspopup="dialog"][aria-expanded="true"]')
					.nodes()
			).attr('aria-expanded', 'false');

			$('div.dt-button-background').off('click.dtb-collection');
			Buttons.background(
				false,
				options.backgroundClassName,
				options.fade,
				hostNode
			);

			$(window).off('resize.resize.dtb-collection');
			$('body').off('.dtb-collection');
			dt.off('buttons-action.b-internal');
			dt.off('destroy');
		};

		if (content === false) {
			close();
			return;
		}

		var existingExpanded = $(
			dt.buttons('[aria-haspopup="dialog"][aria-expanded="true"]').nodes()
		);
		if (existingExpanded.length) {
			// Reuse the current position if the button that was triggered is inside an existing collection
			if (hostNode.closest(containerSelector).length) {
				hostNode = existingExpanded.eq(0);
			}

			close();
		}

		// Try to be smart about the layout
		var cnt = $('.dt-button', content).length;
		var mod = '';

		if (cnt === 3) {
			mod = 'dtb-b3';
		}
		else if (cnt === 2) {
			mod = 'dtb-b2';
		}
		else if (cnt === 1) {
			mod = 'dtb-b1';
		}

		var display = $('<' + options.tag + '/>')
			.addClass(options.containerClassName)
			.addClass(options.collectionLayout)
			.addClass(options.splitAlignClass)
			.addClass(mod)
			.css('display', 'none')
			.attr({
				'aria-modal': true,
				role: 'dialog'
			});

		content = $(content)
			.addClass(options.contentClassName)
			.attr('role', 'menu')
			.appendTo(display);

		hostNode.attr('aria-expanded', 'true');

		if (hostNode.parents('body')[0] !== document.body) {
			hostNode = document.body.lastChild;
		}

		if (options.popoverTitle) {
			display.prepend(
				'<div class="dt-button-collection-title">' +
					options.popoverTitle +
					'</div>'
			);
		}
		else if (options.collectionTitle) {
			display.prepend(
				'<div class="dt-button-collection-title">' +
					options.collectionTitle +
					'</div>'
			);
		}

		if (options.closeButton) {
			display
				.prepend('<div class="dtb-popover-close">&times;</div>')
				.addClass('dtb-collection-closeable');
		}

		_fadeIn(display.insertAfter(hostNode), options.fade);

		var tableContainer = $(hostButton.table().container());
		var position = display.css('position');

		if (options.span === 'container' || options.align === 'dt-container') {
			hostNode = hostNode.parent();
			display.css('width', tableContainer.width());
		}

		// Align the popover relative to the DataTables container
		// Useful for wide popovers such as SearchPanes
		if (position === 'absolute') {
			// Align relative to the host button
			var offsetParent = $(hostNode[0].offsetParent);
			var buttonPosition = hostNode.position();
			var buttonOffset = hostNode.offset();
			var tableSizes = offsetParent.offset();
			var containerPosition = offsetParent.position();
			var computed = window.getComputedStyle(offsetParent[0]);

			tableSizes.height = offsetParent.outerHeight();
			tableSizes.width =
				offsetParent.width() + parseFloat(computed.paddingLeft);
			tableSizes.right = tableSizes.left + tableSizes.width;
			tableSizes.bottom = tableSizes.top + tableSizes.height;

			// Set the initial position so we can read height / width
			var top = buttonPosition.top + hostNode.outerHeight();
			var left = buttonPosition.left;

			display.css({
				top: top,
				left: left
			});

			// Get the popover position
			computed = window.getComputedStyle(display[0]);
			var popoverSizes = display.offset();

			popoverSizes.height = display.outerHeight();
			popoverSizes.width = display.outerWidth();
			popoverSizes.right = popoverSizes.left + popoverSizes.width;
			popoverSizes.bottom = popoverSizes.top + popoverSizes.height;
			popoverSizes.marginTop = parseFloat(computed.marginTop);
			popoverSizes.marginBottom = parseFloat(computed.marginBottom);

			// First position per the class requirements - pop up and right align
			if (options.dropup) {
				top =
					buttonPosition.top -
					popoverSizes.height -
					popoverSizes.marginTop -
					popoverSizes.marginBottom;
			}

			if (
				options.align === 'button-right' ||
				display.hasClass(options.rightAlignClassName)
			) {
				left =
					buttonPosition.left -
					popoverSizes.width +
					hostNode.outerWidth();
			}

			// Container alignment - make sure it doesn't overflow the table container
			if (
				options.align === 'dt-container' ||
				options.align === 'container'
			) {
				if (left < buttonPosition.left) {
					left = -buttonPosition.left;
				}
			}

			// Window adjustment
			if (
				containerPosition.left + left + popoverSizes.width >
				$(window).width()
			) {
				// Overflowing the document to the right
				left =
					$(window).width() -
					popoverSizes.width -
					containerPosition.left;
			}

			if (buttonOffset.left + left < 0) {
				// Off to the left of the document
				left = -buttonOffset.left;
			}

			if (
				containerPosition.top + top + popoverSizes.height >
				$(window).height() + $(window).scrollTop()
			) {
				// Pop up if otherwise we'd need the user to scroll down
				top =
					buttonPosition.top -
					popoverSizes.height -
					popoverSizes.marginTop -
					popoverSizes.marginBottom;
			}

			if (containerPosition.top + top < $(window).scrollTop()) {
				// Correction for when the top is beyond the top of the page
				top = buttonPosition.top + hostNode.outerHeight();
			}

			// Calculations all done - now set it
			display.css({
				top: top,
				left: left
			});
		}
		else {
			// Fix position - centre on screen
			var place = function () {
				var half = $(window).height() / 2;

				var top = display.height() / 2;
				if (top > half) {
					top = half;
				}

				display.css('marginTop', top * -1);
			};

			place();

			$(window).on('resize.dtb-collection', function () {
				place();
			});
		}

		if (options.background) {
			Buttons.background(
				true,
				options.backgroundClassName,
				options.fade,
				options.backgroundHost || hostNode
			);
		}

		// This is bonkers, but if we don't have a click listener on the
		// background element, iOS Safari will ignore the body click
		// listener below. An empty function here is all that is
		// required to make it work...
		$('div.dt-button-background').on(
			'click.dtb-collection',
			function () {}
		);

		if (options.autoClose) {
			setTimeout(function () {
				dt.on('buttons-action.b-internal', function (e, btn, dt, node) {
					if (node[0] === hostNode[0]) {
						return;
					}
					close();
				});
			}, 0);
		}

		$(display).trigger('buttons-popover.dt');

		dt.on('destroy', close);

		setTimeout(function () {
			closed = false;
			$('body')
				.on('click.dtb-collection', function (e) {
					if (closed) {
						return;
					}

					// andSelf is deprecated in jQ1.8, but we want 1.7 compat
					var back = $.fn.addBack ? 'addBack' : 'andSelf';
					var parent = $(e.target).parent()[0];

					if (
						(!$(e.target).parents()[back]().filter(content)
							.length &&
							!$(parent).hasClass('dt-buttons')) ||
						$(e.target).hasClass('dt-button-background')
					) {
						close();
					}
				})
				.on('keyup.dtb-collection', function (e) {
					if (e.keyCode === 27) {
						close();
					}
				})
				.on('keydown.dtb-collection', function (e) {
					// Focus trap for tab key
					var elements = $('a, button', content);
					var active = document.activeElement;

					if (e.keyCode !== 9) {
						// tab
						return;
					}

					if (elements.index(active) === -1) {
						// If current focus is not inside the popover
						elements.first().focus();
						e.preventDefault();
					}
					else if (e.shiftKey) {
						// Reverse tabbing order when shift key is pressed
						if (active === elements[0]) {
							elements.last().focus();
							e.preventDefault();
						}
					}
					else {
						if (active === elements.last()[0]) {
							elements.first().focus();
							e.preventDefault();
						}
					}
				});
		}, 0);
	}
});

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Statics
 */

/**
 * Show / hide a background layer behind a collection
 * @param  {boolean} Flag to indicate if the background should be shown or
 *   hidden
 * @param  {string} Class to assign to the background
 * @static
 */
Buttons.background = function (show, className, fade, insertPoint) {
	if (fade === undefined) {
		fade = 400;
	}
	if (!insertPoint) {
		insertPoint = document.body;
	}

	if (show) {
		_fadeIn(
			$('<div/>')
				.addClass(className)
				.css('display', 'none')
				.insertAfter(insertPoint),
			fade
		);
	}
	else {
		_fadeOut($('div.' + className), fade, function () {
			$(this).removeClass(className).remove();
		});
	}
};

/**
 * Instance selector - select Buttons instances based on an instance selector
 * value from the buttons assigned to a DataTable. This is only useful if
 * multiple instances are attached to a DataTable.
 * @param  {string|int|array} Instance selector - see `instance-selector`
 *   documentation on the DataTables site
 * @param  {array} Button instance array that was attached to the DataTables
 *   settings object
 * @return {array} Buttons instances
 * @static
 */
Buttons.instanceSelector = function (group, buttons) {
	if (group === undefined || group === null) {
		return $.map(buttons, function (v) {
			return v.inst;
		});
	}

	var ret = [];
	var names = $.map(buttons, function (v) {
		return v.name;
	});

	// Flatten the group selector into an array of single options
	var process = function (input) {
		if (Array.isArray(input)) {
			for (var i = 0, ien = input.length; i < ien; i++) {
				process(input[i]);
			}
			return;
		}

		if (typeof input === 'string') {
			if (input.indexOf(',') !== -1) {
				// String selector, list of names
				process(input.split(','));
			}
			else {
				// String selector individual name
				var idx = $.inArray(input.trim(), names);

				if (idx !== -1) {
					ret.push(buttons[idx].inst);
				}
			}
		}
		else if (typeof input === 'number') {
			// Index selector
			ret.push(buttons[input].inst);
		}
		else if (typeof input === 'object' && input.nodeName) {
			// Element selector
			for (var j = 0; j < buttons.length; j++) {
				if (buttons[j].inst.dom.container[0] === input) {
					ret.push(buttons[j].inst);
				}
			}
		}
		else if (typeof input === 'object') {
			// Actual instance selector
			ret.push(input);
		}
	};

	process(group);

	return ret;
};

/**
 * Button selector - select one or more buttons from a selector input so some
 * operation can be performed on them.
 * @param  {array} Button instances array that the selector should operate on
 * @param  {string|int|node|jQuery|array} Button selector - see
 *   `button-selector` documentation on the DataTables site
 * @return {array} Array of objects containing `inst` and `idx` properties of
 *   the selected buttons so you know which instance each button belongs to.
 * @static
 */
Buttons.buttonSelector = function (insts, selector) {
	var ret = [];
	var nodeBuilder = function (a, buttons, baseIdx) {
		var button;
		var idx;

		for (var i = 0, ien = buttons.length; i < ien; i++) {
			button = buttons[i];

			if (button) {
				idx = baseIdx !== undefined ? baseIdx + i : i + '';

				a.push({
					node: button.node,
					name: button.conf.name,
					idx: idx
				});

				if (button.buttons) {
					nodeBuilder(a, button.buttons, idx + '-');
				}
			}
		}
	};

	var run = function (selector, inst) {
		var i, ien;
		var buttons = [];
		nodeBuilder(buttons, inst.s.buttons);

		var nodes = $.map(buttons, function (v) {
			return v.node;
		});

		if (Array.isArray(selector) || selector instanceof $) {
			for (i = 0, ien = selector.length; i < ien; i++) {
				run(selector[i], inst);
			}
			return;
		}

		if (selector === null || selector === undefined || selector === '*') {
			// Select all
			for (i = 0, ien = buttons.length; i < ien; i++) {
				ret.push({
					inst: inst,
					node: buttons[i].node
				});
			}
		}
		else if (typeof selector === 'number') {
			// Main button index selector
			if (inst.s.buttons[selector]) {
				ret.push({
					inst: inst,
					node: inst.s.buttons[selector].node
				});
			}
		}
		else if (typeof selector === 'string') {
			if (selector.indexOf(',') !== -1) {
				// Split
				var a = selector.split(',');

				for (i = 0, ien = a.length; i < ien; i++) {
					run(a[i].trim(), inst);
				}
			}
			else if (selector.match(/^\d+(\-\d+)*$/)) {
				// Sub-button index selector
				var indexes = $.map(buttons, function (v) {
					return v.idx;
				});

				ret.push({
					inst: inst,
					node: buttons[$.inArray(selector, indexes)].node
				});
			}
			else if (selector.indexOf(':name') !== -1) {
				// Button name selector
				var name = selector.replace(':name', '');

				for (i = 0, ien = buttons.length; i < ien; i++) {
					if (buttons[i].name === name) {
						ret.push({
							inst: inst,
							node: buttons[i].node
						});
					}
				}
			}
			else {
				// jQuery selector on the nodes
				$(nodes)
					.filter(selector)
					.each(function () {
						ret.push({
							inst: inst,
							node: this
						});
					});
			}
		}
		else if (typeof selector === 'object' && selector.nodeName) {
			// Node selector
			var idx = $.inArray(selector, nodes);

			if (idx !== -1) {
				ret.push({
					inst: inst,
					node: nodes[idx]
				});
			}
		}
	};

	for (var i = 0, ien = insts.length; i < ien; i++) {
		var inst = insts[i];

		run(selector, inst);
	}

	return ret;
};

/**
 * Default function used for formatting output data.
 * @param {*} str Data to strip
 */
Buttons.stripData = function (str, config) {
	if (typeof str !== 'string') {
		return str;
	}

	// Always remove script tags
	str = Buttons.stripHtmlScript(str);

	// Always remove comments
	str = Buttons.stripHtmlComments(str);

	if (!config || config.stripHtml) {
		str = datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].util.stripHtml(str);
	}

	if (!config || config.trim) {
		str = str.trim();
	}

	if (!config || config.stripNewlines) {
		str = str.replace(/\n/g, ' ');
	}

	if (!config || config.decodeEntities) {
		if (_entityDecoder) {
			str = _entityDecoder(str);
		}
		else {
			_exportTextarea.innerHTML = str;
			str = _exportTextarea.value;
		}
	}

	return str;
};

/**
 * Provide a custom entity decoding function - e.g. a regex one, which can be
 * much faster than the built in DOM option, but also larger code size.
 * @param {function} fn
 */
Buttons.entityDecoder = function (fn) {
	_entityDecoder = fn;
};

/**
 * Common function for stripping HTML comments
 *
 * @param {*} input 
 * @returns 
 */
Buttons.stripHtmlComments = function (input) {
	var previous;  
	
	do {  
		previous = input;
		input = input.replace(/(<!--.*?--!?>)|(<!--[\S\s]+?--!?>)|(<!--[\S\s]*?$)/g, '');
	} while (input !== previous);  

	return input;  
};

/**
 * Common function for stripping HTML script tags
 *
 * @param {*} input 
 * @returns 
 */
Buttons.stripHtmlScript = function (input) {
	var previous;  
	
	do {  
		previous = input;
		input = input.replace(/<script\b[^<]*(?:(?!<\/script[^>]*>)<[^<]*)*<\/script[^>]*>/gi, '');
	} while (input !== previous);  

	return input;  
};

/**
 * Buttons defaults. For full documentation, please refer to the docs/option
 * directory or the DataTables site.
 * @type {Object}
 * @static
 */
Buttons.defaults = {
	buttons: ['copy', 'excel', 'csv', 'pdf', 'print'],
	name: 'main',
	tabIndex: 0,
	dom: {
		container: {
			tag: 'div',
			className: 'dt-buttons'
		},
		collection: {
			action: {
				// action button
				dropHtml: '<span class="dt-button-down-arrow">&#x25BC;</span>'
			},
			container: {
				// The element used for the dropdown
				className: 'dt-button-collection',
				content: {
					className: '',
					tag: 'div'
				},
				tag: 'div'
			}
			// optionally
			// , button: IButton - buttons inside the collection container
			// , split: ISplit - splits inside the collection container
		},
		button: {
			tag: 'button',
			className: 'dt-button',
			active: 'dt-button-active', // class name
			disabled: 'disabled', // class name
			spacer: {
				className: 'dt-button-spacer',
				tag: 'span'
			},
			liner: {
				tag: 'span',
				className: ''
			}
		},
		split: {
			action: {
				// action button
				className: 'dt-button-split-drop-button dt-button',
				tag: 'button'
			},
			dropdown: {
				// button to trigger the dropdown
				align: 'split-right',
				className: 'dt-button-split-drop',
				dropHtml: '<span class="dt-button-down-arrow">&#x25BC;</span>',
				splitAlignClass: 'dt-button-split-left',
				tag: 'button'
			},
			wrapper: {
				// wrap around both
				className: 'dt-button-split',
				tag: 'div'
			}
		}
	}
};

/**
 * Version information
 * @type {string}
 * @static
 */
Buttons.version = '3.0.2';

$.extend(_dtButtons, {
	collection: {
		text: function (dt) {
			return dt.i18n('buttons.collection', 'Collection');
		},
		className: 'buttons-collection',
		closeButton: false,
		init: function (dt, button) {
			button.attr('aria-expanded', false);
		},
		action: function (e, dt, button, config) {
			if (config._collection.parents('body').length) {
				this.popover(false, config);
			}
			else {
				this.popover(config._collection, config);
			}

			// When activated using a key - auto focus on the
			// first item in the popover
			if (e.type === 'keypress') {
				$('a, button', config._collection).eq(0).focus();
			}
		},
		attr: {
			'aria-haspopup': 'dialog'
		}
		// Also the popover options, defined in Buttons.popover
	},
	split: {
		text: function (dt) {
			return dt.i18n('buttons.split', 'Split');
		},
		className: 'buttons-split',
		closeButton: false,
		init: function (dt, button) {
			return button.attr('aria-expanded', false);
		},
		action: function (e, dt, button, config) {
			this.popover(config._collection, config);
		},
		attr: {
			'aria-haspopup': 'dialog'
		}
		// Also the popover options, defined in Buttons.popover
	},
	copy: function () {
		if (_dtButtons.copyHtml5) {
			return 'copyHtml5';
		}
	},
	csv: function (dt, conf) {
		if (_dtButtons.csvHtml5 && _dtButtons.csvHtml5.available(dt, conf)) {
			return 'csvHtml5';
		}
	},
	excel: function (dt, conf) {
		if (
			_dtButtons.excelHtml5 &&
			_dtButtons.excelHtml5.available(dt, conf)
		) {
			return 'excelHtml5';
		}
	},
	pdf: function (dt, conf) {
		if (_dtButtons.pdfHtml5 && _dtButtons.pdfHtml5.available(dt, conf)) {
			return 'pdfHtml5';
		}
	},
	pageLength: function (dt) {
		var lengthMenu = dt.settings()[0].aLengthMenu;
		var vals = [];
		var lang = [];
		var text = function (dt) {
			return dt.i18n(
				'buttons.pageLength',
				{
					'-1': 'Show all rows',
					_: 'Show %d rows'
				},
				dt.page.len()
			);
		};

		// Support for DataTables 1.x 2D array
		if (Array.isArray(lengthMenu[0])) {
			vals = lengthMenu[0];
			lang = lengthMenu[1];
		}
		else {
			for (var i = 0; i < lengthMenu.length; i++) {
				var option = lengthMenu[i];

				// Support for DataTables 2 object in the array
				if ($.isPlainObject(option)) {
					vals.push(option.value);
					lang.push(option.label);
				}
				else {
					vals.push(option);
					lang.push(option);
				}
			}
		}

		return {
			extend: 'collection',
			text: text,
			className: 'buttons-page-length',
			autoClose: true,
			buttons: $.map(vals, function (val, i) {
				return {
					text: lang[i],
					className: 'button-page-length',
					action: function (e, dt) {
						dt.page.len(val).draw();
					},
					init: function (dt, node, conf) {
						var that = this;
						var fn = function () {
							that.active(dt.page.len() === val);
						};

						dt.on('length.dt' + conf.namespace, fn);
						fn();
					},
					destroy: function (dt, node, conf) {
						dt.off('length.dt' + conf.namespace);
					}
				};
			}),
			init: function (dt, node, conf) {
				var that = this;
				dt.on('length.dt' + conf.namespace, function () {
					that.text(conf.text);
				});
			},
			destroy: function (dt, node, conf) {
				dt.off('length.dt' + conf.namespace);
			}
		};
	},
	spacer: {
		style: 'empty',
		spacer: true,
		text: function (dt) {
			return dt.i18n('buttons.spacer', '');
		}
	}
});

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * DataTables API
 *
 * For complete documentation, please refer to the docs/api directory or the
 * DataTables site
 */

// Buttons group and individual button selector
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.register('buttons()', function (group, selector) {
	// Argument shifting
	if (selector === undefined) {
		selector = group;
		group = undefined;
	}

	this.selector.buttonGroup = group;

	var res = this.iterator(
		true,
		'table',
		function (ctx) {
			if (ctx._buttons) {
				return Buttons.buttonSelector(
					Buttons.instanceSelector(group, ctx._buttons),
					selector
				);
			}
		},
		true
	);

	res._groupSelector = group;
	return res;
});

// Individual button selector
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.register('button()', function (group, selector) {
	// just run buttons() and truncate
	var buttons = this.buttons(group, selector);

	if (buttons.length > 1) {
		buttons.splice(1, buttons.length);
	}

	return buttons;
});

// Active buttons
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.registerPlural(
	'buttons().active()',
	'button().active()',
	function (flag) {
		if (flag === undefined) {
			return this.map(function (set) {
				return set.inst.active(set.node);
			});
		}

		return this.each(function (set) {
			set.inst.active(set.node, flag);
		});
	}
);

// Get / set button action
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.registerPlural(
	'buttons().action()',
	'button().action()',
	function (action) {
		if (action === undefined) {
			return this.map(function (set) {
				return set.inst.action(set.node);
			});
		}

		return this.each(function (set) {
			set.inst.action(set.node, action);
		});
	}
);

// Collection control
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.registerPlural(
	'buttons().collectionRebuild()',
	'button().collectionRebuild()',
	function (buttons) {
		return this.each(function (set) {
			for (var i = 0; i < buttons.length; i++) {
				if (typeof buttons[i] === 'object') {
					buttons[i].parentConf = set;
				}
			}
			set.inst.collectionRebuild(set.node, buttons);
		});
	}
);

// Enable / disable buttons
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.register(
	['buttons().enable()', 'button().enable()'],
	function (flag) {
		return this.each(function (set) {
			set.inst.enable(set.node, flag);
		});
	}
);

// Disable buttons
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.register(
	['buttons().disable()', 'button().disable()'],
	function () {
		return this.each(function (set) {
			set.inst.disable(set.node);
		});
	}
);

// Button index
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.register('button().index()', function () {
	var idx = null;

	this.each(function (set) {
		var res = set.inst.index(set.node);

		if (res !== null) {
			idx = res;
		}
	});

	return idx;
});

// Get button nodes
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.registerPlural(
	'buttons().nodes()',
	'button().node()',
	function () {
		var jq = $();

		// jQuery will automatically reduce duplicates to a single entry
		$(
			this.each(function (set) {
				jq = jq.add(set.inst.node(set.node));
			})
		);

		return jq;
	}
);

// Get / set button processing state
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.registerPlural(
	'buttons().processing()',
	'button().processing()',
	function (flag) {
		if (flag === undefined) {
			return this.map(function (set) {
				return set.inst.processing(set.node);
			});
		}

		return this.each(function (set) {
			set.inst.processing(set.node, flag);
		});
	}
);

// Get / set button text (i.e. the button labels)
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.registerPlural(
	'buttons().text()',
	'button().text()',
	function (label) {
		if (label === undefined) {
			return this.map(function (set) {
				return set.inst.text(set.node);
			});
		}

		return this.each(function (set) {
			set.inst.text(set.node, label);
		});
	}
);

// Trigger a button's action
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.registerPlural(
	'buttons().trigger()',
	'button().trigger()',
	function () {
		return this.each(function (set) {
			set.inst.node(set.node).trigger('click');
		});
	}
);

// Button resolver to the popover
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.register('button().popover()', function (content, options) {
	return this.map(function (set) {
		return set.inst._popover(content, this.button(this[0].node), options);
	});
});

// Get the container elements
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.register('buttons().containers()', function () {
	var jq = $();
	var groupSelector = this._groupSelector;

	// We need to use the group selector directly, since if there are no buttons
	// the result set will be empty
	this.iterator(true, 'table', function (ctx) {
		if (ctx._buttons) {
			var insts = Buttons.instanceSelector(groupSelector, ctx._buttons);

			for (var i = 0, ien = insts.length; i < ien; i++) {
				jq = jq.add(insts[i].container());
			}
		}
	});

	return jq;
});

datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.register('buttons().container()', function () {
	// API level of nesting is `buttons()` so we can zip into the containers method
	return this.containers().eq(0);
});

// Add a new button
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.register('button().add()', function (idx, conf, draw) {
	var ctx = this.context;

	// Don't use `this` as it could be empty - select the instances directly
	if (ctx.length) {
		var inst = Buttons.instanceSelector(
			this._groupSelector,
			ctx[0]._buttons
		);

		if (inst.length) {
			inst[0].add(conf, idx, draw);
		}
	}

	return this.button(this._groupSelector, idx);
});

// Destroy the button sets selected
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.register('buttons().destroy()', function () {
	this.pluck('inst')
		.unique()
		.each(function (inst) {
			inst.destroy();
		});

	return this;
});

// Remove a button
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.registerPlural(
	'buttons().remove()',
	'buttons().remove()',
	function () {
		this.each(function (set) {
			set.inst.remove(set.node);
		});

		return this;
	}
);

// Information box that can be used by buttons
var _infoTimer;
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.register('buttons.info()', function (title, message, time) {
	var that = this;

	if (title === false) {
		this.off('destroy.btn-info');
		_fadeOut($('#datatables_buttons_info'), 400, function () {
			$(this).remove();
		});
		clearTimeout(_infoTimer);
		_infoTimer = null;

		return this;
	}

	if (_infoTimer) {
		clearTimeout(_infoTimer);
	}

	if ($('#datatables_buttons_info').length) {
		$('#datatables_buttons_info').remove();
	}

	title = title ? '<h2>' + title + '</h2>' : '';

	_fadeIn(
		$('<div id="datatables_buttons_info" class="dt-button-info"/>')
			.html(title)
			.append(
				$('<div/>')[typeof message === 'string' ? 'html' : 'append'](
					message
				)
			)
			.css('display', 'none')
			.appendTo('body')
	);

	if (time !== undefined && time !== 0) {
		_infoTimer = setTimeout(function () {
			that.buttons.info(false);
		}, time);
	}

	this.on('destroy.btn-info', function () {
		that.buttons.info(false);
	});

	return this;
});

// Get data from the table for export - this is common to a number of plug-in
// buttons so it is included in the Buttons core library
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.register('buttons.exportData()', function (options) {
	if (this.context.length) {
		return _exportData(new datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api(this.context[0]), options);
	}
});

// Get information about the export that is common to many of the export data
// types (DRY)
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.register('buttons.exportInfo()', function (conf) {
	if (!conf) {
		conf = {};
	}

	return {
		filename: _filename(conf, this),
		title: _title(conf, this),
		messageTop: _message(this, conf, conf.message || conf.messageTop, 'top'),
		messageBottom: _message(this, conf, conf.messageBottom, 'bottom')
	};
});

/**
 * Get the file name for an exported file.
 *
 * @param {object} config Button configuration
 * @param {object} dt DataTable instance
 */
var _filename = function (config, dt) {
	// Backwards compatibility
	var filename =
		config.filename === '*' &&
		config.title !== '*' &&
		config.title !== undefined &&
		config.title !== null &&
		config.title !== ''
			? config.title
			: config.filename;

	if (typeof filename === 'function') {
		filename = filename(config, dt);
	}

	if (filename === undefined || filename === null) {
		return null;
	}

	if (filename.indexOf('*') !== -1) {
		filename = filename.replace(/\*/g, $('head > title').text()).trim();
	}

	// Strip characters which the OS will object to
	filename = filename.replace(/[^a-zA-Z0-9_\u00A1-\uFFFF\.,\-_ !\(\)]/g, '');

	var extension = _stringOrFunction(config.extension, config, dt);
	if (!extension) {
		extension = '';
	}

	return filename + extension;
};

/**
 * Simply utility method to allow parameters to be given as a function
 *
 * @param {undefined|string|function} option Option
 * @return {null|string} Resolved value
 */
var _stringOrFunction = function (option, config, dt) {
	if (option === null || option === undefined) {
		return null;
	}
	else if (typeof option === 'function') {
		return option(config, dt);
	}
	return option;
};

/**
 * Get the title for an exported file.
 *
 * @param {object} config	Button configuration
 */
var _title = function (config, dt) {
	var title = _stringOrFunction(config.title, config, dt);

	return title === null
		? null
		: title.indexOf('*') !== -1
		? title.replace(/\*/g, $('head > title').text() || 'Exported data')
		: title;
};

var _message = function (dt, config, option, position) {
	var message = _stringOrFunction(option, config, dt);
	if (message === null) {
		return null;
	}

	var caption = $('caption', dt.table().container()).eq(0);
	if (message === '*') {
		var side = caption.css('caption-side');
		if (side !== position) {
			return null;
		}

		return caption.length ? caption.text() : '';
	}

	return message;
};

var _exportTextarea = $('<textarea/>')[0];
var _exportData = function (dt, inOpts) {
	var config = $.extend(
		true,
		{},
		{
			rows: null,
			columns: '',
			modifier: {
				search: 'applied',
				order: 'applied'
			},
			orthogonal: 'display',
			stripHtml: true,
			stripNewlines: true,
			decodeEntities: true,
			trim: true,
			format: {
				header: function (d) {
					return Buttons.stripData(d, config);
				},
				footer: function (d) {
					return Buttons.stripData(d, config);
				},
				body: function (d) {
					return Buttons.stripData(d, config);
				}
			},
			customizeData: null,
			customizeZip: null
		},
		inOpts
	);

	var header = dt
		.columns(config.columns)
		.indexes()
		.map(function (idx) {
			var col = dt.column(idx);
			return config.format.header(col.title(), idx, col.header());
		})
		.toArray();

	var footer = dt.table().footer()
		? dt
				.columns(config.columns)
				.indexes()
				.map(function (idx) {
					var el = dt.column(idx).footer();
					var val = '';

					if (el) {
						var inner = $('.dt-column-title', el);

						val = inner.length
							? inner.html()
							: $(el).html();
					}

					return config.format.footer(val, idx, el);
				})
				.toArray()
		: null;

	// If Select is available on this table, and any rows are selected, limit the export
	// to the selected rows. If no rows are selected, all rows will be exported. Specify
	// a `selected` modifier to control directly.
	var modifier = $.extend({}, config.modifier);
	if (
		dt.select &&
		typeof dt.select.info === 'function' &&
		modifier.selected === undefined
	) {
		if (
			dt.rows(config.rows, $.extend({ selected: true }, modifier)).any()
		) {
			$.extend(modifier, { selected: true });
		}
	}

	var rowIndexes = dt.rows(config.rows, modifier).indexes().toArray();
	var selectedCells = dt.cells(rowIndexes, config.columns, {
		order: modifier.order
	});
	var cells = selectedCells.render(config.orthogonal).toArray();
	var cellNodes = selectedCells.nodes().toArray();
	var cellIndexes = selectedCells.indexes().toArray();

	var columns = dt.columns(config.columns).count();
	var rows = columns > 0 ? cells.length / columns : 0;
	var body = [];
	var cellCounter = 0;

	for (var i = 0, ien = rows; i < ien; i++) {
		var row = [columns];

		for (var j = 0; j < columns; j++) {
			row[j] = config.format.body(
				cells[cellCounter],
				cellIndexes[cellCounter].row,
				cellIndexes[cellCounter].column,
				cellNodes[cellCounter]
			);
			cellCounter++;
		}

		body[i] = row;
	}

	var data = {
		header: header,
		headerStructure: _headerFormatter(
			config.format.header,
			dt.table().header.structure(config.columns)
		),
		footer: footer,
		footerStructure: _headerFormatter(
			config.format.footer,
			dt.table().footer.structure(config.columns)
		),
		body: body
	};

	if (config.customizeData) {
		config.customizeData(data);
	}

	return data;
};

function _headerFormatter(formatter, struct) {
	for (var i=0 ; i<struct.length ; i++) {
		for (var j=0 ; j<struct[i].length ; j++) {
			var item = struct[i][j];

			if (item) {
				item.title = formatter(
					item.title,
					j,
					item.cell
				);
			}
		}
	}

	return struct;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * DataTables interface
 */

// Attach to DataTables objects for global access
$.fn.dataTable.Buttons = Buttons;
$.fn.DataTable.Buttons = Buttons;

// DataTables creation - check if the buttons have been defined for this table,
// they will have been if the `B` option was used in `dom`, otherwise we should
// create the buttons instance here so they can be inserted into the document
// using the API. Listen for `init` for compatibility with pre 1.10.10, but to
// be removed in future.
$(document).on('init.dt plugin-init.dt', function (e, settings) {
	if (e.namespace !== 'dt') {
		return;
	}

	var opts = settings.oInit.buttons || datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].defaults.buttons;

	if (opts && !settings._buttons) {
		new Buttons(settings, opts).container();
	}
});

function _init(settings, options) {
	var api = new datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api(settings);
	var opts = options
		? options
		: api.init().buttons || datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].defaults.buttons;

	return new Buttons(api, opts).container();
}

// DataTables 1 `dom` feature option
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].ext.feature.push({
	fnInit: _init,
	cFeature: 'B'
});

// DataTables 2 layout feature
if (datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].feature) {
	datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].feature.register('buttons', _init);
}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/datatables.net-dt/js/dataTables.dataTables.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/datatables.net-dt/js/dataTables.dataTables.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var datatables_net__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! datatables.net */ "./node_modules/datatables.net/js/dataTables.mjs");
/*! DataTables styling integration
 * © SpryMedia Ltd - datatables.net/license
 */




// Allow reassignment of the $ variable
let $ = jquery__WEBPACK_IMPORTED_MODULE_0__;




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/datatables.net-responsive-dt/js/responsive.dataTables.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/datatables.net-responsive-dt/js/responsive.dataTables.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var datatables_net_dt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! datatables.net-dt */ "./node_modules/datatables.net-dt/js/dataTables.dataTables.mjs");
/* harmony import */ var datatables_net_responsive__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! datatables.net-responsive */ "./node_modules/datatables.net-responsive/js/dataTables.responsive.mjs");
/*! DataTables styling wrapper for Responsive
 * © SpryMedia Ltd - datatables.net/license
 */





// Allow reassignment of the $ variable
let $ = jquery__WEBPACK_IMPORTED_MODULE_0__;



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (datatables_net_dt__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/datatables.net-responsive/js/dataTables.responsive.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/datatables.net-responsive/js/dataTables.responsive.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var datatables_net__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! datatables.net */ "./node_modules/datatables.net/js/dataTables.mjs");
/*! Responsive 3.0.2
 * © SpryMedia Ltd - datatables.net/license
 */




// Allow reassignment of the $ variable
let $ = jquery__WEBPACK_IMPORTED_MODULE_0__;


/**
 * @summary     Responsive
 * @description Responsive tables plug-in for DataTables
 * @version     3.0.2
 * @author      SpryMedia Ltd
 * @copyright   SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license/mit
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

/**
 * Responsive is a plug-in for the DataTables library that makes use of
 * DataTables' ability to change the visibility of columns, changing the
 * visibility of columns so the displayed columns fit into the table container.
 * The end result is that complex tables will be dynamically adjusted to fit
 * into the viewport, be it on a desktop, tablet or mobile browser.
 *
 * Responsive for DataTables has two modes of operation, which can used
 * individually or combined:
 *
 * * Class name based control - columns assigned class names that match the
 *   breakpoint logic can be shown / hidden as required for each breakpoint.
 * * Automatic control - columns are automatically hidden when there is no
 *   room left to display them. Columns removed from the right.
 *
 * In additional to column visibility control, Responsive also has built into
 * options to use DataTables' child row display to show / hide the information
 * from the table that has been hidden. There are also two modes of operation
 * for this child row display:
 *
 * * Inline - when the control element that the user can use to show / hide
 *   child rows is displayed inside the first column of the table.
 * * Column - where a whole column is dedicated to be the show / hide control.
 *
 * Initialisation of Responsive is performed by:
 *
 * * Adding the class `responsive` or `dt-responsive` to the table. In this case
 *   Responsive will automatically be initialised with the default configuration
 *   options when the DataTable is created.
 * * Using the `responsive` option in the DataTables configuration options. This
 *   can also be used to specify the configuration options, or simply set to
 *   `true` to use the defaults.
 *
 *  @class
 *  @param {object} settings DataTables settings object for the host table
 *  @param {object} [opts] Configuration options
 *  @requires jQuery 1.7+
 *  @requires DataTables 1.10.3+
 *
 *  @example
 *      $('#example').DataTable( {
 *        responsive: true
 *      } );
 *    } );
 */
var Responsive = function (settings, opts) {
	// Sanity check that we are using DataTables 1.10 or newer
	if (!datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].versionCheck || !datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].versionCheck('2')) {
		throw 'DataTables Responsive requires DataTables 2 or newer';
	}

	this.s = {
		childNodeStore: {},
		columns: [],
		current: [],
		dt: new datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api(settings)
	};

	// Check if responsive has already been initialised on this table
	if (this.s.dt.settings()[0].responsive) {
		return;
	}

	// details is an object, but for simplicity the user can give it as a string
	// or a boolean
	if (opts && typeof opts.details === 'string') {
		opts.details = { type: opts.details };
	}
	else if (opts && opts.details === false) {
		opts.details = { type: false };
	}
	else if (opts && opts.details === true) {
		opts.details = { type: 'inline' };
	}

	this.c = $.extend(
		true,
		{},
		Responsive.defaults,
		datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].defaults.responsive,
		opts
	);
	settings.responsive = this;
	this._constructor();
};

$.extend(Responsive.prototype, {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Constructor
	 */

	/**
	 * Initialise the Responsive instance
	 *
	 * @private
	 */
	_constructor: function () {
		var that = this;
		var dt = this.s.dt;
		var oldWindowWidth = $(window).innerWidth();

		dt.settings()[0]._responsive = this;

		// Use DataTables' throttle function to avoid processor thrashing
		$(window).on(
			'orientationchange.dtr',
			datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].util.throttle(function () {
				// iOS has a bug whereby resize can fire when only scrolling
				// See: http://stackoverflow.com/questions/8898412
				var width = $(window).innerWidth();

				if (width !== oldWindowWidth) {
					that._resize();
					oldWindowWidth = width;
				}
			})
		);

		// Handle new rows being dynamically added - needed as responsive
		// updates all rows (shown or not) a responsive change, rather than
		// per draw.
		dt.on('row-created.dtr', function (e, tr, data, idx) {
			if ($.inArray(false, that.s.current) !== -1) {
				$('>td, >th', tr).each(function (i) {
					var idx = dt.column.index('toData', i);

					if (that.s.current[idx] === false) {
						$(this)
							.css('display', 'none')
							.addClass('dtr-hidden');
					}
				});
			}
		});

		// Destroy event handler
		dt.on('destroy.dtr', function () {
			dt.off('.dtr');
			$(dt.table().body()).off('.dtr');
			$(window).off('resize.dtr orientationchange.dtr');
			dt.cells('.dtr-control').nodes().to$().removeClass('dtr-control');
			$(dt.table().node()).removeClass('dtr-inline collapsed');

			// Restore the columns that we've hidden
			$.each(that.s.current, function (i, val) {
				if (val === false) {
					that._setColumnVis(i, true);
				}
			});
		});

		// Reorder the breakpoints array here in case they have been added out
		// of order
		this.c.breakpoints.sort(function (a, b) {
			return a.width < b.width ? 1 : a.width > b.width ? -1 : 0;
		});

		this._classLogic();
		this._resizeAuto();

		// Details handler
		var details = this.c.details;

		if (details.type !== false) {
			that._detailsInit();

			// DataTables will trigger this event on every column it shows and
			// hides individually
			dt.on('column-visibility.dtr', function () {
				// Use a small debounce to allow multiple columns to be set together
				if (that._timer) {
					clearTimeout(that._timer);
				}

				that._timer = setTimeout(function () {
					that._timer = null;

					that._classLogic();
					that._resizeAuto();
					that._resize(true);

					that._redrawChildren();
				}, 100);
			});

			// Redraw the details box on each draw which will happen if the data
			// has changed. This is used until DataTables implements a native
			// `updated` event for rows
			dt.on('draw.dtr', function () {
				that._redrawChildren();
			});

			$(dt.table().node()).addClass('dtr-' + details.type);
		}

		dt.on('column-reorder.dtr', function (e, settings, details) {
			that._classLogic();
			that._resizeAuto();
			that._resize(true);
		});

		// Change in column sizes means we need to calc
		dt.on('column-sizing.dtr', function () {
			that._resizeAuto();
			that._resize();
		});

		// DT2 let's us tell it if we are hiding columns
		dt.on('column-calc.dt', function (e, d) {
			var curr = that.s.current;

			for (var i = 0; i < curr.length; i++) {
				var idx = d.visible.indexOf(i);

				if (curr[i] === false && idx >= 0) {
					d.visible.splice(idx, 1);
				}
			}
		});

		// On Ajax reload we want to reopen any child rows which are displayed
		// by responsive
		dt.on('preXhr.dtr', function () {
			var rowIds = [];
			dt.rows().every(function () {
				if (this.child.isShown()) {
					rowIds.push(this.id(true));
				}
			});

			dt.one('draw.dtr', function () {
				that._resizeAuto();
				that._resize();

				dt.rows(rowIds).every(function () {
					that._detailsDisplay(this, false);
				});
			});
		});

		dt.on('draw.dtr', function () {
			that._controlClass();
		}).on('init.dtr', function (e, settings, details) {
			if (e.namespace !== 'dt') {
				return;
			}

			that._resizeAuto();
			that._resize();
		});

		// First pass - draw the table for the current viewport size
		this._resize();
	},

	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private methods
	 */

	/**
	 * Insert a `col` tag into the correct location in a `colgroup`.
	 *
	 * @param {jQuery} colGroup The `colgroup` tag
	 * @param {jQuery} colEl The `col` tag
	 */
	_colGroupAttach: function (colGroup, colEls, idx) {
		var found = null;

		// No need to do anything if already attached
		if (colEls[idx].get(0).parentNode === colGroup[0]) {
			return;
		}

		// Find the first `col` after our own which is already attached
		for (var i = idx+1; i < colEls.length; i++) {
			if (colGroup[0] === colEls[i].get(0).parentNode) {
				found = i;
				break;
			}
		}

		if (found !== null) {
			// Insert before
			colEls[idx].insertBefore(colEls[found][0]);
		}
		else {
			// If wasn't found, insert at the end
			colGroup.append(colEls[idx]);
		}
	},

	/**
	 * Get and store nodes from a cell - use for node moving renderers
	 *
	 * @param {*} dt DT instance
	 * @param {*} row Row index
	 * @param {*} col Column index
	 */
	_childNodes: function (dt, row, col) {
		var name = row + '-' + col;

		if (this.s.childNodeStore[name]) {
			return this.s.childNodeStore[name];
		}

		// https://jsperf.com/childnodes-array-slice-vs-loop
		var nodes = [];
		var children = dt.cell(row, col).node().childNodes;
		for (var i = 0, ien = children.length; i < ien; i++) {
			nodes.push(children[i]);
		}

		this.s.childNodeStore[name] = nodes;

		return nodes;
	},

	/**
	 * Restore nodes from the cache to a table cell
	 *
	 * @param {*} dt DT instance
	 * @param {*} row Row index
	 * @param {*} col Column index
	 */
	_childNodesRestore: function (dt, row, col) {
		var name = row + '-' + col;

		if (!this.s.childNodeStore[name]) {
			return;
		}

		var node = dt.cell(row, col).node();
		var store = this.s.childNodeStore[name];
		if (store.length > 0) {
			var parent = store[0].parentNode;
			var parentChildren = parent.childNodes;
			var a = [];

			for (var i = 0, ien = parentChildren.length; i < ien; i++) {
				a.push(parentChildren[i]);
			}

			for (var j = 0, jen = a.length; j < jen; j++) {
				node.appendChild(a[j]);
			}
		}

		this.s.childNodeStore[name] = undefined;
	},

	/**
	 * Calculate the visibility for the columns in a table for a given
	 * breakpoint. The result is pre-determined based on the class logic if
	 * class names are used to control all columns, but the width of the table
	 * is also used if there are columns which are to be automatically shown
	 * and hidden.
	 *
	 * @param  {string} breakpoint Breakpoint name to use for the calculation
	 * @return {array} Array of boolean values initiating the visibility of each
	 *   column.
	 *  @private
	 */
	_columnsVisiblity: function (breakpoint) {
		var dt = this.s.dt;
		var columns = this.s.columns;
		var i, ien;

		// Create an array that defines the column ordering based first on the
		// column's priority, and secondly the column index. This allows the
		// columns to be removed from the right if the priority matches
		var order = columns
			.map(function (col, idx) {
				return {
					columnIdx: idx,
					priority: col.priority
				};
			})
			.sort(function (a, b) {
				if (a.priority !== b.priority) {
					return a.priority - b.priority;
				}
				return a.columnIdx - b.columnIdx;
			});

		// Class logic - determine which columns are in this breakpoint based
		// on the classes. If no class control (i.e. `auto`) then `-` is used
		// to indicate this to the rest of the function
		var display = $.map(columns, function (col, i) {
			if (dt.column(i).visible() === false) {
				return 'not-visible';
			}
			return col.auto && col.minWidth === null
				? false
				: col.auto === true
				? '-'
				: $.inArray(breakpoint, col.includeIn) !== -1;
		});

		// Auto column control - first pass: how much width is taken by the
		// ones that must be included from the non-auto columns
		var requiredWidth = 0;
		for (i = 0, ien = display.length; i < ien; i++) {
			if (display[i] === true) {
				requiredWidth += columns[i].minWidth;
			}
		}

		// Second pass, use up any remaining width for other columns. For
		// scrolling tables we need to subtract the width of the scrollbar. It
		// may not be requires which makes this sub-optimal, but it would
		// require another full redraw to make complete use of those extra few
		// pixels
		var scrolling = dt.settings()[0].oScroll;
		var bar = scrolling.sY || scrolling.sX ? scrolling.iBarWidth : 0;
		var widthAvailable = dt.table().container().offsetWidth - bar;
		var usedWidth = widthAvailable - requiredWidth;

		// Control column needs to always be included. This makes it sub-
		// optimal in terms of using the available with, but to stop layout
		// thrashing or overflow. Also we need to account for the control column
		// width first so we know how much width is available for the other
		// columns, since the control column might not be the first one shown
		for (i = 0, ien = display.length; i < ien; i++) {
			if (columns[i].control) {
				usedWidth -= columns[i].minWidth;
			}
		}

		// Allow columns to be shown (counting by priority and then right to
		// left) until we run out of room
		var empty = false;
		for (i = 0, ien = order.length; i < ien; i++) {
			var colIdx = order[i].columnIdx;

			if (
				display[colIdx] === '-' &&
				!columns[colIdx].control &&
				columns[colIdx].minWidth
			) {
				// Once we've found a column that won't fit we don't let any
				// others display either, or columns might disappear in the
				// middle of the table
				if (empty || usedWidth - columns[colIdx].minWidth < 0) {
					empty = true;
					display[colIdx] = false;
				}
				else {
					display[colIdx] = true;
				}

				usedWidth -= columns[colIdx].minWidth;
			}
		}

		// Determine if the 'control' column should be shown (if there is one).
		// This is the case when there is a hidden column (that is not the
		// control column). The two loops look inefficient here, but they are
		// trivial and will fly through. We need to know the outcome from the
		// first , before the action in the second can be taken
		var showControl = false;

		for (i = 0, ien = columns.length; i < ien; i++) {
			if (
				!columns[i].control &&
				!columns[i].never &&
				display[i] === false
			) {
				showControl = true;
				break;
			}
		}

		for (i = 0, ien = columns.length; i < ien; i++) {
			if (columns[i].control) {
				display[i] = showControl;
			}

			// Replace not visible string with false from the control column detection above
			if (display[i] === 'not-visible') {
				display[i] = false;
			}
		}

		// Finally we need to make sure that there is at least one column that
		// is visible
		if ($.inArray(true, display) === -1) {
			display[0] = true;
		}

		return display;
	},

	/**
	 * Create the internal `columns` array with information about the columns
	 * for the table. This includes determining which breakpoints the column
	 * will appear in, based upon class names in the column, which makes up the
	 * vast majority of this method.
	 *
	 * @private
	 */
	_classLogic: function () {
		var that = this;
		var breakpoints = this.c.breakpoints;
		var dt = this.s.dt;
		var columns = dt
			.columns()
			.eq(0)
			.map(function (i) {
				var column = this.column(i);
				var className = column.header().className;
				var priority = column.init().responsivePriority;
				var dataPriority = column
					.header()
					.getAttribute('data-priority');

				if (priority === undefined) {
					priority =
						dataPriority === undefined || dataPriority === null
							? 10000
							: dataPriority * 1;
				}

				return {
					className: className,
					includeIn: [],
					auto: false,
					control: false,
					never: className.match(/\b(dtr\-)?never\b/) ? true : false,
					priority: priority
				};
			});

		// Simply add a breakpoint to `includeIn` array, ensuring that there are
		// no duplicates
		var add = function (colIdx, name) {
			var includeIn = columns[colIdx].includeIn;

			if ($.inArray(name, includeIn) === -1) {
				includeIn.push(name);
			}
		};

		var column = function (colIdx, name, operator, matched) {
			var size, i, ien;

			if (!operator) {
				columns[colIdx].includeIn.push(name);
			}
			else if (operator === 'max-') {
				// Add this breakpoint and all smaller
				size = that._find(name).width;

				for (i = 0, ien = breakpoints.length; i < ien; i++) {
					if (breakpoints[i].width <= size) {
						add(colIdx, breakpoints[i].name);
					}
				}
			}
			else if (operator === 'min-') {
				// Add this breakpoint and all larger
				size = that._find(name).width;

				for (i = 0, ien = breakpoints.length; i < ien; i++) {
					if (breakpoints[i].width >= size) {
						add(colIdx, breakpoints[i].name);
					}
				}
			}
			else if (operator === 'not-') {
				// Add all but this breakpoint
				for (i = 0, ien = breakpoints.length; i < ien; i++) {
					if (breakpoints[i].name.indexOf(matched) === -1) {
						add(colIdx, breakpoints[i].name);
					}
				}
			}
		};

		// Loop over each column and determine if it has a responsive control
		// class
		columns.each(function (col, i) {
			var classNames = col.className.split(' ');
			var hasClass = false;

			// Split the class name up so multiple rules can be applied if needed
			for (var k = 0, ken = classNames.length; k < ken; k++) {
				var className = classNames[k].trim();

				if (className === 'all' || className === 'dtr-all') {
					// Include in all
					hasClass = true;
					col.includeIn = $.map(breakpoints, function (a) {
						return a.name;
					});
					return;
				}
				else if (
					className === 'none' ||
					className === 'dtr-none' ||
					col.never
				) {
					// Include in none (default) and no auto
					hasClass = true;
					return;
				}
				else if (
					className === 'control' ||
					className === 'dtr-control'
				) {
					// Special column that is only visible, when one of the other
					// columns is hidden. This is used for the details control
					hasClass = true;
					col.control = true;
					return;
				}

				$.each(breakpoints, function (j, breakpoint) {
					// Does this column have a class that matches this breakpoint?
					var brokenPoint = breakpoint.name.split('-');
					var re = new RegExp(
						'(min\\-|max\\-|not\\-)?(' +
							brokenPoint[0] +
							')(\\-[_a-zA-Z0-9])?'
					);
					var match = className.match(re);

					if (match) {
						hasClass = true;

						if (
							match[2] === brokenPoint[0] &&
							match[3] === '-' + brokenPoint[1]
						) {
							// Class name matches breakpoint name fully
							column(
								i,
								breakpoint.name,
								match[1],
								match[2] + match[3]
							);
						}
						else if (match[2] === brokenPoint[0] && !match[3]) {
							// Class name matched primary breakpoint name with no qualifier
							column(i, breakpoint.name, match[1], match[2]);
						}
					}
				});
			}

			// If there was no control class, then automatic sizing is used
			if (!hasClass) {
				col.auto = true;
			}
		});

		this.s.columns = columns;
	},

	/**
	 * Update the cells to show the correct control class / button
	 * @private
	 */
	_controlClass: function () {
		if (this.c.details.type === 'inline') {
			var dt = this.s.dt;
			var columnsVis = this.s.current;
			var firstVisible = $.inArray(true, columnsVis);

			// Remove from any cells which shouldn't have it
			dt.cells(
				null,
				function (idx) {
					return idx !== firstVisible;
				},
				{ page: 'current' }
			)
				.nodes()
				.to$()
				.filter('.dtr-control')
				.removeClass('dtr-control');

			dt.cells(null, firstVisible, { page: 'current' })
				.nodes()
				.to$()
				.addClass('dtr-control');
		}
	},

	/**
	 * Show the details for the child row
	 *
	 * @param  {DataTables.Api} row    API instance for the row
	 * @param  {boolean}        update Update flag
	 * @private
	 */
	_detailsDisplay: function (row, update) {
		var that = this;
		var dt = this.s.dt;
		var details = this.c.details;
		var event = function (res) {
			$(row.node()).toggleClass('dtr-expanded', res !== false);
			$(dt.table().node()).triggerHandler('responsive-display.dt', [
				dt,
				row,
				res,
				update
			]);
		};

		if (details && details.type !== false) {
			var renderer =
				typeof details.renderer === 'string'
					? Responsive.renderer[details.renderer]()
					: details.renderer;

			var res = details.display(
				row,
				update,
				function () {
					return renderer.call(
						that,
						dt,
						row[0][0],
						that._detailsObj(row[0])
					);
				},
				function () {
					event(false);
				}
			);

			if (typeof res === 'boolean') {
				event(res);
			}
		}
	},

	/**
	 * Initialisation for the details handler
	 *
	 * @private
	 */
	_detailsInit: function () {
		var that = this;
		var dt = this.s.dt;
		var details = this.c.details;

		// The inline type always uses the first child as the target
		if (details.type === 'inline') {
			details.target = 'td.dtr-control, th.dtr-control';
		}

		// Keyboard accessibility
		dt.on('draw.dtr', function () {
			that._tabIndexes();
		});
		that._tabIndexes(); // Initial draw has already happened

		$(dt.table().body()).on('keyup.dtr', 'td, th', function (e) {
			if (e.keyCode === 13 && $(this).data('dtr-keyboard')) {
				$(this).click();
			}
		});

		// type.target can be a string jQuery selector or a column index
		var target = details.target;
		var selector = typeof target === 'string' ? target : 'td, th';

		if (target !== undefined || target !== null) {
			// Click handler to show / hide the details rows when they are available
			$(dt.table().body()).on(
				'click.dtr mousedown.dtr mouseup.dtr',
				selector,
				function (e) {
					// If the table is not collapsed (i.e. there is no hidden columns)
					// then take no action
					if (!$(dt.table().node()).hasClass('collapsed')) {
						return;
					}

					// Check that the row is actually a DataTable's controlled node
					if (
						$.inArray(
							$(this).closest('tr').get(0),
							dt.rows().nodes().toArray()
						) === -1
					) {
						return;
					}

					// For column index, we determine if we should act or not in the
					// handler - otherwise it is already okay
					if (typeof target === 'number') {
						var targetIdx =
							target < 0
								? dt.columns().eq(0).length + target
								: target;

						if (dt.cell(this).index().column !== targetIdx) {
							return;
						}
					}

					// $().closest() includes itself in its check
					var row = dt.row($(this).closest('tr'));

					// Check event type to do an action
					if (e.type === 'click') {
						// The renderer is given as a function so the caller can execute it
						// only when they need (i.e. if hiding there is no point is running
						// the renderer)
						that._detailsDisplay(row, false);
					}
					else if (e.type === 'mousedown') {
						// For mouse users, prevent the focus ring from showing
						$(this).css('outline', 'none');
					}
					else if (e.type === 'mouseup') {
						// And then re-allow at the end of the click
						$(this).trigger('blur').css('outline', '');
					}
				}
			);
		}
	},

	/**
	 * Get the details to pass to a renderer for a row
	 * @param  {int} rowIdx Row index
	 * @private
	 */
	_detailsObj: function (rowIdx) {
		var that = this;
		var dt = this.s.dt;

		return $.map(this.s.columns, function (col, i) {
			// Never and control columns should not be passed to the renderer
			if (col.never || col.control) {
				return;
			}

			var dtCol = dt.settings()[0].aoColumns[i];

			return {
				className: dtCol.sClass,
				columnIndex: i,
				data: dt.cell(rowIdx, i).render(that.c.orthogonal),
				hidden: dt.column(i).visible() && !that.s.current[i],
				rowIndex: rowIdx,
				title: dt.column(i).title()
			};
		});
	},

	/**
	 * Find a breakpoint object from a name
	 *
	 * @param  {string} name Breakpoint name to find
	 * @return {object}      Breakpoint description object
	 * @private
	 */
	_find: function (name) {
		var breakpoints = this.c.breakpoints;

		for (var i = 0, ien = breakpoints.length; i < ien; i++) {
			if (breakpoints[i].name === name) {
				return breakpoints[i];
			}
		}
	},

	/**
	 * Re-create the contents of the child rows as the display has changed in
	 * some way.
	 *
	 * @private
	 */
	_redrawChildren: function () {
		var that = this;
		var dt = this.s.dt;

		dt.rows({ page: 'current' }).iterator('row', function (settings, idx) {
			that._detailsDisplay(dt.row(idx), true);
		});
	},

	/**
	 * Alter the table display for a resized viewport. This involves first
	 * determining what breakpoint the window currently is in, getting the
	 * column visibilities to apply and then setting them.
	 *
	 * @param  {boolean} forceRedraw Force a redraw
	 * @private
	 */
	_resize: function (forceRedraw) {
		var that = this;
		var dt = this.s.dt;
		var width = $(window).innerWidth();
		var breakpoints = this.c.breakpoints;
		var breakpoint = breakpoints[0].name;
		var columns = this.s.columns;
		var i, ien;
		var oldVis = this.s.current.slice();

		// Determine what breakpoint we are currently at
		for (i = breakpoints.length - 1; i >= 0; i--) {
			if (width <= breakpoints[i].width) {
				breakpoint = breakpoints[i].name;
				break;
			}
		}

		// Show the columns for that break point
		var columnsVis = this._columnsVisiblity(breakpoint);
		this.s.current = columnsVis;

		// Set the class before the column visibility is changed so event
		// listeners know what the state is. Need to determine if there are
		// any columns that are not visible but can be shown
		var collapsedClass = false;

		for (i = 0, ien = columns.length; i < ien; i++) {
			if (
				columnsVis[i] === false &&
				!columns[i].never &&
				!columns[i].control &&
				!dt.column(i).visible() === false
			) {
				collapsedClass = true;
				break;
			}
		}

		$(dt.table().node()).toggleClass('collapsed', collapsedClass);

		var changed = false;
		var visible = 0;
		var dtSettings = dt.settings()[0];
		var colGroup = $(dt.table().node()).children('colgroup');
		var colEls = dtSettings.aoColumns.map(function (col) {
			return col.colEl;
		});

		dt.columns()
			.eq(0)
			.each(function (colIdx, i) {
				//console.log(colIdx, i);
				// Do nothing on DataTables' hidden column - DT removes it from the table
				// so we need to slide back
				if (! dt.column(colIdx).visible()) {
					return;
				}

				if (columnsVis[i] === true) {
					visible++;
				}

				if (forceRedraw || columnsVis[i] !== oldVis[i]) {
					changed = true;
					that._setColumnVis(colIdx, columnsVis[i]);
				}

				// DataTables 2 uses `col` to define the width for a column
				// and this needs to run each time, as DataTables will change
				// the column width. We may need to reattach if we've removed
				// an element previously.
				if (! columnsVis[i]) {
					colEls[i].detach();
				}
				else {
					that._colGroupAttach(colGroup, colEls, i);
				}
			});

		if (changed) {
			dt.columns.adjust();

			this._redrawChildren();

			// Inform listeners of the change
			$(dt.table().node()).trigger('responsive-resize.dt', [
				dt,
				this._responsiveOnlyHidden()
			]);

			// If no records, update the "No records" display element
			if (dt.page.info().recordsDisplay === 0) {
				$('td', dt.table().body()).eq(0).attr('colspan', visible);
			}
		}

		that._controlClass();
	},

	/**
	 * Determine the width of each column in the table so the auto column hiding
	 * has that information to work with. This method is never going to be 100%
	 * perfect since column widths can change slightly per page, but without
	 * seriously compromising performance this is quite effective.
	 *
	 * @private
	 */
	_resizeAuto: function () {
		var dt = this.s.dt;
		var columns = this.s.columns;
		var that = this;
		var visibleColumns = dt
			.columns()
			.indexes()
			.filter(function (idx) {
				return dt.column(idx).visible();
			});

		// Are we allowed to do auto sizing?
		if (!this.c.auto) {
			return;
		}

		// Are there any columns that actually need auto-sizing, or do they all
		// have classes defined
		if (
			$.inArray(
				true,
				$.map(columns, function (c) {
					return c.auto;
				})
			) === -1
		) {
			return;
		}

		// Clone the table with the current data in it
		var clonedTable = dt.table().node().cloneNode(false);
		var clonedHeader = $(dt.table().header().cloneNode(false)).appendTo(
			clonedTable
		);
		var clonedFooter = $(dt.table().footer().cloneNode(false)).appendTo(
			clonedTable
		);
		var clonedBody = $(dt.table().body())
			.clone(false, false)
			.empty()
			.appendTo(clonedTable); // use jQuery because of IE8

		clonedTable.style.width = 'auto';

		// Header
		dt.table()
			.header.structure(visibleColumns)
			.forEach((row) => {
				var cells = row
					.filter(function (el) {
						return el ? true : false;
					})
					.map(function (el) {
						return $(el.cell)
							.clone(false)
							.css('display', 'table-cell')
							.css('width', 'auto')
							.css('min-width', 0);
					});

				$('<tr/>').append(cells).appendTo(clonedHeader);
			});

		// Always need an empty row that we can read widths from
		var emptyRow = $('<tr/>').appendTo(clonedBody);

		for (var i = 0; i < visibleColumns.count(); i++) {
			emptyRow.append('<td/>');
		}

		// Body rows
		dt.rows({ page: 'current' }).every(function (rowIdx) {
			var node = this.node();

			if (! node) {
				return;
			}

			// We clone the table's rows and cells to create the sizing table
			var tr = node.cloneNode(false);

			dt.cells(rowIdx, visibleColumns).every(function (rowIdx2, colIdx) {
				// If nodes have been moved out (listHiddenNodes), we need to
				// clone from the store
				var store = that.s.childNodeStore[rowIdx + '-' + colIdx];

				if (store) {
					$(this.node().cloneNode(false))
						.append($(store).clone())
						.appendTo(tr);
				}
				else {
					$(this.node()).clone(false).appendTo(tr);
				}
			});

			clonedBody.append(tr);
		});

		// Any cells which were hidden by Responsive in the host table, need to
		// be visible here for the calculations
		clonedBody.find('th, td').css('display', '');

		// Footer
		dt.table()
			.footer.structure(visibleColumns)
			.forEach((row) => {
				var cells = row
					.filter(function (el) {
						return el ? true : false;
					})
					.map(function (el) {
						return $(el.cell)
							.clone(false)
							.css('display', 'table-cell')
							.css('width', 'auto')
							.css('min-width', 0);
					});

				$('<tr/>').append(cells).appendTo(clonedFooter);
			});

		// In the inline case extra padding is applied to the first column to
		// give space for the show / hide icon. We need to use this in the
		// calculation
		if (this.c.details.type === 'inline') {
			$(clonedTable).addClass('dtr-inline collapsed');
		}

		// It is unsafe to insert elements with the same name into the DOM
		// multiple times. For example, cloning and inserting a checked radio
		// clears the chcecked state of the original radio.
		$(clonedTable).find('[name]').removeAttr('name');

		// A position absolute table would take the table out of the flow of
		// our container element, bypassing the height and width (Scroller)
		$(clonedTable).css('position', 'relative');

		var inserted = $('<div/>')
			.css({
				width: 1,
				height: 1,
				overflow: 'hidden',
				clear: 'both'
			})
			.append(clonedTable);

		inserted.insertBefore(dt.table().node());

		// The cloned table now contains the smallest that each column can be
		emptyRow.children().each(function (i) {
			var idx = dt.column.index('fromVisible', i);
			columns[idx].minWidth = this.offsetWidth || 0;
		});

		inserted.remove();
	},

	/**
	 * Get the state of the current hidden columns - controlled by Responsive only
	 */
	_responsiveOnlyHidden: function () {
		var dt = this.s.dt;

		return $.map(this.s.current, function (v, i) {
			// If the column is hidden by DataTables then it can't be hidden by
			// Responsive!
			if (dt.column(i).visible() === false) {
				return true;
			}
			return v;
		});
	},

	/**
	 * Set a column's visibility.
	 *
	 * We don't use DataTables' column visibility controls in order to ensure
	 * that column visibility can Responsive can no-exist. Since only IE8+ is
	 * supported (and all evergreen browsers of course) the control of the
	 * display attribute works well.
	 *
	 * @param {integer} col      Column index
	 * @param {boolean} showHide Show or hide (true or false)
	 * @private
	 */
	_setColumnVis: function (col, showHide) {
		var that = this;
		var dt = this.s.dt;
		var display = showHide ? '' : 'none'; // empty string will remove the attr

		this._setHeaderVis(col, showHide, dt.table().header.structure());
		this._setHeaderVis(col, showHide, dt.table().footer.structure());

		dt.column(col)
			.nodes()
			.to$()
			.css('display', display)
			.toggleClass('dtr-hidden', !showHide);

		// If the are child nodes stored, we might need to reinsert them
		if (!$.isEmptyObject(this.s.childNodeStore)) {
			dt.cells(null, col)
				.indexes()
				.each(function (idx) {
					that._childNodesRestore(dt, idx.row, idx.column);
				});
		}
	},

	/**
	 * Set the a column's visibility, taking into account multiple rows
	 * in a header / footer and colspan attributes
	 * @param {*} col
	 * @param {*} showHide
	 * @param {*} structure
	 */
	_setHeaderVis: function (col, showHide, structure) {
		var that = this;
		var display = showHide ? '' : 'none';

		structure.forEach(function (row) {
			if (row[col]) {
				$(row[col].cell)
					.css('display', display)
					.toggleClass('dtr-hidden', !showHide);
			}
			else {
				// In a colspan - need to rewind calc the new span since
				// display:none elements do not count as being spanned over
				var search = col;

				while (search >= 0) {
					if (row[search]) {
						row[search].cell.colSpan = that._colspan(row, search);
						break;
					}

					search--;
				}
			}
		});
	},

	/**
	 * How many columns should this cell span
	 *
	 * @param {*} row Header structure row
	 * @param {*} idx The column index of the cell to span
	 */
	_colspan: function (row, idx) {
		var colspan = 1;

		for (var col = idx + 1; col < row.length; col++) {
			if (row[col] === null && this.s.current[col]) {
				// colspan and not hidden by Responsive
				colspan++;
			}
			else if (row[col]) {
				// Got the next cell, jump out
				break;
			}
		}

		return colspan;
	},

	/**
	 * Update the cell tab indexes for keyboard accessibility. This is called on
	 * every table draw - that is potentially inefficient, but also the least
	 * complex option given that column visibility can change on the fly. Its a
	 * shame user-focus was removed from CSS 3 UI, as it would have solved this
	 * issue with a single CSS statement.
	 *
	 * @private
	 */
	_tabIndexes: function () {
		var dt = this.s.dt;
		var cells = dt.cells({ page: 'current' }).nodes().to$();
		var ctx = dt.settings()[0];
		var target = this.c.details.target;

		cells.filter('[data-dtr-keyboard]').removeData('[data-dtr-keyboard]');

		if (typeof target === 'number') {
			dt.cells(null, target, { page: 'current' })
				.nodes()
				.to$()
				.attr('tabIndex', ctx.iTabIndex)
				.data('dtr-keyboard', 1);
		}
		else {
			// This is a bit of a hack - we need to limit the selected nodes to just
			// those of this table
			if (target === 'td:first-child, th:first-child') {
				target = '>td:first-child, >th:first-child';
			}

			$(target, dt.rows({ page: 'current' }).nodes())
				.attr('tabIndex', ctx.iTabIndex)
				.data('dtr-keyboard', 1);
		}
	}
});

/**
 * List of default breakpoints. Each item in the array is an object with two
 * properties:
 *
 * * `name` - the breakpoint name.
 * * `width` - the breakpoint width
 *
 * @name Responsive.breakpoints
 * @static
 */
Responsive.breakpoints = [
	{ name: 'desktop', width: Infinity },
	{ name: 'tablet-l', width: 1024 },
	{ name: 'tablet-p', width: 768 },
	{ name: 'mobile-l', width: 480 },
	{ name: 'mobile-p', width: 320 }
];

/**
 * Display methods - functions which define how the hidden data should be shown
 * in the table.
 *
 * @namespace
 * @name Responsive.defaults
 * @static
 */
Responsive.display = {
	childRow: function (row, update, render) {
		var rowNode = $(row.node());

		if (update) {
			if (rowNode.hasClass('dtr-expanded')) {
				row.child(render(), 'child').show();

				return true;
			}
		}
		else {
			if (!rowNode.hasClass('dtr-expanded')) {
				var rendered = render();

				if (rendered === false) {
					return false;
				}

				row.child(rendered, 'child').show();
				return true;
			}
			else {
				row.child(false);

				return false;
			}
		}
	},

	childRowImmediate: function (row, update, render) {
		var rowNode = $(row.node());

		if (
			(!update && rowNode.hasClass('dtr-expanded')) ||
			!row.responsive.hasHidden()
		) {
			// User interaction and the row is show, or nothing to show
			row.child(false);

			return false;
		}
		else {
			// Display
			var rendered = render();

			if (rendered === false) {
				return false;
			}

			row.child(rendered, 'child').show();

			return true;
		}
	},

	// This is a wrapper so the modal options for Bootstrap and jQuery UI can
	// have options passed into them. This specific one doesn't need to be a
	// function but it is for consistency in the `modal` name
	modal: function (options) {
		return function (row, update, render, closeCallback) {
			var modal;
			var rendered = render();

			if (rendered === false) {
				return false;
			}

			if (!update) {
				// Show a modal
				var close = function () {
					modal.remove(); // will tidy events for us
					$(document).off('keypress.dtr');
					$(row.node()).removeClass('dtr-expanded');

					closeCallback();
				};

				modal = $('<div class="dtr-modal"/>')
					.append(
						$('<div class="dtr-modal-display"/>')
							.append(
								$('<div class="dtr-modal-content"/>')
									.data('dtr-row-idx', row.index())
									.append(rendered)
							)
							.append(
								$(
									'<div class="dtr-modal-close">&times;</div>'
								).click(function () {
									close();
								})
							)
					)
					.append(
						$('<div class="dtr-modal-background"/>').click(
							function () {
								close();
							}
						)
					)
					.appendTo('body');

				$(row.node()).addClass('dtr-expanded');

				$(document).on('keyup.dtr', function (e) {
					if (e.keyCode === 27) {
						e.stopPropagation();

						close();
					}
				});
			}
			else {
				modal = $('div.dtr-modal-content');

				if (modal.length && row.index() === modal.data('dtr-row-idx')) {
					modal.empty().append(rendered);
				}
				else {
					// Modal not shown, nothing to update
					return null;
				}
			}

			if (options && options.header) {
				$('div.dtr-modal-content').prepend(
					'<h2>' + options.header(row) + '</h2>'
				);
			}

			return true;
		};
	}
};

/**
 * Display methods - functions which define how the hidden data should be shown
 * in the table.
 *
 * @namespace
 * @name Responsive.defaults
 * @static
 */
Responsive.renderer = {
	listHiddenNodes: function () {
		return function (api, rowIdx, columns) {
			var that = this;
			var ul = $(
				'<ul data-dtr-index="' + rowIdx + '" class="dtr-details"/>'
			);
			var found = false;

			$.each(columns, function (i, col) {
				if (col.hidden) {
					var klass = col.className
						? 'class="' + col.className + '"'
						: '';

					$(
						'<li ' +
							klass +
							' data-dtr-index="' +
							col.columnIndex +
							'" data-dt-row="' +
							col.rowIndex +
							'" data-dt-column="' +
							col.columnIndex +
							'">' +
							'<span class="dtr-title">' +
							col.title +
							'</span> ' +
							'</li>'
					)
						.append(
							$('<span class="dtr-data"/>').append(
								that._childNodes(
									api,
									col.rowIndex,
									col.columnIndex
								)
							)
						) // api.cell( col.rowIndex, col.columnIndex ).node().childNodes ) )
						.appendTo(ul);

					found = true;
				}
			});

			return found ? ul : false;
		};
	},

	listHidden: function () {
		return function (api, rowIdx, columns) {
			var data = $.map(columns, function (col) {
				var klass = col.className
					? 'class="' + col.className + '"'
					: '';

				return col.hidden
					? '<li ' +
							klass +
							' data-dtr-index="' +
							col.columnIndex +
							'" data-dt-row="' +
							col.rowIndex +
							'" data-dt-column="' +
							col.columnIndex +
							'">' +
							'<span class="dtr-title">' +
							col.title +
							'</span> ' +
							'<span class="dtr-data">' +
							col.data +
							'</span>' +
							'</li>'
					: '';
			}).join('');

			return data
				? $(
						'<ul data-dtr-index="' +
							rowIdx +
							'" class="dtr-details"/>'
				).append(data)
				: false;
		};
	},

	tableAll: function (options) {
		options = $.extend(
			{
				tableClass: ''
			},
			options
		);

		return function (api, rowIdx, columns) {
			var data = $.map(columns, function (col) {
				var klass = col.className
					? 'class="' + col.className + '"'
					: '';

				return (
					'<tr ' +
					klass +
					' data-dt-row="' +
					col.rowIndex +
					'" data-dt-column="' +
					col.columnIndex +
					'">' +
					'<td>' +
					col.title +
					':' +
					'</td> ' +
					'<td>' +
					col.data +
					'</td>' +
					'</tr>'
				);
			}).join('');

			return $(
				'<table class="' +
					options.tableClass +
					' dtr-details" width="100%"/>'
			).append(data);
		};
	}
};

/**
 * Responsive default settings for initialisation
 *
 * @namespace
 * @name Responsive.defaults
 * @static
 */
Responsive.defaults = {
	/**
	 * List of breakpoints for the instance. Note that this means that each
	 * instance can have its own breakpoints. Additionally, the breakpoints
	 * cannot be changed once an instance has been creased.
	 *
	 * @type {Array}
	 * @default Takes the value of `Responsive.breakpoints`
	 */
	breakpoints: Responsive.breakpoints,

	/**
	 * Enable / disable auto hiding calculations. It can help to increase
	 * performance slightly if you disable this option, but all columns would
	 * need to have breakpoint classes assigned to them
	 *
	 * @type {Boolean}
	 * @default  `true`
	 */
	auto: true,

	/**
	 * Details control. If given as a string value, the `type` property of the
	 * default object is set to that value, and the defaults used for the rest
	 * of the object - this is for ease of implementation.
	 *
	 * The object consists of the following properties:
	 *
	 * * `display` - A function that is used to show and hide the hidden details
	 * * `renderer` - function that is called for display of the child row data.
	 *   The default function will show the data from the hidden columns
	 * * `target` - Used as the selector for what objects to attach the child
	 *   open / close to
	 * * `type` - `false` to disable the details display, `inline` or `column`
	 *   for the two control types
	 *
	 * @type {Object|string}
	 */
	details: {
		display: Responsive.display.childRow,

		renderer: Responsive.renderer.listHidden(),

		target: 0,

		type: 'inline'
	},

	/**
	 * Orthogonal data request option. This is used to define the data type
	 * requested when Responsive gets the data to show in the child row.
	 *
	 * @type {String}
	 */
	orthogonal: 'display'
};

/*
 * API
 */
var Api = $.fn.dataTable.Api;

// Doesn't do anything - work around for a bug in DT... Not documented
Api.register('responsive()', function () {
	return this;
});

Api.register('responsive.index()', function (li) {
	li = $(li);

	return {
		column: li.data('dtr-index'),
		row: li.parent().data('dtr-index')
	};
});

Api.register('responsive.rebuild()', function () {
	return this.iterator('table', function (ctx) {
		if (ctx._responsive) {
			ctx._responsive._classLogic();
		}
	});
});

Api.register('responsive.recalc()', function () {
	return this.iterator('table', function (ctx) {
		if (ctx._responsive) {
			ctx._responsive._resizeAuto();
			ctx._responsive._resize();
		}
	});
});

Api.register('responsive.hasHidden()', function () {
	var ctx = this.context[0];

	return ctx._responsive
		? $.inArray(false, ctx._responsive._responsiveOnlyHidden()) !== -1
		: false;
});

Api.registerPlural(
	'columns().responsiveHidden()',
	'column().responsiveHidden()',
	function () {
		return this.iterator(
			'column',
			function (settings, column) {
				return settings._responsive
					? settings._responsive._responsiveOnlyHidden()[column]
					: false;
			},
			1
		);
	}
);

/**
 * Version information
 *
 * @name Responsive.version
 * @static
 */
Responsive.version = '3.0.2';

$.fn.dataTable.Responsive = Responsive;
$.fn.DataTable.Responsive = Responsive;

// Attach a listener to the document which listens for DataTables initialisation
// events so we can automatically initialise
$(document).on('preInit.dt.dtr', function (e, settings, json) {
	if (e.namespace !== 'dt') {
		return;
	}

	if (
		$(settings.nTable).hasClass('responsive') ||
		$(settings.nTable).hasClass('dt-responsive') ||
		settings.oInit.responsive ||
		datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].defaults.responsive
	) {
		var init = settings.oInit.responsive;

		if (init !== false) {
			new Responsive(settings, $.isPlainObject(init) ? init : {});
		}
	}
});


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/datatables.net/js/dataTables.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/datatables.net/js/dataTables.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/*! DataTables 2.0.8
 * © SpryMedia Ltd - datatables.net/license
 */



// DataTables code uses $ internally, but we want to be able to
// reassign $ with the `use` method, so it is a regular var.
var $ = jquery__WEBPACK_IMPORTED_MODULE_0__;


var DataTable = function ( selector, options )
{
	// Check if called with a window or jQuery object for DOM less applications
	// This is for backwards compatibility
	if (DataTable.factory(selector, options)) {
		return DataTable;
	}

	// When creating with `new`, create a new DataTable, returning the API instance
	if (this instanceof DataTable) {
		return $(selector).DataTable(options);
	}
	else {
		// Argument switching
		options = selector;
	}

	var _that = this;
	var emptyInit = options === undefined;
	var len = this.length;

	if ( emptyInit ) {
		options = {};
	}

	// Method to get DT API instance from jQuery object
	this.api = function ()
	{
		return new _Api( this );
	};

	this.each(function() {
		// For each initialisation we want to give it a clean initialisation
		// object that can be bashed around
		var o = {};
		var oInit = len > 1 ? // optimisation for single table case
			_fnExtend( o, options, true ) :
			options;

		
		var i=0, iLen;
		var sId = this.getAttribute( 'id' );
		var bInitHandedOff = false;
		var defaults = DataTable.defaults;
		var $this = $(this);
		
		
		/* Sanity check */
		if ( this.nodeName.toLowerCase() != 'table' )
		{
			_fnLog( null, 0, 'Non-table node initialisation ('+this.nodeName+')', 2 );
			return;
		}
		
		$(this).trigger( 'options.dt', oInit );
		
		/* Backwards compatibility for the defaults */
		_fnCompatOpts( defaults );
		_fnCompatCols( defaults.column );
		
		/* Convert the camel-case defaults to Hungarian */
		_fnCamelToHungarian( defaults, defaults, true );
		_fnCamelToHungarian( defaults.column, defaults.column, true );
		
		/* Setting up the initialisation object */
		_fnCamelToHungarian( defaults, $.extend( oInit, $this.data() ), true );
		
		
		
		/* Check to see if we are re-initialising a table */
		var allSettings = DataTable.settings;
		for ( i=0, iLen=allSettings.length ; i<iLen ; i++ )
		{
			var s = allSettings[i];
		
			/* Base check on table node */
			if (
				s.nTable == this ||
				(s.nTHead && s.nTHead.parentNode == this) ||
				(s.nTFoot && s.nTFoot.parentNode == this)
			) {
				var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
				var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;
		
				if ( emptyInit || bRetrieve )
				{
					return s.oInstance;
				}
				else if ( bDestroy )
				{
					new DataTable.Api(s).destroy();
					break;
				}
				else
				{
					_fnLog( s, 0, 'Cannot reinitialise DataTable', 3 );
					return;
				}
			}
		
			/* If the element we are initialising has the same ID as a table which was previously
			 * initialised, but the table nodes don't match (from before) then we destroy the old
			 * instance by simply deleting it. This is under the assumption that the table has been
			 * destroyed by other methods. Anyone using non-id selectors will need to do this manually
			 */
			if ( s.sTableId == this.id )
			{
				allSettings.splice( i, 1 );
				break;
			}
		}
		
		/* Ensure the table has an ID - required for accessibility */
		if ( sId === null || sId === "" )
		{
			sId = "DataTables_Table_"+(DataTable.ext._unique++);
			this.id = sId;
		}
		
		/* Create the settings object for this table and set some of the default parameters */
		var oSettings = $.extend( true, {}, DataTable.models.oSettings, {
			"sDestroyWidth": $this[0].style.width,
			"sInstance":     sId,
			"sTableId":      sId,
			colgroup: $('<colgroup>').prependTo(this),
			fastData: function (row, column, type) {
				return _fnGetCellData(oSettings, row, column, type);
			}
		} );
		oSettings.nTable = this;
		oSettings.oInit  = oInit;
		
		allSettings.push( oSettings );
		
		// Make a single API instance available for internal handling
		oSettings.api = new _Api( oSettings );
		
		// Need to add the instance after the instance after the settings object has been added
		// to the settings array, so we can self reference the table instance if more than one
		oSettings.oInstance = (_that.length===1) ? _that : $this.dataTable();
		
		// Backwards compatibility, before we apply all the defaults
		_fnCompatOpts( oInit );
		
		// If the length menu is given, but the init display length is not, use the length menu
		if ( oInit.aLengthMenu && ! oInit.iDisplayLength )
		{
			oInit.iDisplayLength = Array.isArray(oInit.aLengthMenu[0])
				? oInit.aLengthMenu[0][0]
				: $.isPlainObject( oInit.aLengthMenu[0] )
					? oInit.aLengthMenu[0].value
					: oInit.aLengthMenu[0];
		}
		
		// Apply the defaults and init options to make a single init object will all
		// options defined from defaults and instance options.
		oInit = _fnExtend( $.extend( true, {}, defaults ), oInit );
		
		
		// Map the initialisation options onto the settings object
		_fnMap( oSettings.oFeatures, oInit, [
			"bPaginate",
			"bLengthChange",
			"bFilter",
			"bSort",
			"bSortMulti",
			"bInfo",
			"bProcessing",
			"bAutoWidth",
			"bSortClasses",
			"bServerSide",
			"bDeferRender"
		] );
		_fnMap( oSettings, oInit, [
			"ajax",
			"fnFormatNumber",
			"sServerMethod",
			"aaSorting",
			"aaSortingFixed",
			"aLengthMenu",
			"sPaginationType",
			"iStateDuration",
			"bSortCellsTop",
			"iTabIndex",
			"sDom",
			"fnStateLoadCallback",
			"fnStateSaveCallback",
			"renderer",
			"searchDelay",
			"rowId",
			"caption",
			"layout",
			[ "iCookieDuration", "iStateDuration" ], // backwards compat
			[ "oSearch", "oPreviousSearch" ],
			[ "aoSearchCols", "aoPreSearchCols" ],
			[ "iDisplayLength", "_iDisplayLength" ]
		] );
		_fnMap( oSettings.oScroll, oInit, [
			[ "sScrollX", "sX" ],
			[ "sScrollXInner", "sXInner" ],
			[ "sScrollY", "sY" ],
			[ "bScrollCollapse", "bCollapse" ]
		] );
		_fnMap( oSettings.oLanguage, oInit, "fnInfoCallback" );
		
		/* Callback functions which are array driven */
		_fnCallbackReg( oSettings, 'aoDrawCallback',       oInit.fnDrawCallback );
		_fnCallbackReg( oSettings, 'aoStateSaveParams',    oInit.fnStateSaveParams );
		_fnCallbackReg( oSettings, 'aoStateLoadParams',    oInit.fnStateLoadParams );
		_fnCallbackReg( oSettings, 'aoStateLoaded',        oInit.fnStateLoaded );
		_fnCallbackReg( oSettings, 'aoRowCallback',        oInit.fnRowCallback );
		_fnCallbackReg( oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow );
		_fnCallbackReg( oSettings, 'aoHeaderCallback',     oInit.fnHeaderCallback );
		_fnCallbackReg( oSettings, 'aoFooterCallback',     oInit.fnFooterCallback );
		_fnCallbackReg( oSettings, 'aoInitComplete',       oInit.fnInitComplete );
		_fnCallbackReg( oSettings, 'aoPreDrawCallback',    oInit.fnPreDrawCallback );
		
		oSettings.rowIdFn = _fnGetObjectDataFn( oInit.rowId );
		
		/* Browser support detection */
		_fnBrowserDetect( oSettings );
		
		var oClasses = oSettings.oClasses;
		
		$.extend( oClasses, DataTable.ext.classes, oInit.oClasses );
		$this.addClass( oClasses.table );
		
		if (! oSettings.oFeatures.bPaginate) {
			oInit.iDisplayStart = 0;
		}
		
		if ( oSettings.iInitDisplayStart === undefined )
		{
			/* Display start point, taking into account the save saving */
			oSettings.iInitDisplayStart = oInit.iDisplayStart;
			oSettings._iDisplayStart = oInit.iDisplayStart;
		}
		
		/* Language definitions */
		var oLanguage = oSettings.oLanguage;
		$.extend( true, oLanguage, oInit.oLanguage );
		
		if ( oLanguage.sUrl )
		{
			/* Get the language definitions from a file - because this Ajax call makes the language
			 * get async to the remainder of this function we use bInitHandedOff to indicate that
			 * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
			 */
			$.ajax( {
				dataType: 'json',
				url: oLanguage.sUrl,
				success: function ( json ) {
					_fnCamelToHungarian( defaults.oLanguage, json );
					$.extend( true, oLanguage, json, oSettings.oInit.oLanguage );
		
					_fnCallbackFire( oSettings, null, 'i18n', [oSettings], true);
					_fnInitialise( oSettings );
				},
				error: function () {
					// Error occurred loading language file
					_fnLog( oSettings, 0, 'i18n file loading error', 21 );
		
					// continue on as best we can
					_fnInitialise( oSettings );
				}
			} );
			bInitHandedOff = true;
		}
		else {
			_fnCallbackFire( oSettings, null, 'i18n', [oSettings]);
		}
		
		/*
		 * Columns
		 * See if we should load columns automatically or use defined ones
		 */
		var columnsInit = [];
		var thead = this.getElementsByTagName('thead');
		var initHeaderLayout = _fnDetectHeader( oSettings, thead[0] );
		
		// If we don't have a columns array, then generate one with nulls
		if ( oInit.aoColumns ) {
			columnsInit = oInit.aoColumns;
		}
		else if ( initHeaderLayout.length ) {
			for ( i=0, iLen=initHeaderLayout[0].length ; i<iLen ; i++ ) {
				columnsInit.push( null );
			}
		}
		
		// Add the columns
		for ( i=0, iLen=columnsInit.length ; i<iLen ; i++ ) {
			_fnAddColumn( oSettings );
		}
		
		// Apply the column definitions
		_fnApplyColumnDefs( oSettings, oInit.aoColumnDefs, columnsInit, initHeaderLayout, function (iCol, oDef) {
			_fnColumnOptions( oSettings, iCol, oDef );
		} );
		
		/* HTML5 attribute detection - build an mData object automatically if the
		 * attributes are found
		 */
		var rowOne = $this.children('tbody').find('tr').eq(0);
		
		if ( rowOne.length ) {
			var a = function ( cell, name ) {
				return cell.getAttribute( 'data-'+name ) !== null ? name : null;
			};
		
			$( rowOne[0] ).children('th, td').each( function (i, cell) {
				var col = oSettings.aoColumns[i];
		
				if (! col) {
					_fnLog( oSettings, 0, 'Incorrect column count', 18 );
				}
		
				if ( col.mData === i ) {
					var sort = a( cell, 'sort' ) || a( cell, 'order' );
					var filter = a( cell, 'filter' ) || a( cell, 'search' );
		
					if ( sort !== null || filter !== null ) {
						col.mData = {
							_:      i+'.display',
							sort:   sort !== null   ? i+'.@data-'+sort   : undefined,
							type:   sort !== null   ? i+'.@data-'+sort   : undefined,
							filter: filter !== null ? i+'.@data-'+filter : undefined
						};
						col._isArrayHost = true;
		
						_fnColumnOptions( oSettings, i );
					}
				}
			} );
		}
		
		var features = oSettings.oFeatures;
		var loadedInit = function () {
			/*
			 * Sorting
			 * @todo For modularisation (1.11) this needs to do into a sort start up handler
			 */
		
			// If aaSorting is not defined, then we use the first indicator in asSorting
			// in case that has been altered, so the default sort reflects that option
			if ( oInit.aaSorting === undefined ) {
				var sorting = oSettings.aaSorting;
				for ( i=0, iLen=sorting.length ; i<iLen ; i++ ) {
					sorting[i][1] = oSettings.aoColumns[ i ].asSorting[0];
				}
			}
		
			/* Do a first pass on the sorting classes (allows any size changes to be taken into
			 * account, and also will apply sorting disabled classes if disabled
			 */
			_fnSortingClasses( oSettings );
		
			_fnCallbackReg( oSettings, 'aoDrawCallback', function () {
				if ( oSettings.bSorted || _fnDataSource( oSettings ) === 'ssp' || features.bDeferRender ) {
					_fnSortingClasses( oSettings );
				}
			} );
		
		
			/*
			 * Final init
			 * Cache the header, body and footer as required, creating them if needed
			 */
			var caption = $this.children('caption');
		
			if ( oSettings.caption ) {
				if ( caption.length === 0 ) {
					caption = $('<caption/>').appendTo( $this );
				}
		
				caption.html( oSettings.caption );
			}
		
			// Store the caption side, so we can remove the element from the document
			// when creating the element
			if (caption.length) {
				caption[0]._captionSide = caption.css('caption-side');
				oSettings.captionNode = caption[0];
			}
		
			if ( thead.length === 0 ) {
				thead = $('<thead/>').appendTo($this);
			}
			oSettings.nTHead = thead[0];
			$('tr', thead).addClass(oClasses.thead.row);
		
			var tbody = $this.children('tbody');
			if ( tbody.length === 0 ) {
				tbody = $('<tbody/>').insertAfter(thead);
			}
			oSettings.nTBody = tbody[0];
		
			var tfoot = $this.children('tfoot');
			if ( tfoot.length === 0 ) {
				// If we are a scrolling table, and no footer has been given, then we need to create
				// a tfoot element for the caption element to be appended to
				tfoot = $('<tfoot/>').appendTo($this);
			}
			oSettings.nTFoot = tfoot[0];
			$('tr', tfoot).addClass(oClasses.tfoot.row);
		
			// Check if there is data passing into the constructor
			if ( oInit.aaData ) {
				for ( i=0 ; i<oInit.aaData.length ; i++ ) {
					_fnAddData( oSettings, oInit.aaData[ i ] );
				}
			}
			else if ( _fnDataSource( oSettings ) == 'dom' ) {
				// Grab the data from the page
				_fnAddTr( oSettings, $(oSettings.nTBody).children('tr') );
			}
		
			/* Copy the data index array */
			oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
		
			/* Initialisation complete - table can be drawn */
			oSettings.bInitialised = true;
		
			/* Check if we need to initialise the table (it might not have been handed off to the
			 * language processor)
			 */
			if ( bInitHandedOff === false ) {
				_fnInitialise( oSettings );
			}
		};
		
		/* Must be done after everything which can be overridden by the state saving! */
		_fnCallbackReg( oSettings, 'aoDrawCallback', _fnSaveState );
		
		if ( oInit.bStateSave )
		{
			features.bStateSave = true;
			_fnLoadState( oSettings, oInit, loadedInit );
		}
		else {
			loadedInit();
		}
		
	} );
	_that = null;
	return this;
};



/**
 * DataTables extensions
 * 
 * This namespace acts as a collection area for plug-ins that can be used to
 * extend DataTables capabilities. Indeed many of the build in methods
 * use this method to provide their own capabilities (sorting methods for
 * example).
 *
 * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
 * reasons
 *
 *  @namespace
 */
DataTable.ext = _ext = {
	/**
	 * Buttons. For use with the Buttons extension for DataTables. This is
	 * defined here so other extensions can define buttons regardless of load
	 * order. It is _not_ used by DataTables core.
	 *
	 *  @type object
	 *  @default {}
	 */
	buttons: {},


	/**
	 * Element class names
	 *
	 *  @type object
	 *  @default {}
	 */
	classes: {},


	/**
	 * DataTables build type (expanded by the download builder)
	 *
	 *  @type string
	 */
	builder: "-source-",


	/**
	 * Error reporting.
	 * 
	 * How should DataTables report an error. Can take the value 'alert',
	 * 'throw', 'none' or a function.
	 *
	 *  @type string|function
	 *  @default alert
	 */
	errMode: "alert",


	/**
	 * Legacy so v1 plug-ins don't throw js errors on load
	 */
	feature: [],

	/**
	 * Feature plug-ins.
	 * 
	 * This is an object of callbacks which provide the features for DataTables
	 * to be initialised via the `layout` option.
	 */
	features: {},


	/**
	 * Row searching.
	 * 
	 * This method of searching is complimentary to the default type based
	 * searching, and a lot more comprehensive as it allows you complete control
	 * over the searching logic. Each element in this array is a function
	 * (parameters described below) that is called for every row in the table,
	 * and your logic decides if it should be included in the searching data set
	 * or not.
	 *
	 * Searching functions have the following input parameters:
	 *
	 * 1. `{object}` DataTables settings object: see
	 *    {@link DataTable.models.oSettings}
	 * 2. `{array|object}` Data for the row to be processed (same as the
	 *    original format that was passed in as the data source, or an array
	 *    from a DOM data source
	 * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
	 *    can be useful to retrieve the `TR` element if you need DOM interaction.
	 *
	 * And the following return is expected:
	 *
	 * * {boolean} Include the row in the searched result set (true) or not
	 *   (false)
	 *
	 * Note that as with the main search ability in DataTables, technically this
	 * is "filtering", since it is subtractive. However, for consistency in
	 * naming we call it searching here.
	 *
	 *  @type array
	 *  @default []
	 *
	 *  @example
	 *    // The following example shows custom search being applied to the
	 *    // fourth column (i.e. the data[3] index) based on two input values
	 *    // from the end-user, matching the data in a certain range.
	 *    $.fn.dataTable.ext.search.push(
	 *      function( settings, data, dataIndex ) {
	 *        var min = document.getElementById('min').value * 1;
	 *        var max = document.getElementById('max').value * 1;
	 *        var version = data[3] == "-" ? 0 : data[3]*1;
	 *
	 *        if ( min == "" && max == "" ) {
	 *          return true;
	 *        }
	 *        else if ( min == "" && version < max ) {
	 *          return true;
	 *        }
	 *        else if ( min < version && "" == max ) {
	 *          return true;
	 *        }
	 *        else if ( min < version && version < max ) {
	 *          return true;
	 *        }
	 *        return false;
	 *      }
	 *    );
	 */
	search: [],


	/**
	 * Selector extensions
	 *
	 * The `selector` option can be used to extend the options available for the
	 * selector modifier options (`selector-modifier` object data type) that
	 * each of the three built in selector types offer (row, column and cell +
	 * their plural counterparts). For example the Select extension uses this
	 * mechanism to provide an option to select only rows, columns and cells
	 * that have been marked as selected by the end user (`{selected: true}`),
	 * which can be used in conjunction with the existing built in selector
	 * options.
	 *
	 * Each property is an array to which functions can be pushed. The functions
	 * take three attributes:
	 *
	 * * Settings object for the host table
	 * * Options object (`selector-modifier` object type)
	 * * Array of selected item indexes
	 *
	 * The return is an array of the resulting item indexes after the custom
	 * selector has been applied.
	 *
	 *  @type object
	 */
	selector: {
		cell: [],
		column: [],
		row: []
	},


	/**
	 * Legacy configuration options. Enable and disable legacy options that
	 * are available in DataTables.
	 *
	 *  @type object
	 */
	legacy: {
		/**
		 * Enable / disable DataTables 1.9 compatible server-side processing
		 * requests
		 *
		 *  @type boolean
		 *  @default null
		 */
		ajax: null
	},


	/**
	 * Pagination plug-in methods.
	 * 
	 * Each entry in this object is a function and defines which buttons should
	 * be shown by the pagination rendering method that is used for the table:
	 * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
	 * buttons are displayed in the document, while the functions here tell it
	 * what buttons to display. This is done by returning an array of button
	 * descriptions (what each button will do).
	 *
	 * Pagination types (the four built in options and any additional plug-in
	 * options defined here) can be used through the `paginationType`
	 * initialisation parameter.
	 *
	 * The functions defined take two parameters:
	 *
	 * 1. `{int} page` The current page index
	 * 2. `{int} pages` The number of pages in the table
	 *
	 * Each function is expected to return an array where each element of the
	 * array can be one of:
	 *
	 * * `first` - Jump to first page when activated
	 * * `last` - Jump to last page when activated
	 * * `previous` - Show previous page when activated
	 * * `next` - Show next page when activated
	 * * `{int}` - Show page of the index given
	 * * `{array}` - A nested array containing the above elements to add a
	 *   containing 'DIV' element (might be useful for styling).
	 *
	 * Note that DataTables v1.9- used this object slightly differently whereby
	 * an object with two functions would be defined for each plug-in. That
	 * ability is still supported by DataTables 1.10+ to provide backwards
	 * compatibility, but this option of use is now decremented and no longer
	 * documented in DataTables 1.10+.
	 *
	 *  @type object
	 *  @default {}
	 *
	 *  @example
	 *    // Show previous, next and current page buttons only
	 *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
	 *      return [ 'previous', page, 'next' ];
	 *    };
	 */
	pager: {},


	renderer: {
		pageButton: {},
		header: {}
	},


	/**
	 * Ordering plug-ins - custom data source
	 * 
	 * The extension options for ordering of data available here is complimentary
	 * to the default type based ordering that DataTables typically uses. It
	 * allows much greater control over the the data that is being used to
	 * order a column, but is necessarily therefore more complex.
	 * 
	 * This type of ordering is useful if you want to do ordering based on data
	 * live from the DOM (for example the contents of an 'input' element) rather
	 * than just the static string that DataTables knows of.
	 * 
	 * The way these plug-ins work is that you create an array of the values you
	 * wish to be ordering for the column in question and then return that
	 * array. The data in the array much be in the index order of the rows in
	 * the table (not the currently ordering order!). Which order data gathering
	 * function is run here depends on the `dt-init columns.orderDataType`
	 * parameter that is used for the column (if any).
	 *
	 * The functions defined take two parameters:
	 *
	 * 1. `{object}` DataTables settings object: see
	 *    {@link DataTable.models.oSettings}
	 * 2. `{int}` Target column index
	 *
	 * Each function is expected to return an array:
	 *
	 * * `{array}` Data for the column to be ordering upon
	 *
	 *  @type array
	 *
	 *  @example
	 *    // Ordering using `input` node values
	 *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
	 *    {
	 *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
	 *        return $('input', td).val();
	 *      } );
	 *    }
	 */
	order: {},


	/**
	 * Type based plug-ins.
	 *
	 * Each column in DataTables has a type assigned to it, either by automatic
	 * detection or by direct assignment using the `type` option for the column.
	 * The type of a column will effect how it is ordering and search (plug-ins
	 * can also make use of the column type if required).
	 *
	 * @namespace
	 */
	type: {
		/**
		 * Automatic column class assignment
		 */
		className: {},

		/**
		 * Type detection functions.
		 *
		 * The functions defined in this object are used to automatically detect
		 * a column's type, making initialisation of DataTables super easy, even
		 * when complex data is in the table.
		 *
		 * The functions defined take two parameters:
		 *
	     *  1. `{*}` Data from the column cell to be analysed
	     *  2. `{settings}` DataTables settings object. This can be used to
	     *     perform context specific type detection - for example detection
	     *     based on language settings such as using a comma for a decimal
	     *     place. Generally speaking the options from the settings will not
	     *     be required
		 *
		 * Each function is expected to return:
		 *
		 * * `{string|null}` Data type detected, or null if unknown (and thus
		 *   pass it on to the other type detection functions.
		 *
		 *  @type array
		 *
		 *  @example
		 *    // Currency type detection plug-in:
		 *    $.fn.dataTable.ext.type.detect.push(
		 *      function ( data, settings ) {
		 *        // Check the numeric part
		 *        if ( ! data.substring(1).match(/[0-9]/) ) {
		 *          return null;
		 *        }
		 *
		 *        // Check prefixed by currency
		 *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
		 *          return 'currency';
		 *        }
		 *        return null;
		 *      }
		 *    );
		 */
		detect: [],

		/**
		 * Automatic renderer assignment
		 */
		render: {},


		/**
		 * Type based search formatting.
		 *
		 * The type based searching functions can be used to pre-format the
		 * data to be search on. For example, it can be used to strip HTML
		 * tags or to de-format telephone numbers for numeric only searching.
		 *
		 * Note that is a search is not defined for a column of a given type,
		 * no search formatting will be performed.
		 * 
		 * Pre-processing of searching data plug-ins - When you assign the sType
		 * for a column (or have it automatically detected for you by DataTables
		 * or a type detection plug-in), you will typically be using this for
		 * custom sorting, but it can also be used to provide custom searching
		 * by allowing you to pre-processing the data and returning the data in
		 * the format that should be searched upon. This is done by adding
		 * functions this object with a parameter name which matches the sType
		 * for that target column. This is the corollary of <i>afnSortData</i>
		 * for searching data.
		 *
		 * The functions defined take a single parameter:
		 *
	     *  1. `{*}` Data from the column cell to be prepared for searching
		 *
		 * Each function is expected to return:
		 *
		 * * `{string|null}` Formatted string that will be used for the searching.
		 *
		 *  @type object
		 *  @default {}
		 *
		 *  @example
		 *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
		 *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
		 *    }
		 */
		search: {},


		/**
		 * Type based ordering.
		 *
		 * The column type tells DataTables what ordering to apply to the table
		 * when a column is sorted upon. The order for each type that is defined,
		 * is defined by the functions available in this object.
		 *
		 * Each ordering option can be described by three properties added to
		 * this object:
		 *
		 * * `{type}-pre` - Pre-formatting function
		 * * `{type}-asc` - Ascending order function
		 * * `{type}-desc` - Descending order function
		 *
		 * All three can be used together, only `{type}-pre` or only
		 * `{type}-asc` and `{type}-desc` together. It is generally recommended
		 * that only `{type}-pre` is used, as this provides the optimal
		 * implementation in terms of speed, although the others are provided
		 * for compatibility with existing Javascript sort functions.
		 *
		 * `{type}-pre`: Functions defined take a single parameter:
		 *
	     *  1. `{*}` Data from the column cell to be prepared for ordering
		 *
		 * And return:
		 *
		 * * `{*}` Data to be sorted upon
		 *
		 * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
		 * functions, taking two parameters:
		 *
	     *  1. `{*}` Data to compare to the second parameter
	     *  2. `{*}` Data to compare to the first parameter
		 *
		 * And returning:
		 *
		 * * `{*}` Ordering match: <0 if first parameter should be sorted lower
		 *   than the second parameter, ===0 if the two parameters are equal and
		 *   >0 if the first parameter should be sorted height than the second
		 *   parameter.
		 * 
		 *  @type object
		 *  @default {}
		 *
		 *  @example
		 *    // Numeric ordering of formatted numbers with a pre-formatter
		 *    $.extend( $.fn.dataTable.ext.type.order, {
		 *      "string-pre": function(x) {
		 *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
		 *        return parseFloat( a );
		 *      }
		 *    } );
		 *
		 *  @example
		 *    // Case-sensitive string ordering, with no pre-formatting method
		 *    $.extend( $.fn.dataTable.ext.order, {
		 *      "string-case-asc": function(x,y) {
		 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		 *      },
		 *      "string-case-desc": function(x,y) {
		 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
		 *      }
		 *    } );
		 */
		order: {}
	},

	/**
	 * Unique DataTables instance counter
	 *
	 * @type int
	 * @private
	 */
	_unique: 0,


	//
	// Depreciated
	// The following properties are retained for backwards compatibility only.
	// The should not be used in new projects and will be removed in a future
	// version
	//

	/**
	 * Version check function.
	 *  @type function
	 *  @depreciated Since 1.10
	 */
	fnVersionCheck: DataTable.fnVersionCheck,


	/**
	 * Index for what 'this' index API functions should use
	 *  @type int
	 *  @deprecated Since v1.10
	 */
	iApiIndex: 0,


	/**
	 * Software version
	 *  @type string
	 *  @deprecated Since v1.10
	 */
	sVersion: DataTable.version
};


//
// Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
//
$.extend( _ext, {
	afnFiltering: _ext.search,
	aTypes:       _ext.type.detect,
	ofnSearch:    _ext.type.search,
	oSort:        _ext.type.order,
	afnSortData:  _ext.order,
	aoFeatures:   _ext.feature,
	oStdClasses:  _ext.classes,
	oPagination:  _ext.pager
} );


$.extend( DataTable.ext.classes, {
	container: 'dt-container',
	empty: {
		row: 'dt-empty'
	},
	info: {
		container: 'dt-info'
	},
	length: {
		container: 'dt-length',
		select: 'dt-input'
	},
	order: {
		canAsc: 'dt-orderable-asc',
		canDesc: 'dt-orderable-desc',
		isAsc: 'dt-ordering-asc',
		isDesc: 'dt-ordering-desc',
		none: 'dt-orderable-none',
		position: 'sorting_'
	},
	processing: {
		container: 'dt-processing'
	},
	scrolling: {
		body: 'dt-scroll-body',
		container: 'dt-scroll',
		footer: {
			self: 'dt-scroll-foot',
			inner: 'dt-scroll-footInner'
		},
		header: {
			self: 'dt-scroll-head',
			inner: 'dt-scroll-headInner'
		}
	},
	search: {
		container: 'dt-search',
		input: 'dt-input'
	},
	table: 'dataTable',	
	tbody: {
		cell: '',
		row: ''
	},
	thead: {
		cell: '',
		row: ''
	},
	tfoot: {
		cell: '',
		row: ''
	},
	paging: {
		active: 'current',
		button: 'dt-paging-button',
		container: 'dt-paging',
		disabled: 'disabled'
	}
} );


/*
 * It is useful to have variables which are scoped locally so only the
 * DataTables functions can access them and they don't leak into global space.
 * At the same time these functions are often useful over multiple files in the
 * core and API, so we list, or at least document, all variables which are used
 * by DataTables as private variables here. This also ensures that there is no
 * clashing of variable names and that they can easily referenced for reuse.
 */


// Defined else where
//  _selector_run
//  _selector_opts
//  _selector_row_indexes

var _ext; // DataTable.ext
var _Api; // DataTable.Api
var _api_register; // DataTable.Api.register
var _api_registerPlural; // DataTable.Api.registerPlural

var _re_dic = {};
var _re_new_lines = /[\r\n\u2028]/g;
var _re_html = /<([^>]*>)/g;
var _max_str_len = Math.pow(2, 28);

// This is not strict ISO8601 - Date.parse() is quite lax, although
// implementations differ between browsers.
var _re_date = /^\d{2,4}[./-]\d{1,2}[./-]\d{1,2}([T ]{1}\d{1,2}[:.]\d{2}([.:]\d{2})?)?$/;

// Escape regular expression special characters
var _re_escape_regex = new RegExp( '(\\' + [ '/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-' ].join('|\\') + ')', 'g' );

// https://en.wikipedia.org/wiki/Foreign_exchange_market
// - \u20BD - Russian ruble.
// - \u20a9 - South Korean Won
// - \u20BA - Turkish Lira
// - \u20B9 - Indian Rupee
// - R - Brazil (R$) and South Africa
// - fr - Swiss Franc
// - kr - Swedish krona, Norwegian krone and Danish krone
// - \u2009 is thin space and \u202F is narrow no-break space, both used in many
// - Ƀ - Bitcoin
// - Ξ - Ethereum
//   standards as thousands separators.
var _re_formatted_numeric = /['\u00A0,$£€¥%\u2009\u202F\u20BD\u20a9\u20BArfkɃΞ]/gi;


var _empty = function ( d ) {
	return !d || d === true || d === '-' ? true : false;
};


var _intVal = function ( s ) {
	var integer = parseInt( s, 10 );
	return !isNaN(integer) && isFinite(s) ? integer : null;
};

// Convert from a formatted number with characters other than `.` as the
// decimal place, to a Javascript number
var _numToDecimal = function ( num, decimalPoint ) {
	// Cache created regular expressions for speed as this function is called often
	if ( ! _re_dic[ decimalPoint ] ) {
		_re_dic[ decimalPoint ] = new RegExp( _fnEscapeRegex( decimalPoint ), 'g' );
	}
	return typeof num === 'string' && decimalPoint !== '.' ?
		num.replace( /\./g, '' ).replace( _re_dic[ decimalPoint ], '.' ) :
		num;
};


var _isNumber = function ( d, decimalPoint, formatted ) {
	var type = typeof d;
	var strType = type === 'string';

	if ( type === 'number' || type === 'bigint') {
		return true;
	}

	// If empty return immediately so there must be a number if it is a
	// formatted string (this stops the string "k", or "kr", etc being detected
	// as a formatted number for currency
	if ( _empty( d ) ) {
		return true;
	}

	if ( decimalPoint && strType ) {
		d = _numToDecimal( d, decimalPoint );
	}

	if ( formatted && strType ) {
		d = d.replace( _re_formatted_numeric, '' );
	}

	return !isNaN( parseFloat(d) ) && isFinite( d );
};


// A string without HTML in it can be considered to be HTML still
var _isHtml = function ( d ) {
	return _empty( d ) || typeof d === 'string';
};

// Is a string a number surrounded by HTML?
var _htmlNumeric = function ( d, decimalPoint, formatted ) {
	if ( _empty( d ) ) {
		return true;
	}

	// input and select strings mean that this isn't just a number
	if (typeof d === 'string' && d.match(/<(input|select)/i)) {
		return null;
	}

	var html = _isHtml( d );
	return ! html ?
		null :
		_isNumber( _stripHtml( d ), decimalPoint, formatted ) ?
			true :
			null;
};


var _pluck = function ( a, prop, prop2 ) {
	var out = [];
	var i=0, ien=a.length;

	// Could have the test in the loop for slightly smaller code, but speed
	// is essential here
	if ( prop2 !== undefined ) {
		for ( ; i<ien ; i++ ) {
			if ( a[i] && a[i][ prop ] ) {
				out.push( a[i][ prop ][ prop2 ] );
			}
		}
	}
	else {
		for ( ; i<ien ; i++ ) {
			if ( a[i] ) {
				out.push( a[i][ prop ] );
			}
		}
	}

	return out;
};


// Basically the same as _pluck, but rather than looping over `a` we use `order`
// as the indexes to pick from `a`
var _pluck_order = function ( a, order, prop, prop2 )
{
	var out = [];
	var i=0, ien=order.length;

	// Could have the test in the loop for slightly smaller code, but speed
	// is essential here
	if ( prop2 !== undefined ) {
		for ( ; i<ien ; i++ ) {
			if ( a[ order[i] ][ prop ] ) {
				out.push( a[ order[i] ][ prop ][ prop2 ] );
			}
		}
	}
	else {
		for ( ; i<ien ; i++ ) {
			if ( a[ order[i] ] ) {
				out.push( a[ order[i] ][ prop ] );
			}
		}
	}

	return out;
};


var _range = function ( len, start )
{
	var out = [];
	var end;

	if ( start === undefined ) {
		start = 0;
		end = len;
	}
	else {
		end = start;
		start = len;
	}

	for ( var i=start ; i<end ; i++ ) {
		out.push( i );
	}

	return out;
};


var _removeEmpty = function ( a )
{
	var out = [];

	for ( var i=0, ien=a.length ; i<ien ; i++ ) {
		if ( a[i] ) { // careful - will remove all falsy values!
			out.push( a[i] );
		}
	}

	return out;
};

// Replaceable function in api.util
var _stripHtml = function (input) {
	// Irrelevant check to workaround CodeQL's false positive on the regex
	if (input.length > _max_str_len) {
		throw new Error('Exceeded max str len');
	}

	var previous;

	input = input.replace(_re_html, ''); // Complete tags

	// Safety for incomplete script tag - use do / while to ensure that
	// we get all instances
	do {
		previous = input;
		input = input.replace(/<script/i, '');
	} while (input !== previous);

	return previous;
};

// Replaceable function in api.util
var _escapeHtml = function ( d ) {
	if (Array.isArray(d)) {
		d = d.join(',');
	}

	return typeof d === 'string' ?
		d
			.replace(/&/g, '&amp;')
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(/"/g, '&quot;') :
		d;
};

// Remove diacritics from a string by decomposing it and then removing
// non-ascii characters
var _normalize = function (str, both) {
	if (typeof str !== 'string') {
		return str;
	}

	// It is faster to just run `normalize` than it is to check if
	// we need to with a regex!
	var res = str.normalize("NFD");

	// Equally, here we check if a regex is needed or not
	return res.length !== str.length
		? (both === true ? str + ' ' : '' ) + res.replace(/[\u0300-\u036f]/g, "")
		: res;
}

/**
 * Determine if all values in the array are unique. This means we can short
 * cut the _unique method at the cost of a single loop. A sorted array is used
 * to easily check the values.
 *
 * @param  {array} src Source array
 * @return {boolean} true if all unique, false otherwise
 * @ignore
 */
var _areAllUnique = function ( src ) {
	if ( src.length < 2 ) {
		return true;
	}

	var sorted = src.slice().sort();
	var last = sorted[0];

	for ( var i=1, ien=sorted.length ; i<ien ; i++ ) {
		if ( sorted[i] === last ) {
			return false;
		}

		last = sorted[i];
	}

	return true;
};


/**
 * Find the unique elements in a source array.
 *
 * @param  {array} src Source array
 * @return {array} Array of unique items
 * @ignore
 */
var _unique = function ( src )
{
	if (Array.from && Set) {
		return Array.from(new Set(src));
	}

	if ( _areAllUnique( src ) ) {
		return src.slice();
	}

	// A faster unique method is to use object keys to identify used values,
	// but this doesn't work with arrays or objects, which we must also
	// consider. See jsperf.app/compare-array-unique-versions/4 for more
	// information.
	var
		out = [],
		val,
		i, ien=src.length,
		j, k=0;

	again: for ( i=0 ; i<ien ; i++ ) {
		val = src[i];

		for ( j=0 ; j<k ; j++ ) {
			if ( out[j] === val ) {
				continue again;
			}
		}

		out.push( val );
		k++;
	}

	return out;
};

// Surprisingly this is faster than [].concat.apply
// https://jsperf.com/flatten-an-array-loop-vs-reduce/2
var _flatten = function (out, val) {
	if (Array.isArray(val)) {
		for (var i=0 ; i<val.length ; i++) {
			_flatten(out, val[i]);
		}
	}
	else {
		out.push(val);
	}

	return out;
}

// Similar to jQuery's addClass, but use classList.add
function _addClass(el, name) {
	if (name) {
		name.split(' ').forEach(function (n) {
			if (n) {
				// `add` does deduplication, so no need to check `contains`
				el.classList.add(n);
			}
		});
	}
}

/**
 * DataTables utility methods
 * 
 * This namespace provides helper methods that DataTables uses internally to
 * create a DataTable, but which are not exclusively used only for DataTables.
 * These methods can be used by extension authors to save the duplication of
 * code.
 *
 *  @namespace
 */
DataTable.util = {
	/**
	 * Return a string with diacritic characters decomposed
	 * @param {*} mixed Function or string to normalize
	 * @param {*} both Return original string and the normalized string
	 * @returns String or undefined
	 */
	diacritics: function (mixed, both) {
		var type = typeof mixed;

		if (type !== 'function') {
			return _normalize(mixed, both);
		}
		_normalize = mixed;
	},

	/**
	 * Debounce a function
	 *
	 * @param {function} fn Function to be called
	 * @param {integer} freq Call frequency in mS
	 * @return {function} Wrapped function
	 */
	debounce: function ( fn, timeout ) {
		var timer;

		return function () {
			var that = this;
			var args = arguments;

			clearTimeout(timer);

			timer = setTimeout( function () {
				fn.apply(that, args);
			}, timeout || 250 );
		};
	},

	/**
	 * Throttle the calls to a function. Arguments and context are maintained
	 * for the throttled function.
	 *
	 * @param {function} fn Function to be called
	 * @param {integer} freq Call frequency in mS
	 * @return {function} Wrapped function
	 */
	throttle: function ( fn, freq ) {
		var
			frequency = freq !== undefined ? freq : 200,
			last,
			timer;

		return function () {
			var
				that = this,
				now  = +new Date(),
				args = arguments;

			if ( last && now < last + frequency ) {
				clearTimeout( timer );

				timer = setTimeout( function () {
					last = undefined;
					fn.apply( that, args );
				}, frequency );
			}
			else {
				last = now;
				fn.apply( that, args );
			}
		};
	},

	/**
	 * Escape a string such that it can be used in a regular expression
	 *
	 *  @param {string} val string to escape
	 *  @returns {string} escaped string
	 */
	escapeRegex: function ( val ) {
		return val.replace( _re_escape_regex, '\\$1' );
	},

	/**
	 * Create a function that will write to a nested object or array
	 * @param {*} source JSON notation string
	 * @returns Write function
	 */
	set: function ( source ) {
		if ( $.isPlainObject( source ) ) {
			/* Unlike get, only the underscore (global) option is used for for
			 * setting data since we don't know the type here. This is why an object
			 * option is not documented for `mData` (which is read/write), but it is
			 * for `mRender` which is read only.
			 */
			return DataTable.util.set( source._ );
		}
		else if ( source === null ) {
			// Nothing to do when the data source is null
			return function () {};
		}
		else if ( typeof source === 'function' ) {
			return function (data, val, meta) {
				source( data, 'set', val, meta );
			};
		}
		else if (
			typeof source === 'string' && (source.indexOf('.') !== -1 ||
			source.indexOf('[') !== -1 || source.indexOf('(') !== -1)
		) {
			// Like the get, we need to get data from a nested object
			var setData = function (data, val, src) {
				var a = _fnSplitObjNotation( src ), b;
				var aLast = a[a.length-1];
				var arrayNotation, funcNotation, o, innerSrc;
	
				for ( var i=0, iLen=a.length-1 ; i<iLen ; i++ ) {
					// Protect against prototype pollution
					if (a[i] === '__proto__' || a[i] === 'constructor') {
						throw new Error('Cannot set prototype values');
					}
	
					// Check if we are dealing with an array notation request
					arrayNotation = a[i].match(__reArray);
					funcNotation = a[i].match(__reFn);
	
					if ( arrayNotation ) {
						a[i] = a[i].replace(__reArray, '');
						data[ a[i] ] = [];
	
						// Get the remainder of the nested object to set so we can recurse
						b = a.slice();
						b.splice( 0, i+1 );
						innerSrc = b.join('.');
	
						// Traverse each entry in the array setting the properties requested
						if ( Array.isArray( val ) ) {
							for ( var j=0, jLen=val.length ; j<jLen ; j++ ) {
								o = {};
								setData( o, val[j], innerSrc );
								data[ a[i] ].push( o );
							}
						}
						else {
							// We've been asked to save data to an array, but it
							// isn't array data to be saved. Best that can be done
							// is to just save the value.
							data[ a[i] ] = val;
						}
	
						// The inner call to setData has already traversed through the remainder
						// of the source and has set the data, thus we can exit here
						return;
					}
					else if ( funcNotation ) {
						// Function call
						a[i] = a[i].replace(__reFn, '');
						data = data[ a[i] ]( val );
					}
	
					// If the nested object doesn't currently exist - since we are
					// trying to set the value - create it
					if ( data[ a[i] ] === null || data[ a[i] ] === undefined ) {
						data[ a[i] ] = {};
					}
					data = data[ a[i] ];
				}
	
				// Last item in the input - i.e, the actual set
				if ( aLast.match(__reFn ) ) {
					// Function call
					data = data[ aLast.replace(__reFn, '') ]( val );
				}
				else {
					// If array notation is used, we just want to strip it and use the property name
					// and assign the value. If it isn't used, then we get the result we want anyway
					data[ aLast.replace(__reArray, '') ] = val;
				}
			};
	
			return function (data, val) { // meta is also passed in, but not used
				return setData( data, val, source );
			};
		}
		else {
			// Array or flat object mapping
			return function (data, val) { // meta is also passed in, but not used
				data[source] = val;
			};
		}
	},

	/**
	 * Create a function that will read nested objects from arrays, based on JSON notation
	 * @param {*} source JSON notation string
	 * @returns Value read
	 */
	get: function ( source ) {
		if ( $.isPlainObject( source ) ) {
			// Build an object of get functions, and wrap them in a single call
			var o = {};
			$.each( source, function (key, val) {
				if ( val ) {
					o[key] = DataTable.util.get( val );
				}
			} );
	
			return function (data, type, row, meta) {
				var t = o[type] || o._;
				return t !== undefined ?
					t(data, type, row, meta) :
					data;
			};
		}
		else if ( source === null ) {
			// Give an empty string for rendering / sorting etc
			return function (data) { // type, row and meta also passed, but not used
				return data;
			};
		}
		else if ( typeof source === 'function' ) {
			return function (data, type, row, meta) {
				return source( data, type, row, meta );
			};
		}
		else if (
			typeof source === 'string' && (source.indexOf('.') !== -1 ||
			source.indexOf('[') !== -1 || source.indexOf('(') !== -1)
		) {
			/* If there is a . in the source string then the data source is in a
			 * nested object so we loop over the data for each level to get the next
			 * level down. On each loop we test for undefined, and if found immediately
			 * return. This allows entire objects to be missing and sDefaultContent to
			 * be used if defined, rather than throwing an error
			 */
			var fetchData = function (data, type, src) {
				var arrayNotation, funcNotation, out, innerSrc;
	
				if ( src !== "" ) {
					var a = _fnSplitObjNotation( src );
	
					for ( var i=0, iLen=a.length ; i<iLen ; i++ ) {
						// Check if we are dealing with special notation
						arrayNotation = a[i].match(__reArray);
						funcNotation = a[i].match(__reFn);
	
						if ( arrayNotation ) {
							// Array notation
							a[i] = a[i].replace(__reArray, '');
	
							// Condition allows simply [] to be passed in
							if ( a[i] !== "" ) {
								data = data[ a[i] ];
							}
							out = [];
	
							// Get the remainder of the nested object to get
							a.splice( 0, i+1 );
							innerSrc = a.join('.');
	
							// Traverse each entry in the array getting the properties requested
							if ( Array.isArray( data ) ) {
								for ( var j=0, jLen=data.length ; j<jLen ; j++ ) {
									out.push( fetchData( data[j], type, innerSrc ) );
								}
							}
	
							// If a string is given in between the array notation indicators, that
							// is used to join the strings together, otherwise an array is returned
							var join = arrayNotation[0].substring(1, arrayNotation[0].length-1);
							data = (join==="") ? out : out.join(join);
	
							// The inner call to fetchData has already traversed through the remainder
							// of the source requested, so we exit from the loop
							break;
						}
						else if ( funcNotation ) {
							// Function call
							a[i] = a[i].replace(__reFn, '');
							data = data[ a[i] ]();
							continue;
						}
	
						if (data === null || data[ a[i] ] === null) {
							return null;
						}
						else if ( data === undefined || data[ a[i] ] === undefined ) {
							return undefined;
						}

						data = data[ a[i] ];
					}
				}
	
				return data;
			};
	
			return function (data, type) { // row and meta also passed, but not used
				return fetchData( data, type, source );
			};
		}
		else {
			// Array or flat object mapping
			return function (data) { // row and meta also passed, but not used
				return data[source];
			};
		}
	},

	stripHtml: function (mixed) {
		var type = typeof mixed;

		if (type === 'function') {
			_stripHtml = mixed;
			return;
		}
		else if (type === 'string') {
			return _stripHtml(mixed);
		}
		return mixed;
	},

	escapeHtml: function (mixed) {
		var type = typeof mixed;

		if (type === 'function') {
			_escapeHtml = mixed;
			return;
		}
		else if (type === 'string' || Array.isArray(mixed)) {
			return _escapeHtml(mixed);
		}
		return mixed;
	},

	unique: _unique
};



/**
 * Create a mapping object that allows camel case parameters to be looked up
 * for their Hungarian counterparts. The mapping is stored in a private
 * parameter called `_hungarianMap` which can be accessed on the source object.
 *  @param {object} o
 *  @memberof DataTable#oApi
 */
function _fnHungarianMap ( o )
{
	var
		hungarian = 'a aa ai ao as b fn i m o s ',
		match,
		newKey,
		map = {};

	$.each( o, function (key) {
		match = key.match(/^([^A-Z]+?)([A-Z])/);

		if ( match && hungarian.indexOf(match[1]+' ') !== -1 )
		{
			newKey = key.replace( match[0], match[2].toLowerCase() );
			map[ newKey ] = key;

			if ( match[1] === 'o' )
			{
				_fnHungarianMap( o[key] );
			}
		}
	} );

	o._hungarianMap = map;
}


/**
 * Convert from camel case parameters to Hungarian, based on a Hungarian map
 * created by _fnHungarianMap.
 *  @param {object} src The model object which holds all parameters that can be
 *    mapped.
 *  @param {object} user The object to convert from camel case to Hungarian.
 *  @param {boolean} force When set to `true`, properties which already have a
 *    Hungarian value in the `user` object will be overwritten. Otherwise they
 *    won't be.
 *  @memberof DataTable#oApi
 */
function _fnCamelToHungarian ( src, user, force )
{
	if ( ! src._hungarianMap ) {
		_fnHungarianMap( src );
	}

	var hungarianKey;

	$.each( user, function (key) {
		hungarianKey = src._hungarianMap[ key ];

		if ( hungarianKey !== undefined && (force || user[hungarianKey] === undefined) )
		{
			// For objects, we need to buzz down into the object to copy parameters
			if ( hungarianKey.charAt(0) === 'o' )
			{
				// Copy the camelCase options over to the hungarian
				if ( ! user[ hungarianKey ] ) {
					user[ hungarianKey ] = {};
				}
				$.extend( true, user[hungarianKey], user[key] );

				_fnCamelToHungarian( src[hungarianKey], user[hungarianKey], force );
			}
			else {
				user[hungarianKey] = user[ key ];
			}
		}
	} );
}

/**
 * Map one parameter onto another
 *  @param {object} o Object to map
 *  @param {*} knew The new parameter name
 *  @param {*} old The old parameter name
 */
var _fnCompatMap = function ( o, knew, old ) {
	if ( o[ knew ] !== undefined ) {
		o[ old ] = o[ knew ];
	}
};


/**
 * Provide backwards compatibility for the main DT options. Note that the new
 * options are mapped onto the old parameters, so this is an external interface
 * change only.
 *  @param {object} init Object to map
 */
function _fnCompatOpts ( init )
{
	_fnCompatMap( init, 'ordering',      'bSort' );
	_fnCompatMap( init, 'orderMulti',    'bSortMulti' );
	_fnCompatMap( init, 'orderClasses',  'bSortClasses' );
	_fnCompatMap( init, 'orderCellsTop', 'bSortCellsTop' );
	_fnCompatMap( init, 'order',         'aaSorting' );
	_fnCompatMap( init, 'orderFixed',    'aaSortingFixed' );
	_fnCompatMap( init, 'paging',        'bPaginate' );
	_fnCompatMap( init, 'pagingType',    'sPaginationType' );
	_fnCompatMap( init, 'pageLength',    'iDisplayLength' );
	_fnCompatMap( init, 'searching',     'bFilter' );

	// Boolean initialisation of x-scrolling
	if ( typeof init.sScrollX === 'boolean' ) {
		init.sScrollX = init.sScrollX ? '100%' : '';
	}
	if ( typeof init.scrollX === 'boolean' ) {
		init.scrollX = init.scrollX ? '100%' : '';
	}

	// Column search objects are in an array, so it needs to be converted
	// element by element
	var searchCols = init.aoSearchCols;

	if ( searchCols ) {
		for ( var i=0, ien=searchCols.length ; i<ien ; i++ ) {
			if ( searchCols[i] ) {
				_fnCamelToHungarian( DataTable.models.oSearch, searchCols[i] );
			}
		}
	}

	// Enable search delay if server-side processing is enabled
	if (init.serverSide && ! init.searchDelay) {
		init.searchDelay = 400;
	}
}


/**
 * Provide backwards compatibility for column options. Note that the new options
 * are mapped onto the old parameters, so this is an external interface change
 * only.
 *  @param {object} init Object to map
 */
function _fnCompatCols ( init )
{
	_fnCompatMap( init, 'orderable',     'bSortable' );
	_fnCompatMap( init, 'orderData',     'aDataSort' );
	_fnCompatMap( init, 'orderSequence', 'asSorting' );
	_fnCompatMap( init, 'orderDataType', 'sortDataType' );

	// orderData can be given as an integer
	var dataSort = init.aDataSort;
	if ( typeof dataSort === 'number' && ! Array.isArray( dataSort ) ) {
		init.aDataSort = [ dataSort ];
	}
}


/**
 * Browser feature detection for capabilities, quirks
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnBrowserDetect( settings )
{
	// We don't need to do this every time DataTables is constructed, the values
	// calculated are specific to the browser and OS configuration which we
	// don't expect to change between initialisations
	if ( ! DataTable.__browser ) {
		var browser = {};
		DataTable.__browser = browser;

		// Scrolling feature / quirks detection
		var n = $('<div/>')
			.css( {
				position: 'fixed',
				top: 0,
				left: -1 * window.pageXOffset, // allow for scrolling
				height: 1,
				width: 1,
				overflow: 'hidden'
			} )
			.append(
				$('<div/>')
					.css( {
						position: 'absolute',
						top: 1,
						left: 1,
						width: 100,
						overflow: 'scroll'
					} )
					.append(
						$('<div/>')
							.css( {
								width: '100%',
								height: 10
							} )
					)
			)
			.appendTo( 'body' );

		var outer = n.children();
		var inner = outer.children();

		// Get scrollbar width
		browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;

		// In rtl text layout, some browsers (most, but not all) will place the
		// scrollbar on the left, rather than the right.
		browser.bScrollbarLeft = Math.round( inner.offset().left ) !== 1;

		n.remove();
	}

	$.extend( settings.oBrowser, DataTable.__browser );
	settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
}

/**
 * Add a column to the list used for the table with default values
 *  @param {object} oSettings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnAddColumn( oSettings )
{
	// Add column to aoColumns array
	var oDefaults = DataTable.defaults.column;
	var iCol = oSettings.aoColumns.length;
	var oCol = $.extend( {}, DataTable.models.oColumn, oDefaults, {
		"aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
		"mData": oDefaults.mData ? oDefaults.mData : iCol,
		idx: iCol,
		searchFixed: {},
		colEl: $('<col>').attr('data-dt-column', iCol)
	} );
	oSettings.aoColumns.push( oCol );

	// Add search object for column specific search. Note that the `searchCols[ iCol ]`
	// passed into extend can be undefined. This allows the user to give a default
	// with only some of the parameters defined, and also not give a default
	var searchCols = oSettings.aoPreSearchCols;
	searchCols[ iCol ] = $.extend( {}, DataTable.models.oSearch, searchCols[ iCol ] );
}


/**
 * Apply options for a column
 *  @param {object} oSettings dataTables settings object
 *  @param {int} iCol column index to consider
 *  @param {object} oOptions object with sType, bVisible and bSearchable etc
 *  @memberof DataTable#oApi
 */
function _fnColumnOptions( oSettings, iCol, oOptions )
{
	var oCol = oSettings.aoColumns[ iCol ];

	/* User specified column options */
	if ( oOptions !== undefined && oOptions !== null )
	{
		// Backwards compatibility
		_fnCompatCols( oOptions );

		// Map camel case parameters to their Hungarian counterparts
		_fnCamelToHungarian( DataTable.defaults.column, oOptions, true );

		/* Backwards compatibility for mDataProp */
		if ( oOptions.mDataProp !== undefined && !oOptions.mData )
		{
			oOptions.mData = oOptions.mDataProp;
		}

		if ( oOptions.sType )
		{
			oCol._sManualType = oOptions.sType;
		}
	
		// `class` is a reserved word in Javascript, so we need to provide
		// the ability to use a valid name for the camel case input
		if ( oOptions.className && ! oOptions.sClass )
		{
			oOptions.sClass = oOptions.className;
		}

		var origClass = oCol.sClass;

		$.extend( oCol, oOptions );
		_fnMap( oCol, oOptions, "sWidth", "sWidthOrig" );

		// Merge class from previously defined classes with this one, rather than just
		// overwriting it in the extend above
		if (origClass !== oCol.sClass) {
			oCol.sClass = origClass + ' ' + oCol.sClass;
		}

		/* iDataSort to be applied (backwards compatibility), but aDataSort will take
		 * priority if defined
		 */
		if ( oOptions.iDataSort !== undefined )
		{
			oCol.aDataSort = [ oOptions.iDataSort ];
		}
		_fnMap( oCol, oOptions, "aDataSort" );
	}

	/* Cache the data get and set functions for speed */
	var mDataSrc = oCol.mData;
	var mData = _fnGetObjectDataFn( mDataSrc );

	// The `render` option can be given as an array to access the helper rendering methods.
	// The first element is the rendering method to use, the rest are the parameters to pass
	if ( oCol.mRender && Array.isArray( oCol.mRender ) ) {
		var copy = oCol.mRender.slice();
		var name = copy.shift();

		oCol.mRender = DataTable.render[name].apply(window, copy);
	}

	oCol._render = oCol.mRender ? _fnGetObjectDataFn( oCol.mRender ) : null;

	var attrTest = function( src ) {
		return typeof src === 'string' && src.indexOf('@') !== -1;
	};
	oCol._bAttrSrc = $.isPlainObject( mDataSrc ) && (
		attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)
	);
	oCol._setter = null;

	oCol.fnGetData = function (rowData, type, meta) {
		var innerData = mData( rowData, type, undefined, meta );

		return oCol._render && type ?
			oCol._render( innerData, type, rowData, meta ) :
			innerData;
	};
	oCol.fnSetData = function ( rowData, val, meta ) {
		return _fnSetObjectDataFn( mDataSrc )( rowData, val, meta );
	};

	// Indicate if DataTables should read DOM data as an object or array
	// Used in _fnGetRowElements
	if ( typeof mDataSrc !== 'number' && ! oCol._isArrayHost ) {
		oSettings._rowReadObject = true;
	}

	/* Feature sorting overrides column specific when off */
	if ( !oSettings.oFeatures.bSort )
	{
		oCol.bSortable = false;
	}
}


/**
 * Adjust the table column widths for new data. Note: you would probably want to
 * do a redraw after calling this function!
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnAdjustColumnSizing ( settings )
{
	_fnCalculateColumnWidths( settings );
	_fnColumnSizes( settings );

	var scroll = settings.oScroll;
	if ( scroll.sY !== '' || scroll.sX !== '') {
		_fnScrollDraw( settings );
	}

	_fnCallbackFire( settings, null, 'column-sizing', [settings] );
}

/**
 * Apply column sizes
 *
 * @param {*} settings DataTables settings object
 */
function _fnColumnSizes ( settings )
{
	var cols = settings.aoColumns;

	for (var i=0 ; i<cols.length ; i++) {
		var width = _fnColumnsSumWidth(settings, [i], false, false);

		cols[i].colEl.css('width', width);
	}
}


/**
 * Convert the index of a visible column to the index in the data array (take account
 * of hidden columns)
 *  @param {object} oSettings dataTables settings object
 *  @param {int} iMatch Visible column index to lookup
 *  @returns {int} i the data index
 *  @memberof DataTable#oApi
 */
function _fnVisibleToColumnIndex( oSettings, iMatch )
{
	var aiVis = _fnGetColumns( oSettings, 'bVisible' );

	return typeof aiVis[iMatch] === 'number' ?
		aiVis[iMatch] :
		null;
}


/**
 * Convert the index of an index in the data array and convert it to the visible
 *   column index (take account of hidden columns)
 *  @param {int} iMatch Column index to lookup
 *  @param {object} oSettings dataTables settings object
 *  @returns {int} i the data index
 *  @memberof DataTable#oApi
 */
function _fnColumnIndexToVisible( oSettings, iMatch )
{
	var aiVis = _fnGetColumns( oSettings, 'bVisible' );
	var iPos = aiVis.indexOf(iMatch);

	return iPos !== -1 ? iPos : null;
}


/**
 * Get the number of visible columns
 *  @param {object} oSettings dataTables settings object
 *  @returns {int} i the number of visible columns
 *  @memberof DataTable#oApi
 */
function _fnVisbleColumns( settings )
{
	var layout = settings.aoHeader;
	var columns = settings.aoColumns;
	var vis = 0;

	if ( layout.length ) {
		for ( var i=0, ien=layout[0].length ; i<ien ; i++ ) {
			if ( columns[i].bVisible && $(layout[0][i].cell).css('display') !== 'none' ) {
				vis++;
			}
		}
	}

	return vis;
}


/**
 * Get an array of column indexes that match a given property
 *  @param {object} oSettings dataTables settings object
 *  @param {string} sParam Parameter in aoColumns to look for - typically
 *    bVisible or bSearchable
 *  @returns {array} Array of indexes with matched properties
 *  @memberof DataTable#oApi
 */
function _fnGetColumns( oSettings, sParam )
{
	var a = [];

	oSettings.aoColumns.map( function(val, i) {
		if ( val[sParam] ) {
			a.push( i );
		}
	} );

	return a;
}


/**
 * Calculate the 'type' of a column
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnColumnTypes ( settings )
{
	var columns = settings.aoColumns;
	var data = settings.aoData;
	var types = DataTable.ext.type.detect;
	var i, ien, j, jen, k, ken;
	var col, detectedType, cache;

	// For each column, spin over the 
	for ( i=0, ien=columns.length ; i<ien ; i++ ) {
		col = columns[i];
		cache = [];

		if ( ! col.sType && col._sManualType ) {
			col.sType = col._sManualType;
		}
		else if ( ! col.sType ) {
			for ( j=0, jen=types.length ; j<jen ; j++ ) {
				for ( k=0, ken=data.length ; k<ken ; k++ ) {

					if (! data[k]) {
						continue;
					}

					// Use a cache array so we only need to get the type data
					// from the formatter once (when using multiple detectors)
					if ( cache[k] === undefined ) {
						cache[k] = _fnGetCellData( settings, k, i, 'type' );
					}

					detectedType = types[j]( cache[k], settings );

					// If null, then this type can't apply to this column, so
					// rather than testing all cells, break out. There is an
					// exception for the last type which is `html`. We need to
					// scan all rows since it is possible to mix string and HTML
					// types
					if ( ! detectedType && j !== types.length-2 ) {
						break;
					}

					// Only a single match is needed for html type since it is
					// bottom of the pile and very similar to string - but it
					// must not be empty
					if ( detectedType === 'html' && ! _empty(cache[k]) ) {
						break;
					}
				}

				// Type is valid for all data points in the column - use this
				// type
				if ( detectedType ) {
					col.sType = detectedType;
					break;
				}
			}

			// Fall back - if no type was detected, always use string
			if ( ! col.sType ) {
				col.sType = 'string';
			}
		}

		// Set class names for header / footer for auto type classes
		var autoClass = _ext.type.className[col.sType];

		if (autoClass) {
			_columnAutoClass(settings.aoHeader, i, autoClass);
			_columnAutoClass(settings.aoFooter, i, autoClass);
		}

		var renderer = _ext.type.render[col.sType];

		// This can only happen once! There is no way to remover
		// a renderer. After the first time the renderer has
		// already been set so createTr will run the renderer itself.
		if (renderer && ! col._render) {
			col._render = DataTable.util.get(renderer);

			_columnAutoRender(settings, i);
		}
	}
}

/**
 * Apply an auto detected renderer to data which doesn't yet have
 * a renderer
 */
function _columnAutoRender(settings, colIdx) {
	var data = settings.aoData;

	for (var i=0 ; i<data.length ; i++) {
		if (data[i].nTr) {
			// We have to update the display here since there is no
			// invalidation check for the data
			var display = _fnGetCellData( settings, i, colIdx, 'display' );

			data[i].displayData[colIdx] = display;
			_fnWriteCell(data[i].anCells[colIdx], display);

			// No need to update sort / filter data since it has
			// been invalidated and will be re-read with the
			// renderer now applied
		}
	}
}

/**
 * Apply a class name to a column's header cells
 */
function _columnAutoClass(container, colIdx, className) {
	container.forEach(function (row) {
		if (row[colIdx] && row[colIdx].unique) {
			_addClass(row[colIdx].cell, className);
		}
	});
}

/**
 * Take the column definitions and static columns arrays and calculate how
 * they relate to column indexes. The callback function will then apply the
 * definition found for a column to a suitable configuration object.
 *  @param {object} oSettings dataTables settings object
 *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
 *  @param {array} aoCols The aoColumns array that defines columns individually
 *  @param {array} headerLayout Layout for header as it was loaded
 *  @param {function} fn Callback function - takes two parameters, the calculated
 *    column index and the definition for that column.
 *  @memberof DataTable#oApi
 */
function _fnApplyColumnDefs( oSettings, aoColDefs, aoCols, headerLayout, fn )
{
	var i, iLen, j, jLen, k, kLen, def;
	var columns = oSettings.aoColumns;

	if ( aoCols ) {
		for ( i=0, iLen=aoCols.length ; i<iLen ; i++ ) {
			if (aoCols[i] && aoCols[i].name) {
				columns[i].sName = aoCols[i].name;
			}
		}
	}

	// Column definitions with aTargets
	if ( aoColDefs )
	{
		/* Loop over the definitions array - loop in reverse so first instance has priority */
		for ( i=aoColDefs.length-1 ; i>=0 ; i-- )
		{
			def = aoColDefs[i];

			/* Each definition can target multiple columns, as it is an array */
			var aTargets = def.target !== undefined
				? def.target
				: def.targets !== undefined
					? def.targets
					: def.aTargets;

			if ( ! Array.isArray( aTargets ) )
			{
				aTargets = [ aTargets ];
			}

			for ( j=0, jLen=aTargets.length ; j<jLen ; j++ )
			{
				var target = aTargets[j];

				if ( typeof target === 'number' && target >= 0 )
				{
					/* Add columns that we don't yet know about */
					while( columns.length <= target )
					{
						_fnAddColumn( oSettings );
					}

					/* Integer, basic index */
					fn( target, def );
				}
				else if ( typeof target === 'number' && target < 0 )
				{
					/* Negative integer, right to left column counting */
					fn( columns.length+target, def );
				}
				else if ( typeof target === 'string' )
				{
					for ( k=0, kLen=columns.length ; k<kLen ; k++ ) {
						if (target === '_all') {
							// Apply to all columns
							fn( k, def );
						}
						else if (target.indexOf(':name') !== -1) {
							// Column selector
							if (columns[k].sName === target.replace(':name', '')) {
								fn( k, def );
							}
						}
						else {
							// Cell selector
							headerLayout.forEach(function (row) {
								if (row[k]) {
									var cell = $(row[k].cell);

									// Legacy support. Note that it means that we don't support
									// an element name selector only, since they are treated as
									// class names for 1.x compat.
									if (target.match(/^[a-z][\w-]*$/i)) {
										target = '.' + target;
									}

									if (cell.is( target )) {
										fn( k, def );
									}
								}
							});
						}
					}
				}
			}
		}
	}

	// Statically defined columns array
	if ( aoCols ) {
		for ( i=0, iLen=aoCols.length ; i<iLen ; i++ ) {
			fn( i, aoCols[i] );
		}
	}
}


/**
 * Get the width for a given set of columns
 *
 * @param {*} settings DataTables settings object
 * @param {*} targets Columns - comma separated string or array of numbers
 * @param {*} original Use the original width (true) or calculated (false)
 * @param {*} incVisible Include visible columns (true) or not (false)
 * @returns Combined CSS value
 */
function _fnColumnsSumWidth( settings, targets, original, incVisible ) {
	if ( ! Array.isArray( targets ) ) {
		targets = _fnColumnsFromHeader( targets );
	}

	var sum = 0;
	var unit;
	var columns = settings.aoColumns;
	
	for ( var i=0, ien=targets.length ; i<ien ; i++ ) {
		var column = columns[ targets[i] ];
		var definedWidth = original ?
			column.sWidthOrig :
			column.sWidth;

		if ( ! incVisible && column.bVisible === false ) {
			continue;
		}

		if ( definedWidth === null || definedWidth === undefined ) {
			return null; // can't determine a defined width - browser defined
		}
		else if ( typeof definedWidth === 'number' ) {
			unit = 'px';
			sum += definedWidth;
		}
		else {
			var matched = definedWidth.match(/([\d\.]+)([^\d]*)/);

			if ( matched ) {
				sum += matched[1] * 1;
				unit = matched.length === 3 ?
					matched[2] :
					'px';
			}
		}
	}

	return sum + unit;
}

function _fnColumnsFromHeader( cell )
{
	var attr = $(cell).closest('[data-dt-column]').attr('data-dt-column');

	if ( ! attr ) {
		return [];
	}

	return attr.split(',').map( function (val) {
		return val * 1;
	} );
}
/**
 * Add a data array to the table, creating DOM node etc. This is the parallel to
 * _fnGatherData, but for adding rows from a Javascript source, rather than a
 * DOM source.
 *  @param {object} settings dataTables settings object
 *  @param {array} data data array to be added
 *  @param {node} [tr] TR element to add to the table - optional. If not given,
 *    DataTables will create a row automatically
 *  @param {array} [tds] Array of TD|TH elements for the row - must be given
 *    if nTr is.
 *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
 *  @memberof DataTable#oApi
 */
function _fnAddData ( settings, dataIn, tr, tds )
{
	/* Create the object for storing information about this new row */
	var rowIdx = settings.aoData.length;
	var rowModel = $.extend( true, {}, DataTable.models.oRow, {
		src: tr ? 'dom' : 'data',
		idx: rowIdx
	} );

	rowModel._aData = dataIn;
	settings.aoData.push( rowModel );

	var columns = settings.aoColumns;

	for ( var i=0, iLen=columns.length ; i<iLen ; i++ )
	{
		// Invalidate the column types as the new data needs to be revalidated
		columns[i].sType = null;
	}

	/* Add to the display array */
	settings.aiDisplayMaster.push( rowIdx );

	var id = settings.rowIdFn( dataIn );
	if ( id !== undefined ) {
		settings.aIds[ id ] = rowModel;
	}

	/* Create the DOM information, or register it if already present */
	if ( tr || ! settings.oFeatures.bDeferRender )
	{
		_fnCreateTr( settings, rowIdx, tr, tds );
	}

	return rowIdx;
}


/**
 * Add one or more TR elements to the table. Generally we'd expect to
 * use this for reading data from a DOM sourced table, but it could be
 * used for an TR element. Note that if a TR is given, it is used (i.e.
 * it is not cloned).
 *  @param {object} settings dataTables settings object
 *  @param {array|node|jQuery} trs The TR element(s) to add to the table
 *  @returns {array} Array of indexes for the added rows
 *  @memberof DataTable#oApi
 */
function _fnAddTr( settings, trs )
{
	var row;

	// Allow an individual node to be passed in
	if ( ! (trs instanceof $) ) {
		trs = $(trs);
	}

	return trs.map( function (i, el) {
		row = _fnGetRowElements( settings, el );
		return _fnAddData( settings, row.data, el, row.cells );
	} );
}


/**
 * Get the data for a given cell from the internal cache, taking into account data mapping
 *  @param {object} settings dataTables settings object
 *  @param {int} rowIdx aoData row id
 *  @param {int} colIdx Column index
 *  @param {string} type data get type ('display', 'type' 'filter|search' 'sort|order')
 *  @returns {*} Cell data
 *  @memberof DataTable#oApi
 */
function _fnGetCellData( settings, rowIdx, colIdx, type )
{
	if (type === 'search') {
		type = 'filter';
	}
	else if (type === 'order') {
		type = 'sort';
	}

	var row = settings.aoData[rowIdx];

	if (! row) {
		return undefined;
	}

	var draw           = settings.iDraw;
	var col            = settings.aoColumns[colIdx];
	var rowData        = row._aData;
	var defaultContent = col.sDefaultContent;
	var cellData       = col.fnGetData( rowData, type, {
		settings: settings,
		row:      rowIdx,
		col:      colIdx
	} );

	// Allow for a node being returned for non-display types
	if (type !== 'display' && cellData && typeof cellData === 'object' && cellData.nodeName) {
		cellData = cellData.innerHTML;
	}

	if ( cellData === undefined ) {
		if ( settings.iDrawError != draw && defaultContent === null ) {
			_fnLog( settings, 0, "Requested unknown parameter "+
				(typeof col.mData=='function' ? '{function}' : "'"+col.mData+"'")+
				" for row "+rowIdx+", column "+colIdx, 4 );
			settings.iDrawError = draw;
		}
		return defaultContent;
	}

	// When the data source is null and a specific data type is requested (i.e.
	// not the original data), we can use default column data
	if ( (cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined ) {
		cellData = defaultContent;
	}
	else if ( typeof cellData === 'function' ) {
		// If the data source is a function, then we run it and use the return,
		// executing in the scope of the data object (for instances)
		return cellData.call( rowData );
	}

	if ( cellData === null && type === 'display' ) {
		return '';
	}

	if ( type === 'filter' ) {
		var fomatters = DataTable.ext.type.search;

		if ( fomatters[ col.sType ] ) {
			cellData = fomatters[ col.sType ]( cellData );
		}
	}

	return cellData;
}


/**
 * Set the value for a specific cell, into the internal data cache
 *  @param {object} settings dataTables settings object
 *  @param {int} rowIdx aoData row id
 *  @param {int} colIdx Column index
 *  @param {*} val Value to set
 *  @memberof DataTable#oApi
 */
function _fnSetCellData( settings, rowIdx, colIdx, val )
{
	var col     = settings.aoColumns[colIdx];
	var rowData = settings.aoData[rowIdx]._aData;

	col.fnSetData( rowData, val, {
		settings: settings,
		row:      rowIdx,
		col:      colIdx
	}  );
}

/**
 * Write a value to a cell
 * @param {*} td Cell
 * @param {*} val Value
 */
function _fnWriteCell(td, val)
{
	if (val && typeof val === 'object' && val.nodeName) {
		$(td)
			.empty()
			.append(val);
	}
	else {
		td.innerHTML = val;
	}
}


// Private variable that is used to match action syntax in the data property object
var __reArray = /\[.*?\]$/;
var __reFn = /\(\)$/;

/**
 * Split string on periods, taking into account escaped periods
 * @param  {string} str String to split
 * @return {array} Split string
 */
function _fnSplitObjNotation( str )
{
	var parts = str.match(/(\\.|[^.])+/g) || [''];

	return parts.map( function ( s ) {
		return s.replace(/\\\./g, '.');
	} );
}


/**
 * Return a function that can be used to get data from a source object, taking
 * into account the ability to use nested objects as a source
 *  @param {string|int|function} mSource The data source for the object
 *  @returns {function} Data get function
 *  @memberof DataTable#oApi
 */
var _fnGetObjectDataFn = DataTable.util.get;


/**
 * Return a function that can be used to set data from a source object, taking
 * into account the ability to use nested objects as a source
 *  @param {string|int|function} mSource The data source for the object
 *  @returns {function} Data set function
 *  @memberof DataTable#oApi
 */
var _fnSetObjectDataFn = DataTable.util.set;


/**
 * Return an array with the full table data
 *  @param {object} oSettings dataTables settings object
 *  @returns array {array} aData Master data array
 *  @memberof DataTable#oApi
 */
function _fnGetDataMaster ( settings )
{
	return _pluck( settings.aoData, '_aData' );
}


/**
 * Nuke the table
 *  @param {object} oSettings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnClearTable( settings )
{
	settings.aoData.length = 0;
	settings.aiDisplayMaster.length = 0;
	settings.aiDisplay.length = 0;
	settings.aIds = {};
}


/**
 * Mark cached data as invalid such that a re-read of the data will occur when
 * the cached data is next requested. Also update from the data source object.
 *
 * @param {object} settings DataTables settings object
 * @param {int}    rowIdx   Row index to invalidate
 * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
 *     or 'data'
 * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
 *     row will be invalidated
 * @memberof DataTable#oApi
 *
 * @todo For the modularisation of v1.11 this will need to become a callback, so
 *   the sort and filter methods can subscribe to it. That will required
 *   initialisation options for sorting, which is why it is not already baked in
 */
function _fnInvalidate( settings, rowIdx, src, colIdx )
{
	var row = settings.aoData[ rowIdx ];
	var i, ien;

	// Remove the cached data for the row
	row._aSortData = null;
	row._aFilterData = null;
	row.displayData = null;

	// Are we reading last data from DOM or the data object?
	if ( src === 'dom' || ((! src || src === 'auto') && row.src === 'dom') ) {
		// Read the data from the DOM
		row._aData = _fnGetRowElements(
				settings, row, colIdx, colIdx === undefined ? undefined : row._aData
			)
			.data;
	}
	else {
		// Reading from data object, update the DOM
		var cells = row.anCells;
		var display = _fnGetRowDisplay(settings, rowIdx);

		if ( cells ) {
			if ( colIdx !== undefined ) {
				_fnWriteCell(cells[colIdx], display[colIdx]);
			}
			else {
				for ( i=0, ien=cells.length ; i<ien ; i++ ) {
					_fnWriteCell(cells[i], display[i]);
				}
			}
		}
	}

	// Column specific invalidation
	var cols = settings.aoColumns;
	if ( colIdx !== undefined ) {
		// Type - the data might have changed
		cols[ colIdx ].sType = null;

		// Max length string. Its a fairly cheep recalculation, so not worth
		// something more complicated
		cols[ colIdx ].maxLenString = null;
	}
	else {
		for ( i=0, ien=cols.length ; i<ien ; i++ ) {
			cols[i].sType = null;
			cols[i].maxLenString = null;
		}

		// Update DataTables special `DT_*` attributes for the row
		_fnRowAttributes( settings, row );
	}
}


/**
 * Build a data source object from an HTML row, reading the contents of the
 * cells that are in the row.
 *
 * @param {object} settings DataTables settings object
 * @param {node|object} TR element from which to read data or existing row
 *   object from which to re-read the data from the cells
 * @param {int} [colIdx] Optional column index
 * @param {array|object} [d] Data source object. If `colIdx` is given then this
 *   parameter should also be given and will be used to write the data into.
 *   Only the column in question will be written
 * @returns {object} Object with two parameters: `data` the data read, in
 *   document order, and `cells` and array of nodes (they can be useful to the
 *   caller, so rather than needing a second traversal to get them, just return
 *   them from here).
 * @memberof DataTable#oApi
 */
function _fnGetRowElements( settings, row, colIdx, d )
{
	var
		tds = [],
		td = row.firstChild,
		name, col, i=0, contents,
		columns = settings.aoColumns,
		objectRead = settings._rowReadObject;

	// Allow the data object to be passed in, or construct
	d = d !== undefined ?
		d :
		objectRead ?
			{} :
			[];

	var attr = function ( str, td  ) {
		if ( typeof str === 'string' ) {
			var idx = str.indexOf('@');

			if ( idx !== -1 ) {
				var attr = str.substring( idx+1 );
				var setter = _fnSetObjectDataFn( str );
				setter( d, td.getAttribute( attr ) );
			}
		}
	};

	// Read data from a cell and store into the data object
	var cellProcess = function ( cell ) {
		if ( colIdx === undefined || colIdx === i ) {
			col = columns[i];
			contents = (cell.innerHTML).trim();

			if ( col && col._bAttrSrc ) {
				var setter = _fnSetObjectDataFn( col.mData._ );
				setter( d, contents );

				attr( col.mData.sort, cell );
				attr( col.mData.type, cell );
				attr( col.mData.filter, cell );
			}
			else {
				// Depending on the `data` option for the columns the data can
				// be read to either an object or an array.
				if ( objectRead ) {
					if ( ! col._setter ) {
						// Cache the setter function
						col._setter = _fnSetObjectDataFn( col.mData );
					}
					col._setter( d, contents );
				}
				else {
					d[i] = contents;
				}
			}
		}

		i++;
	};

	if ( td ) {
		// `tr` element was passed in
		while ( td ) {
			name = td.nodeName.toUpperCase();

			if ( name == "TD" || name == "TH" ) {
				cellProcess( td );
				tds.push( td );
			}

			td = td.nextSibling;
		}
	}
	else {
		// Existing row object passed in
		tds = row.anCells;

		for ( var j=0, jen=tds.length ; j<jen ; j++ ) {
			cellProcess( tds[j] );
		}
	}

	// Read the ID from the DOM if present
	var rowNode = row.firstChild ? row : row.nTr;

	if ( rowNode ) {
		var id = rowNode.getAttribute( 'id' );

		if ( id ) {
			_fnSetObjectDataFn( settings.rowId )( d, id );
		}
	}

	return {
		data: d,
		cells: tds
	};
}

/**
 * Render and cache a row's display data for the columns, if required
 * @returns 
 */
function _fnGetRowDisplay (settings, rowIdx) {
	let rowModal = settings.aoData[rowIdx];
	let columns = settings.aoColumns;

	if (! rowModal.displayData) {
		// Need to render and cache
		rowModal.displayData = [];
	
		for ( var colIdx=0, len=columns.length ; colIdx<len ; colIdx++ ) {
			rowModal.displayData.push(
				_fnGetCellData( settings, rowIdx, colIdx, 'display' )
			);
		}
	}

	return rowModal.displayData;
}

/**
 * Create a new TR element (and it's TD children) for a row
 *  @param {object} oSettings dataTables settings object
 *  @param {int} iRow Row to consider
 *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
 *    DataTables will create a row automatically
 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
 *    if nTr is.
 *  @memberof DataTable#oApi
 */
function _fnCreateTr ( oSettings, iRow, nTrIn, anTds )
{
	var
		row = oSettings.aoData[iRow],
		rowData = row._aData,
		cells = [],
		nTr, nTd, oCol,
		i, iLen, create,
		trClass = oSettings.oClasses.tbody.row;

	if ( row.nTr === null )
	{
		nTr = nTrIn || document.createElement('tr');

		row.nTr = nTr;
		row.anCells = cells;

		_addClass(nTr, trClass);

		/* Use a private property on the node to allow reserve mapping from the node
		 * to the aoData array for fast look up
		 */
		nTr._DT_RowIndex = iRow;

		/* Special parameters can be given by the data source to be used on the row */
		_fnRowAttributes( oSettings, row );

		/* Process each column */
		for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
		{
			oCol = oSettings.aoColumns[i];
			create = nTrIn && anTds[i] ? false : true;

			nTd = create ? document.createElement( oCol.sCellType ) : anTds[i];

			if (! nTd) {
				_fnLog( oSettings, 0, 'Incorrect column count', 18 );
			}

			nTd._DT_CellIndex = {
				row: iRow,
				column: i
			};
			
			cells.push( nTd );
			
			var display = _fnGetRowDisplay(oSettings, iRow);

			// Need to create the HTML if new, or if a rendering function is defined
			if (
				create ||
				(
					(oCol.mRender || oCol.mData !== i) &&
					(!$.isPlainObject(oCol.mData) || oCol.mData._ !== i+'.display')
				)
			) {
				_fnWriteCell(nTd, display[i]);
			}

			// Visibility - add or remove as required
			if ( oCol.bVisible && create )
			{
				nTr.appendChild( nTd );
			}
			else if ( ! oCol.bVisible && ! create )
			{
				nTd.parentNode.removeChild( nTd );
			}

			if ( oCol.fnCreatedCell )
			{
				oCol.fnCreatedCell.call( oSettings.oInstance,
					nTd, _fnGetCellData( oSettings, iRow, i ), rowData, iRow, i
				);
			}
		}

		_fnCallbackFire( oSettings, 'aoRowCreatedCallback', 'row-created', [nTr, rowData, iRow, cells] );
	}
	else {
		_addClass(row.nTr, trClass);
	}
}


/**
 * Add attributes to a row based on the special `DT_*` parameters in a data
 * source object.
 *  @param {object} settings DataTables settings object
 *  @param {object} DataTables row object for the row to be modified
 *  @memberof DataTable#oApi
 */
function _fnRowAttributes( settings, row )
{
	var tr = row.nTr;
	var data = row._aData;

	if ( tr ) {
		var id = settings.rowIdFn( data );

		if ( id ) {
			tr.id = id;
		}

		if ( data.DT_RowClass ) {
			// Remove any classes added by DT_RowClass before
			var a = data.DT_RowClass.split(' ');
			row.__rowc = row.__rowc ?
				_unique( row.__rowc.concat( a ) ) :
				a;

			$(tr)
				.removeClass( row.__rowc.join(' ') )
				.addClass( data.DT_RowClass );
		}

		if ( data.DT_RowAttr ) {
			$(tr).attr( data.DT_RowAttr );
		}

		if ( data.DT_RowData ) {
			$(tr).data( data.DT_RowData );
		}
	}
}


/**
 * Create the HTML header for the table
 *  @param {object} oSettings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnBuildHead( settings, side )
{
	var classes = settings.oClasses;
	var columns = settings.aoColumns;
	var i, ien, row;
	var target = side === 'header'
		? settings.nTHead
		: settings.nTFoot;
	var titleProp = side === 'header' ? 'sTitle' : side;

	// Footer might be defined
	if (! target) {
		return;
	}

	// If no cells yet and we have content for them, then create
	if (side === 'header' || _pluck(settings.aoColumns, titleProp).join('')) {
		row = $('tr', target);

		// Add a row if needed
		if (! row.length) {
			row = $('<tr/>').appendTo(target)
		}

		// Add the number of cells needed to make up to the number of columns
		if (row.length === 1) {
			var cells = $('td, th', row);

			for ( i=cells.length, ien=columns.length ; i<ien ; i++ ) {
				$('<th/>')
					.html( columns[i][titleProp] || '' )
					.appendTo( row );
			}
		}
	}

	var detected = _fnDetectHeader( settings, target, true );

	if (side === 'header') {
		settings.aoHeader = detected;
	}
	else {
		settings.aoFooter = detected;
	}

	// ARIA role for the rows
	$(target).children('tr').attr('role', 'row');

	// Every cell needs to be passed through the renderer
	$(target).children('tr').children('th, td')
		.each( function () {
			_fnRenderer( settings, side )(
				settings, $(this), classes
			);
		} );
}

/**
 * Build a layout structure for a header or footer
 *
 * @param {*} settings DataTables settings
 * @param {*} source Source layout array
 * @param {*} incColumns What columns should be included
 * @returns Layout array
 */
function _fnHeaderLayout( settings, source, incColumns )
{
	var row, column, cell;
	var local = [];
	var structure = [];
	var columns = settings.aoColumns;
	var columnCount = columns.length;
	var rowspan, colspan;

	if ( ! source ) {
		return;
	}

	// Default is to work on only visible columns
	if ( ! incColumns ) {
		incColumns = _range(columnCount)
			.filter(function (idx) {
				return columns[idx].bVisible;
			});
	}

	// Make a copy of the master layout array, but with only the columns we want
	for ( row=0 ; row<source.length ; row++ ) {
		// Remove any columns we haven't selected
		local[row] = source[row].slice().filter(function (cell, i) {
			return incColumns.includes(i);
		});

		// Prep the structure array - it needs an element for each row
		structure.push( [] );
	}

	for ( row=0 ; row<local.length ; row++ ) {
		for ( column=0 ; column<local[row].length ; column++ ) {
			rowspan = 1;
			colspan = 1;

			// Check to see if there is already a cell (row/colspan) covering our target
			// insert point. If there is, then there is nothing to do.
			if ( structure[row][column] === undefined ) {
				cell = local[row][column].cell;

				// Expand for rowspan
				while (
					local[row+rowspan] !== undefined &&
					local[row][column].cell == local[row+rowspan][column].cell
				) {
					structure[row+rowspan][column] = null;
					rowspan++;
				}

				// And for colspan
				while (
					local[row][column+colspan] !== undefined &&
					local[row][column].cell == local[row][column+colspan].cell
				) {
					// Which also needs to go over rows
					for ( var k=0 ; k<rowspan ; k++ ) {
						structure[row+k][column+colspan] = null;
					}

					colspan++;
				}

				var titleSpan = $('span.dt-column-title', cell);

				structure[row][column] = {
					cell: cell,
					colspan: colspan,
					rowspan: rowspan,
					title: titleSpan.length
						? titleSpan.html()
						: $(cell).html()
				};
			}
		}
	}

	return structure;
}


/**
 * Draw the header (or footer) element based on the column visibility states.
 *
 *  @param object oSettings dataTables settings object
 *  @param array aoSource Layout array from _fnDetectHeader
 *  @memberof DataTable#oApi
 */
function _fnDrawHead( settings, source )
{
	var layout = _fnHeaderLayout(settings, source);
	var tr, n;

	for ( var row=0 ; row<source.length ; row++ ) {
		tr = source[row].row;

		// All cells are going to be replaced, so empty out the row
		// Can't use $().empty() as that kills event handlers
		if (tr) {
			while( (n = tr.firstChild) ) {
				tr.removeChild( n );
			}
		}

		for ( var column=0 ; column<layout[row].length ; column++ ) {
			var point = layout[row][column];

			if (point) {
				$(point.cell)
					.appendTo(tr)
					.attr('rowspan', point.rowspan)
					.attr('colspan', point.colspan);
			}
		}
	}
}


/**
 * Insert the required TR nodes into the table for display
 *  @param {object} oSettings dataTables settings object
 *  @param ajaxComplete true after ajax call to complete rendering
 *  @memberof DataTable#oApi
 */
function _fnDraw( oSettings, ajaxComplete )
{
	// Allow for state saving and a custom start position
	_fnStart( oSettings );

	/* Provide a pre-callback function which can be used to cancel the draw is false is returned */
	var aPreDraw = _fnCallbackFire( oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings] );
	if ( aPreDraw.indexOf(false) !== -1 )
	{
		_fnProcessingDisplay( oSettings, false );
		return;
	}

	var anRows = [];
	var iRowCount = 0;
	var bServerSide = _fnDataSource( oSettings ) == 'ssp';
	var aiDisplay = oSettings.aiDisplay;
	var iDisplayStart = oSettings._iDisplayStart;
	var iDisplayEnd = oSettings.fnDisplayEnd();
	var columns = oSettings.aoColumns;
	var body = $(oSettings.nTBody);

	oSettings.bDrawing = true;

	/* Server-side processing draw intercept */
	if ( !bServerSide )
	{
		oSettings.iDraw++;
	}
	else if ( !oSettings.bDestroying && !ajaxComplete)
	{
		// Show loading message for server-side processing
		if (oSettings.iDraw === 0) {
			body.empty().append(_emptyRow(oSettings));
		}

		_fnAjaxUpdate( oSettings );
		return;
	}

	if ( aiDisplay.length !== 0 )
	{
		var iStart = bServerSide ? 0 : iDisplayStart;
		var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;

		for ( var j=iStart ; j<iEnd ; j++ )
		{
			var iDataIndex = aiDisplay[j];
			var aoData = oSettings.aoData[ iDataIndex ];
			if ( aoData.nTr === null )
			{
				_fnCreateTr( oSettings, iDataIndex );
			}

			var nRow = aoData.nTr;

			// Add various classes as needed
			for (var i=0 ; i<columns.length ; i++) {
				var col = columns[i];
				var td = aoData.anCells[i];

				_addClass(td, _ext.type.className[col.sType]); // auto class
				_addClass(td, col.sClass); // column class
				_addClass(td, oSettings.oClasses.tbody.cell); // all cells
			}

			// Row callback functions - might want to manipulate the row
			// iRowCount and j are not currently documented. Are they at all
			// useful?
			_fnCallbackFire( oSettings, 'aoRowCallback', null,
				[nRow, aoData._aData, iRowCount, j, iDataIndex] );

			anRows.push( nRow );
			iRowCount++;
		}
	}
	else
	{
		anRows[ 0 ] = _emptyRow(oSettings);
	}

	/* Header and footer callbacks */
	_fnCallbackFire( oSettings, 'aoHeaderCallback', 'header', [ $(oSettings.nTHead).children('tr')[0],
		_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );

	_fnCallbackFire( oSettings, 'aoFooterCallback', 'footer', [ $(oSettings.nTFoot).children('tr')[0],
		_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );

	// replaceChildren is faster, but only became widespread in 2020,
	// so a fall back in jQuery is provided for older browsers.
	if (body[0].replaceChildren) {
		body[0].replaceChildren.apply(body[0], anRows);
	}
	else {
		body.children().detach();
		body.append( $(anRows) );
	}

	// Empty table needs a specific class
	$(oSettings.nTableWrapper).toggleClass('dt-empty-footer', $('tr', oSettings.nTFoot).length === 0);

	/* Call all required callback functions for the end of a draw */
	_fnCallbackFire( oSettings, 'aoDrawCallback', 'draw', [oSettings], true );

	/* Draw is complete, sorting and filtering must be as well */
	oSettings.bSorted = false;
	oSettings.bFiltered = false;
	oSettings.bDrawing = false;
}


/**
 * Redraw the table - taking account of the various features which are enabled
 *  @param {object} oSettings dataTables settings object
 *  @param {boolean} [holdPosition] Keep the current paging position. By default
 *    the paging is reset to the first page
 *  @memberof DataTable#oApi
 */
function _fnReDraw( settings, holdPosition, recompute )
{
	var
		features = settings.oFeatures,
		sort     = features.bSort,
		filter   = features.bFilter;

	if (recompute === undefined || recompute === true) {
		if ( sort ) {
			_fnSort( settings );
		}

		if ( filter ) {
			_fnFilterComplete( settings, settings.oPreviousSearch );
		}
		else {
			// No filtering, so we want to just use the display master
			settings.aiDisplay = settings.aiDisplayMaster.slice();
		}
	}

	if ( holdPosition !== true ) {
		settings._iDisplayStart = 0;
	}

	// Let any modules know about the draw hold position state (used by
	// scrolling internally)
	settings._drawHold = holdPosition;

	_fnDraw( settings );

	settings._drawHold = false;
}


/*
 * Table is empty - create a row with an empty message in it
 */
function _emptyRow ( settings ) {
	var oLang = settings.oLanguage;
	var zero = oLang.sZeroRecords;
	var dataSrc = _fnDataSource( settings );

	if (
		(settings.iDraw < 1 && dataSrc === 'ssp') ||
		(settings.iDraw <= 1 && dataSrc === 'ajax')
	) {
		zero = oLang.sLoadingRecords;
	}
	else if ( oLang.sEmptyTable && settings.fnRecordsTotal() === 0 )
	{
		zero = oLang.sEmptyTable;
	}

	return $( '<tr/>' )
		.append( $('<td />', {
			'colSpan': _fnVisbleColumns( settings ),
			'class':   settings.oClasses.empty.row
		} ).html( zero ) )[0];
}


/**
 * Convert a `layout` object given by a user to the object structure needed
 * for the renderer. This is done twice, once for above and once for below
 * the table. Ordering must also be considered.
 *
 * @param {*} settings DataTables settings object
 * @param {*} layout Layout object to convert
 * @param {string} side `top` or `bottom`
 * @returns Converted array structure - one item for each row.
 */
function _layoutArray ( settings, layout, side )
{
	var groups = {};

	// Combine into like groups (e.g. `top`, `top2`, etc)
	$.each( layout, function ( pos, val ) {
		if (val === null) {
			return;
		}

		var splitPos = pos.replace(/([A-Z])/g, ' $1').split(' ');

		if ( ! groups[ splitPos[0] ] ) {
			groups[ splitPos[0] ] = {};
		}

		var align = splitPos.length === 1 ?
			'full' :
			splitPos[1].toLowerCase();
		var group = groups[ splitPos[0] ];
		var groupRun = function (contents, innerVal) {
			// If it is an object, then there can be multiple features contained in it
			if ( $.isPlainObject( innerVal ) ) {
				Object.keys(innerVal).map(function (key) {
					contents.push( {
						feature: key,
						opts: innerVal[key]
					});
				});
			}
			else {
				contents.push(innerVal);
			}
		}

		// Transform to an object with a contents property
		if (! group[align] || ! group[align].contents) {
			group[align] = { contents: [] };
		}

		// Allow for an array or just a single object
		if ( Array.isArray(val)) {
			for (var i=0 ; i<val.length ; i++) {
				groupRun(group[align].contents, val[i]);
			}
		}
		else {
			groupRun(group[ align ].contents, val);
		}

		// And make contents an array
		if ( ! Array.isArray( group[ align ].contents ) ) {
			group[ align ].contents = [ group[ align ].contents ];
		}
	} );

	var filtered = Object.keys(groups)
		.map( function ( pos ) {
			// Filter to only the side we need
			if ( pos.indexOf(side) !== 0 ) {
				return null;
			}

			return {
				name: pos,
				val: groups[pos]
			};
		} )
		.filter( function (item) {
			return item !== null;
		});

	// Order by item identifier
	filtered.sort( function ( a, b ) {
		var order1 = a.name.replace(/[^0-9]/g, '') * 1;
		var order2 = b.name.replace(/[^0-9]/g, '') * 1;

		return order2 - order1;
	} );
	
	if ( side === 'bottom' ) {
		filtered.reverse();
	}

	// Split into rows
	var rows = [];
	for ( var i=0, ien=filtered.length ; i<ien ; i++ ) {
		if (  filtered[i].val.full ) {
			rows.push( { full: filtered[i].val.full } );
			_layoutResolve( settings, rows[ rows.length - 1 ] );

			delete filtered[i].val.full;
		}

		if ( Object.keys(filtered[i].val).length ) {
			rows.push( filtered[i].val );
			_layoutResolve( settings, rows[ rows.length - 1 ] );
		}
	}

	return rows;
}


/**
 * Convert the contents of a row's layout object to nodes that can be inserted
 * into the document by a renderer. Execute functions, look up plug-ins, etc.
 *
 * @param {*} settings DataTables settings object
 * @param {*} row Layout object for this row
 */
function _layoutResolve( settings, row ) {
	var getFeature = function (feature, opts) {
		if ( ! _ext.features[ feature ] ) {
			_fnLog( settings, 0, 'Unknown feature: '+ feature );
		}

		return _ext.features[ feature ].apply( this, [settings, opts] );
	};

	var resolve = function ( item ) {
		var line = row[ item ].contents;

		for ( var i=0, ien=line.length ; i<ien ; i++ ) {
			if ( ! line[i] ) {
				continue;
			}
			else if ( typeof line[i] === 'string' ) {
				line[i] = getFeature( line[i], null );
			}
			else if ( $.isPlainObject(line[i]) ) {
				// If it's an object, it just has feature and opts properties from
				// the transform in _layoutArray
				line[i] = getFeature(line[i].feature, line[i].opts);
			}
			else if ( typeof line[i].node === 'function' ) {
				line[i] = line[i].node( settings );
			}
			else if ( typeof line[i] === 'function' ) {
				var inst = line[i]( settings );

				line[i] = typeof inst.node === 'function' ?
					inst.node() :
					inst;
			}
		}
	};

	$.each( row, function ( key ) {
		resolve( key );
	} );
}


/**
 * Add the options to the page HTML for the table
 *  @param {object} settings DataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnAddOptionsHtml ( settings )
{
	var classes = settings.oClasses;
	var table = $(settings.nTable);

	// Wrapper div around everything DataTables controls
	var insert = $('<div/>')
		.attr({
			id:      settings.sTableId+'_wrapper',
			'class': classes.container
		})
		.insertBefore(table);

	settings.nTableWrapper = insert[0];

	if (settings.sDom) {
		// Legacy
		_fnLayoutDom(settings, settings.sDom, insert);
	}
	else {
		var top = _layoutArray( settings, settings.layout, 'top' );
		var bottom = _layoutArray( settings, settings.layout, 'bottom' );
		var renderer = _fnRenderer( settings, 'layout' );
	
		// Everything above - the renderer will actually insert the contents into the document
		top.forEach(function (item) {
			renderer( settings, insert, item );
		});

		// The table - always the center of attention
		renderer( settings, insert, {
			full: {
				table: true,
				contents: [ _fnFeatureHtmlTable(settings) ]
			}
		} );

		// Everything below
		bottom.forEach(function (item) {
			renderer( settings, insert, item );
		});
	}

	// Processing floats on top, so it isn't an inserted feature
	_processingHtml( settings );
}

/**
 * Draw the table with the legacy DOM property
 * @param {*} settings DT settings object
 * @param {*} dom DOM string
 * @param {*} insert Insert point
 */
function _fnLayoutDom( settings, dom, insert )
{
	var parts = dom.match(/(".*?")|('.*?')|./g);
	var featureNode, option, newNode, next, attr;

	for ( var i=0 ; i<parts.length ; i++ ) {
		featureNode = null;
		option = parts[i];

		if ( option == '<' ) {
			// New container div
			newNode = $('<div/>');

			// Check to see if we should append an id and/or a class name to the container
			next = parts[i+1];

			if ( next[0] == "'" || next[0] == '"' ) {
				attr = next.replace(/['"]/g, '');

				var id = '', className;

				/* The attribute can be in the format of "#id.class", "#id" or "class" This logic
				 * breaks the string into parts and applies them as needed
				 */
				if ( attr.indexOf('.') != -1 ) {
					var split = attr.split('.');

					id = split[0];
					className = split[1];
				}
				else if ( attr[0] == "#" ) {
					id = attr;
				}
				else {
					className = attr;
				}

				newNode
					.attr('id', id.substring(1))
					.addClass(className);

				i++; // Move along the position array
			}

			insert.append( newNode );
			insert = newNode;
		}
		else if ( option == '>' ) {
			// End container div
			insert = insert.parent();
		}
		else if ( option == 't' ) {
			// Table
			featureNode = _fnFeatureHtmlTable( settings );
		}
		else
		{
			DataTable.ext.feature.forEach(function(feature) {
				if ( option == feature.cFeature ) {
					featureNode = feature.fnInit( settings );
				}
			});
		}

		// Add to the display
		if ( featureNode ) {
			insert.append( featureNode );
		}
	}
}


/**
 * Use the DOM source to create up an array of header cells. The idea here is to
 * create a layout grid (array) of rows x columns, which contains a reference
 * to the cell that that point in the grid (regardless of col/rowspan), such that
 * any column / row could be removed and the new grid constructed
 *  @param {node} thead The header/footer element for the table
 *  @returns {array} Calculated layout array
 *  @memberof DataTable#oApi
 */
function _fnDetectHeader ( settings, thead, write )
{
	var columns = settings.aoColumns;
	var rows = $(thead).children('tr');
	var row, cell;
	var i, k, l, iLen, shifted, column, colspan, rowspan;
	var isHeader = thead && thead.nodeName.toLowerCase() === 'thead';
	var layout = [];
	var unique;
	var shift = function ( a, i, j ) {
		var k = a[i];
		while ( k[j] ) {
			j++;
		}
		return j;
	};

	// We know how many rows there are in the layout - so prep it
	for ( i=0, iLen=rows.length ; i<iLen ; i++ ) {
		layout.push( [] );
	}

	for ( i=0, iLen=rows.length ; i<iLen ; i++ ) {
		row = rows[i];
		column = 0;

		// For every cell in the row..
		cell = row.firstChild;
		while ( cell ) {
			if (
				cell.nodeName.toUpperCase() == 'TD' ||
				cell.nodeName.toUpperCase() == 'TH'
			) {
				var cols = [];

				// Get the col and rowspan attributes from the DOM and sanitise them
				colspan = cell.getAttribute('colspan') * 1;
				rowspan = cell.getAttribute('rowspan') * 1;
				colspan = (!colspan || colspan===0 || colspan===1) ? 1 : colspan;
				rowspan = (!rowspan || rowspan===0 || rowspan===1) ? 1 : rowspan;

				// There might be colspan cells already in this row, so shift our target
				// accordingly
				shifted = shift( layout, i, column );

				// Cache calculation for unique columns
				unique = colspan === 1 ?
					true :
					false;
				
				// Perform header setup
				if ( write ) {
					if (unique) {
						// Allow column options to be set from HTML attributes
						_fnColumnOptions( settings, shifted, $(cell).data() );
						
						// Get the width for the column. This can be defined from the
						// width attribute, style attribute or `columns.width` option
						var columnDef = columns[shifted];
						var width = cell.getAttribute('width') || null;
						var t = cell.style.width.match(/width:\s*(\d+[pxem%]+)/);
						if ( t ) {
							width = t[1];
						}

						columnDef.sWidthOrig = columnDef.sWidth || width;

						if (isHeader) {
							// Column title handling - can be user set, or read from the DOM
							// This happens before the render, so the original is still in place
							if ( columnDef.sTitle !== null && ! columnDef.autoTitle ) {
								cell.innerHTML = columnDef.sTitle;
							}

							if (! columnDef.sTitle && unique) {
								columnDef.sTitle = _stripHtml(cell.innerHTML);
								columnDef.autoTitle = true;
							}
						}
						else {
							// Footer specific operations
							if (columnDef.footer) {
								cell.innerHTML = columnDef.footer;
							}
						}

						// Fall back to the aria-label attribute on the table header if no ariaTitle is
						// provided.
						if (! columnDef.ariaTitle) {
							columnDef.ariaTitle = $(cell).attr("aria-label") || columnDef.sTitle;
						}

						// Column specific class names
						if ( columnDef.className ) {
							$(cell).addClass( columnDef.className );
						}
					}

					// Wrap the column title so we can write to it in future
					if ( $('span.dt-column-title', cell).length === 0) {
						$('<span>')
							.addClass('dt-column-title')
							.append(cell.childNodes)
							.appendTo(cell);
					}

					if ( isHeader && $('span.dt-column-order', cell).length === 0) {
						$('<span>')
							.addClass('dt-column-order')
							.appendTo(cell);
					}
				}

				// If there is col / rowspan, copy the information into the layout grid
				for ( l=0 ; l<colspan ; l++ ) {
					for ( k=0 ; k<rowspan ; k++ ) {
						layout[i+k][shifted+l] = {
							cell: cell,
							unique: unique
						};

						layout[i+k].row = row;
					}

					cols.push( shifted+l );
				}

				// Assign an attribute so spanning cells can still be identified
				// as belonging to a column
				cell.setAttribute('data-dt-column', _unique(cols).join(','));
			}

			cell = cell.nextSibling;
		}
	}

	return layout;
}

/**
 * Set the start position for draw
 *  @param {object} oSettings dataTables settings object
 */
function _fnStart( oSettings )
{
	var bServerSide = _fnDataSource( oSettings ) == 'ssp';
	var iInitDisplayStart = oSettings.iInitDisplayStart;

	// Check and see if we have an initial draw position from state saving
	if ( iInitDisplayStart !== undefined && iInitDisplayStart !== -1 )
	{
		oSettings._iDisplayStart = bServerSide ?
			iInitDisplayStart :
			iInitDisplayStart >= oSettings.fnRecordsDisplay() ?
				0 :
				iInitDisplayStart;

		oSettings.iInitDisplayStart = -1;
	}
}

/**
 * Create an Ajax call based on the table's settings, taking into account that
 * parameters can have multiple forms, and backwards compatibility.
 *
 * @param {object} oSettings dataTables settings object
 * @param {array} data Data to send to the server, required by
 *     DataTables - may be augmented by developer callbacks
 * @param {function} fn Callback function to run when data is obtained
 */
function _fnBuildAjax( oSettings, data, fn )
{
	var ajaxData;
	var ajax = oSettings.ajax;
	var instance = oSettings.oInstance;
	var callback = function ( json ) {
		var status = oSettings.jqXHR
			? oSettings.jqXHR.status
			: null;

		if ( json === null || (typeof status === 'number' && status == 204 ) ) {
			json = {};
			_fnAjaxDataSrc( oSettings, json, [] );
		}

		var error = json.error || json.sError;
		if ( error ) {
			_fnLog( oSettings, 0, error );
		}

		oSettings.json = json;

		_fnCallbackFire( oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR], true );
		fn( json );
	};

	if ( $.isPlainObject( ajax ) && ajax.data )
	{
		ajaxData = ajax.data;

		var newData = typeof ajaxData === 'function' ?
			ajaxData( data, oSettings ) :  // fn can manipulate data or return
			ajaxData;                      // an object object or array to merge

		// If the function returned something, use that alone
		data = typeof ajaxData === 'function' && newData ?
			newData :
			$.extend( true, data, newData );

		// Remove the data property as we've resolved it already and don't want
		// jQuery to do it again (it is restored at the end of the function)
		delete ajax.data;
	}

	var baseAjax = {
		"url": typeof ajax === 'string' ?
			ajax :
			'',
		"data": data,
		"success": callback,
		"dataType": "json",
		"cache": false,
		"type": oSettings.sServerMethod,
		"error": function (xhr, error) {
			var ret = _fnCallbackFire( oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR], true );

			if ( ret.indexOf(true) === -1 ) {
				if ( error == "parsererror" ) {
					_fnLog( oSettings, 0, 'Invalid JSON response', 1 );
				}
				else if ( xhr.readyState === 4 ) {
					_fnLog( oSettings, 0, 'Ajax error', 7 );
				}
			}

			_fnProcessingDisplay( oSettings, false );
		}
	};

	// If `ajax` option is an object, extend and override our default base
	if ( $.isPlainObject( ajax ) ) {
		$.extend( baseAjax, ajax )
	}

	// Store the data submitted for the API
	oSettings.oAjaxData = data;

	// Allow plug-ins and external processes to modify the data
	_fnCallbackFire( oSettings, null, 'preXhr', [oSettings, data, baseAjax], true );

	if ( typeof ajax === 'function' )
	{
		// Is a function - let the caller define what needs to be done
		oSettings.jqXHR = ajax.call( instance, data, callback, oSettings );
	}
	else if (ajax.url === '') {
		// No url, so don't load any data. Just apply an empty data array
		// to the object for the callback.
		var empty = {};

		DataTable.util.set(ajax.dataSrc)(empty, []);
		callback(empty);
	}
	else {
		// Object to extend the base settings
		oSettings.jqXHR = $.ajax( baseAjax );

		// Restore for next time around
		if ( ajaxData ) {
			ajax.data = ajaxData;
		}
	}
}


/**
 * Update the table using an Ajax call
 *  @param {object} settings dataTables settings object
 *  @returns {boolean} Block the table drawing or not
 *  @memberof DataTable#oApi
 */
function _fnAjaxUpdate( settings )
{
	settings.iDraw++;
	_fnProcessingDisplay( settings, true );

	_fnBuildAjax(
		settings,
		_fnAjaxParameters( settings ),
		function(json) {
			_fnAjaxUpdateDraw( settings, json );
		}
	);
}


/**
 * Build up the parameters in an object needed for a server-side processing
 * request.
 *  @param {object} oSettings dataTables settings object
 *  @returns {bool} block the table drawing or not
 *  @memberof DataTable#oApi
 */
function _fnAjaxParameters( settings )
{
	var
		columns = settings.aoColumns,
		features = settings.oFeatures,
		preSearch = settings.oPreviousSearch,
		preColSearch = settings.aoPreSearchCols,
		colData = function ( idx, prop ) {
			return typeof columns[idx][prop] === 'function' ?
				'function' :
				columns[idx][prop];
		};

	return {
		draw: settings.iDraw,
		columns: columns.map( function ( column, i ) {
			return {
				data: colData(i, 'mData'),
				name: column.sName,
				searchable: column.bSearchable,
				orderable: column.bSortable,
				search: {
					value: preColSearch[i].search,
					regex: preColSearch[i].regex,
					fixed: Object.keys(column.searchFixed).map( function(name) {
						return {
							name: name,
							term: column.searchFixed[name].toString()
						}
					})
				}
			};
		} ),
		order: _fnSortFlatten( settings ).map( function ( val ) {
			return {
				column: val.col,
				dir: val.dir,
				name: colData(val.col, 'sName')
			};
		} ),
		start: settings._iDisplayStart,
		length: features.bPaginate ?
			settings._iDisplayLength :
			-1,
		search: {
			value: preSearch.search,
			regex: preSearch.regex,
			fixed: Object.keys(settings.searchFixed).map( function(name) {
				return {
					name: name,
					term: settings.searchFixed[name].toString()
				}
			})
		}
	};
}


/**
 * Data the data from the server (nuking the old) and redraw the table
 *  @param {object} oSettings dataTables settings object
 *  @param {object} json json data return from the server.
 *  @param {string} json.sEcho Tracking flag for DataTables to match requests
 *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
 *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
 *  @param {array} json.aaData The data to display on this page
 *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
 *  @memberof DataTable#oApi
 */
function _fnAjaxUpdateDraw ( settings, json )
{
	var data = _fnAjaxDataSrc(settings, json);
	var draw = _fnAjaxDataSrcParam(settings, 'draw', json);
	var recordsTotal = _fnAjaxDataSrcParam(settings, 'recordsTotal', json);
	var recordsFiltered = _fnAjaxDataSrcParam(settings, 'recordsFiltered', json);

	if ( draw !== undefined ) {
		// Protect against out of sequence returns
		if ( draw*1 < settings.iDraw ) {
			return;
		}
		settings.iDraw = draw * 1;
	}

	// No data in returned object, so rather than an array, we show an empty table
	if ( ! data ) {
		data = [];
	}

	_fnClearTable( settings );
	settings._iRecordsTotal   = parseInt(recordsTotal, 10);
	settings._iRecordsDisplay = parseInt(recordsFiltered, 10);

	for ( var i=0, ien=data.length ; i<ien ; i++ ) {
		_fnAddData( settings, data[i] );
	}
	settings.aiDisplay = settings.aiDisplayMaster.slice();

	_fnDraw( settings, true );
	_fnInitComplete( settings );
	_fnProcessingDisplay( settings, false );
}


/**
 * Get the data from the JSON data source to use for drawing a table. Using
 * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
 * source object, or from a processing function.
 *  @param {object} settings dataTables settings object
 *  @param  {object} json Data source object / array from the server
 *  @return {array} Array of data to use
 */
function _fnAjaxDataSrc ( settings, json, write )
{
	var dataProp = 'data';

	if ($.isPlainObject( settings.ajax ) && settings.ajax.dataSrc !== undefined) {
		// Could in inside a `dataSrc` object, or not!
		var dataSrc = settings.ajax.dataSrc;

		// string, function and object are valid types
		if (typeof dataSrc === 'string' || typeof dataSrc === 'function') {
			dataProp = dataSrc;
		}
		else if (dataSrc.data !== undefined) {
			dataProp = dataSrc.data;
		}
	}

	if ( ! write ) {
		if ( dataProp === 'data' ) {
			// If the default, then we still want to support the old style, and safely ignore
			// it if possible
			return json.aaData || json[dataProp];
		}

		return dataProp !== "" ?
			_fnGetObjectDataFn( dataProp )( json ) :
			json;
	}
	
	// set
	_fnSetObjectDataFn( dataProp )( json, write );
}

/**
 * Very similar to _fnAjaxDataSrc, but for the other SSP properties
 * @param {*} settings DataTables settings object
 * @param {*} param Target parameter
 * @param {*} json JSON data
 * @returns Resolved value
 */
function _fnAjaxDataSrcParam (settings, param, json) {
	var dataSrc = $.isPlainObject( settings.ajax )
		? settings.ajax.dataSrc
		: null;

	if (dataSrc && dataSrc[param]) {
		// Get from custom location
		return _fnGetObjectDataFn( dataSrc[param] )( json );
	}

	// else - Default behaviour
	var old = '';

	// Legacy support
	if (param === 'draw') {
		old = 'sEcho';
	}
	else if (param === 'recordsTotal') {
		old = 'iTotalRecords';
	}
	else if (param === 'recordsFiltered') {
		old = 'iTotalDisplayRecords';
	}

	return json[old] !== undefined
		? json[old]
		: json[param];
}


/**
 * Filter the table using both the global filter and column based filtering
 *  @param {object} settings dataTables settings object
 *  @param {object} input search information
 *  @memberof DataTable#oApi
 */
function _fnFilterComplete ( settings, input )
{
	var columnsSearch = settings.aoPreSearchCols;

	// Resolve any column types that are unknown due to addition or invalidation
	// @todo As per sort - can this be moved into an event handler?
	_fnColumnTypes( settings );

	// In server-side processing all filtering is done by the server, so no point hanging around here
	if ( _fnDataSource( settings ) != 'ssp' )
	{
		// Check if any of the rows were invalidated
		_fnFilterData( settings );

		// Start from the full data set
		settings.aiDisplay = settings.aiDisplayMaster.slice();

		// Global filter first
		_fnFilter( settings.aiDisplay, settings, input.search, input );

		$.each(settings.searchFixed, function (name, term) {
			_fnFilter(settings.aiDisplay, settings, term, {});
		});

		// Then individual column filters
		for ( var i=0 ; i<columnsSearch.length ; i++ )
		{
			var col = columnsSearch[i];

			_fnFilter(
				settings.aiDisplay,
				settings,
				col.search,
				col,
				i
			);

			$.each(settings.aoColumns[i].searchFixed, function (name, term) {
				_fnFilter(settings.aiDisplay, settings, term, {}, i);
			});
		}

		// And finally global filtering
		_fnFilterCustom( settings );
	}

	// Tell the draw function we have been filtering
	settings.bFiltered = true;

	_fnCallbackFire( settings, null, 'search', [settings] );
}


/**
 * Apply custom filtering functions
 * 
 * This is legacy now that we have named functions, but it is widely used
 * from 1.x, so it is not yet deprecated.
 *  @param {object} oSettings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnFilterCustom( settings )
{
	var filters = DataTable.ext.search;
	var displayRows = settings.aiDisplay;
	var row, rowIdx;

	for ( var i=0, ien=filters.length ; i<ien ; i++ ) {
		var rows = [];

		// Loop over each row and see if it should be included
		for ( var j=0, jen=displayRows.length ; j<jen ; j++ ) {
			rowIdx = displayRows[ j ];
			row = settings.aoData[ rowIdx ];

			if ( filters[i]( settings, row._aFilterData, rowIdx, row._aData, j ) ) {
				rows.push( rowIdx );
			}
		}

		// So the array reference doesn't break set the results into the
		// existing array
		displayRows.length = 0;
		displayRows.push.apply(displayRows, rows);
	}
}


/**
 * Filter the data table based on user input and draw the table
 */
function _fnFilter( searchRows, settings, input, options, column )
{
	if ( input === '' ) {
		return;
	}

	var i = 0;
	var matched = [];

	// Search term can be a function, regex or string - if a string we apply our
	// smart filtering regex (assuming the options require that)
	var searchFunc = typeof input === 'function' ? input : null;
	var rpSearch = input instanceof RegExp
		? input
		: searchFunc
			? null
			: _fnFilterCreateSearch( input, options );

	// Then for each row, does the test pass. If not, lop the row from the array
	for (i=0 ; i<searchRows.length ; i++) {
		var row = settings.aoData[ searchRows[i] ];
		var data = column === undefined
			? row._sFilterRow
			: row._aFilterData[ column ];

		if ( (searchFunc && searchFunc(data, row._aData, searchRows[i], column)) || (rpSearch && rpSearch.test(data)) ) {
			matched.push(searchRows[i]);
		}
	}

	// Mutate the searchRows array
	searchRows.length = matched.length;

	for (i=0 ; i<matched.length ; i++) {
		searchRows[i] = matched[i];
	}
}


/**
 * Build a regular expression object suitable for searching a table
 *  @param {string} sSearch string to search for
 *  @param {bool} bRegex treat as a regular expression or not
 *  @param {bool} bSmart perform smart filtering or not
 *  @param {bool} bCaseInsensitive Do case insensitive matching or not
 *  @returns {RegExp} constructed object
 *  @memberof DataTable#oApi
 */
function _fnFilterCreateSearch( search, inOpts )
{
	var not = [];
	var options = $.extend({}, {
		boundary: false,
		caseInsensitive: true,
		exact: false,
		regex: false,
		smart: true
	}, inOpts);

	if (typeof search !== 'string') {
		search = search.toString();
	}

	// Remove diacritics if normalize is set up to do so
	search = _normalize(search);

	if (options.exact) {
		return new RegExp(
			'^'+_fnEscapeRegex(search)+'$',
			options.caseInsensitive ? 'i' : ''
		);
	}

	search = options.regex ?
		search :
		_fnEscapeRegex( search );
	
	if ( options.smart ) {
		/* For smart filtering we want to allow the search to work regardless of
		 * word order. We also want double quoted text to be preserved, so word
		 * order is important - a la google. And a negative look around for
		 * finding rows which don't contain a given string.
		 * 
		 * So this is the sort of thing we want to generate:
		 * 
		 * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
		 */
		var parts = search.match( /!?["\u201C][^"\u201D]+["\u201D]|[^ ]+/g ) || [''];
		var a = parts.map( function ( word ) {
			var negative = false;
			var m;

			// Determine if it is a "does not include"
			if ( word.charAt(0) === '!' ) {
				negative = true;
				word = word.substring(1);
			}

			// Strip the quotes from around matched phrases
			if ( word.charAt(0) === '"' ) {
				m = word.match( /^"(.*)"$/ );
				word = m ? m[1] : word;
			}
			else if ( word.charAt(0) === '\u201C' ) {
				// Smart quote match (iPhone users)
				m = word.match( /^\u201C(.*)\u201D$/ );
				word = m ? m[1] : word;
			}

			// For our "not" case, we need to modify the string that is
			// allowed to match at the end of the expression.
			if (negative) {
				if (word.length > 1) {
					not.push('(?!'+word+')');
				}

				word = '';
			}

			return word.replace(/"/g, '');
		} );

		var match = not.length
			? not.join('')
			: '';

		var boundary = options.boundary
			? '\\b'
			: '';

		search = '^(?=.*?'+boundary+a.join( ')(?=.*?'+boundary )+')('+match+'.)*$';
	}

	return new RegExp( search, options.caseInsensitive ? 'i' : '' );
}


/**
 * Escape a string such that it can be used in a regular expression
 *  @param {string} sVal string to escape
 *  @returns {string} escaped string
 *  @memberof DataTable#oApi
 */
var _fnEscapeRegex = DataTable.util.escapeRegex;

var __filter_div = $('<div>')[0];
var __filter_div_textContent = __filter_div.textContent !== undefined;

// Update the filtering data for each row if needed (by invalidation or first run)
function _fnFilterData ( settings )
{
	var columns = settings.aoColumns;
	var data = settings.aoData;
	var column;
	var j, jen, filterData, cellData, row;
	var wasInvalidated = false;

	for ( var rowIdx=0 ; rowIdx<data.length ; rowIdx++ ) {
		if (! data[rowIdx]) {
			continue;
		}

		row = data[rowIdx];

		if ( ! row._aFilterData ) {
			filterData = [];

			for ( j=0, jen=columns.length ; j<jen ; j++ ) {
				column = columns[j];

				if ( column.bSearchable ) {
					cellData = _fnGetCellData( settings, rowIdx, j, 'filter' );

					// Search in DataTables is string based
					if ( cellData === null ) {
						cellData = '';
					}

					if ( typeof cellData !== 'string' && cellData.toString ) {
						cellData = cellData.toString();
					}
				}
				else {
					cellData = '';
				}

				// If it looks like there is an HTML entity in the string,
				// attempt to decode it so sorting works as expected. Note that
				// we could use a single line of jQuery to do this, but the DOM
				// method used here is much faster https://jsperf.com/html-decode
				if ( cellData.indexOf && cellData.indexOf('&') !== -1 ) {
					__filter_div.innerHTML = cellData;
					cellData = __filter_div_textContent ?
						__filter_div.textContent :
						__filter_div.innerText;
				}

				if ( cellData.replace ) {
					cellData = cellData.replace(/[\r\n\u2028]/g, '');
				}

				filterData.push( cellData );
			}

			row._aFilterData = filterData;
			row._sFilterRow = filterData.join('  ');
			wasInvalidated = true;
		}
	}

	return wasInvalidated;
}


/**
 * Draw the table for the first time, adding all required features
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnInitialise ( settings )
{
	var i, iAjaxStart=settings.iInitDisplayStart;

	/* Ensure that the table data is fully initialised */
	if ( ! settings.bInitialised ) {
		setTimeout( function(){ _fnInitialise( settings ); }, 200 );
		return;
	}

	/* Build and draw the header / footer for the table */
	_fnBuildHead( settings, 'header' );
	_fnBuildHead( settings, 'footer' );
	_fnDrawHead( settings, settings.aoHeader );
	_fnDrawHead( settings, settings.aoFooter );

	// Enable features
	_fnAddOptionsHtml( settings );
	_fnSortInit( settings );

	_colGroup( settings );

	/* Okay to show that something is going on now */
	_fnProcessingDisplay( settings, true );

	_fnCallbackFire( settings, null, 'preInit', [settings], true );

	// If there is default sorting required - let's do it. The sort function
	// will do the drawing for us. Otherwise we draw the table regardless of the
	// Ajax source - this allows the table to look initialised for Ajax sourcing
	// data (show 'loading' message possibly)
	_fnReDraw( settings );

	var dataSrc = _fnDataSource( settings );

	// Server-side processing init complete is done by _fnAjaxUpdateDraw
	if ( dataSrc != 'ssp' ) {
		// if there is an ajax source load the data
		if ( dataSrc == 'ajax' ) {
			_fnBuildAjax( settings, {}, function(json) {
				var aData = _fnAjaxDataSrc( settings, json );

				// Got the data - add it to the table
				for ( i=0 ; i<aData.length ; i++ ) {
					_fnAddData( settings, aData[i] );
				}

				// Reset the init display for cookie saving. We've already done
				// a filter, and therefore cleared it before. So we need to make
				// it appear 'fresh'
				settings.iInitDisplayStart = iAjaxStart;

				_fnReDraw( settings );
				_fnProcessingDisplay( settings, false );
				_fnInitComplete( settings );
			}, settings );
		}
		else {
			_fnInitComplete( settings );
			_fnProcessingDisplay( settings, false );
		}
	}
}


/**
 * Draw the table for the first time, adding all required features
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnInitComplete ( settings )
{
	if (settings._bInitComplete) {
		return;
	}

	var args = [settings, settings.json];

	settings._bInitComplete = true;

	// Table is fully set up and we have data, so calculate the
	// column widths
	_fnAdjustColumnSizing( settings );

	_fnCallbackFire( settings, null, 'plugin-init', args, true );
	_fnCallbackFire( settings, 'aoInitComplete', 'init', args, true );
}

function _fnLengthChange ( settings, val )
{
	var len = parseInt( val, 10 );
	settings._iDisplayLength = len;

	_fnLengthOverflow( settings );

	// Fire length change event
	_fnCallbackFire( settings, null, 'length', [settings, len] );
}

/**
 * Alter the display settings to change the page
 *  @param {object} settings DataTables settings object
 *  @param {string|int} action Paging action to take: "first", "previous",
 *    "next" or "last" or page number to jump to (integer)
 *  @param [bool] redraw Automatically draw the update or not
 *  @returns {bool} true page has changed, false - no change
 *  @memberof DataTable#oApi
 */
function _fnPageChange ( settings, action, redraw )
{
	var
		start     = settings._iDisplayStart,
		len       = settings._iDisplayLength,
		records   = settings.fnRecordsDisplay();

	if ( records === 0 || len === -1 )
	{
		start = 0;
	}
	else if ( typeof action === "number" )
	{
		start = action * len;

		if ( start > records )
		{
			start = 0;
		}
	}
	else if ( action == "first" )
	{
		start = 0;
	}
	else if ( action == "previous" )
	{
		start = len >= 0 ?
			start - len :
			0;

		if ( start < 0 )
		{
			start = 0;
		}
	}
	else if ( action == "next" )
	{
		if ( start + len < records )
		{
			start += len;
		}
	}
	else if ( action == "last" )
	{
		start = Math.floor( (records-1) / len) * len;
	}
	else if ( action === 'ellipsis' )
	{
		return;
	}
	else
	{
		_fnLog( settings, 0, "Unknown paging action: "+action, 5 );
	}

	var changed = settings._iDisplayStart !== start;
	settings._iDisplayStart = start;

	_fnCallbackFire( settings, null, changed ? 'page' : 'page-nc', [settings] );

	if ( changed && redraw ) {
		_fnDraw( settings );
	}

	return changed;
}


/**
 * Generate the node required for the processing node
 *  @param {object} settings DataTables settings object
 */
function _processingHtml ( settings )
{
	var table = settings.nTable;
	var scrolling = settings.oScroll.sX !== '' || settings.oScroll.sY !== '';

	if ( settings.oFeatures.bProcessing ) {
		var n = $('<div/>', {
				'id': settings.sTableId + '_processing',
				'class': settings.oClasses.processing.container,
				'role': 'status'
			} )
			.html( settings.oLanguage.sProcessing )
			.append('<div><div></div><div></div><div></div><div></div></div>');

		// Different positioning depending on if scrolling is enabled or not
		if (scrolling) {
			n.prependTo( $('div.dt-scroll', settings.nTableWrapper) );
		}
		else {
			n.insertBefore( table );
		}

		$(table).on( 'processing.dt.DT', function (e, s, show) {
			n.css( 'display', show ? 'block' : 'none' );
		} );
	}
}


/**
 * Display or hide the processing indicator
 *  @param {object} settings DataTables settings object
 *  @param {bool} show Show the processing indicator (true) or not (false)
 */
function _fnProcessingDisplay ( settings, show )
{
	_fnCallbackFire( settings, null, 'processing', [settings, show] );
}
/**
 * Add any control elements for the table - specifically scrolling
 *  @param {object} settings dataTables settings object
 *  @returns {node} Node to add to the DOM
 *  @memberof DataTable#oApi
 */
function _fnFeatureHtmlTable ( settings )
{
	var table = $(settings.nTable);

	// Scrolling from here on in
	var scroll = settings.oScroll;

	if ( scroll.sX === '' && scroll.sY === '' ) {
		return settings.nTable;
	}

	var scrollX = scroll.sX;
	var scrollY = scroll.sY;
	var classes = settings.oClasses.scrolling;
	var caption = settings.captionNode;
	var captionSide = caption ? caption._captionSide : null;
	var headerClone = $( table[0].cloneNode(false) );
	var footerClone = $( table[0].cloneNode(false) );
	var footer = table.children('tfoot');
	var _div = '<div/>';
	var size = function ( s ) {
		return !s ? null : _fnStringToCss( s );
	};

	if ( ! footer.length ) {
		footer = null;
	}

	/*
	 * The HTML structure that we want to generate in this function is:
	 *  div - scroller
	 *    div - scroll head
	 *      div - scroll head inner
	 *        table - scroll head table
	 *          thead - thead
	 *    div - scroll body
	 *      table - table (master table)
	 *        thead - thead clone for sizing
	 *        tbody - tbody
	 *    div - scroll foot
	 *      div - scroll foot inner
	 *        table - scroll foot table
	 *          tfoot - tfoot
	 */
	var scroller = $( _div, { 'class': classes.container } )
		.append(
			$(_div, { 'class': classes.header.self } )
				.css( {
					overflow: 'hidden',
					position: 'relative',
					border: 0,
					width: scrollX ? size(scrollX) : '100%'
				} )
				.append(
					$(_div, { 'class': classes.header.inner } )
						.css( {
							'box-sizing': 'content-box',
							width: scroll.sXInner || '100%'
						} )
						.append(
							headerClone
								.removeAttr('id')
								.css( 'margin-left', 0 )
								.append( captionSide === 'top' ? caption : null )
								.append(
									table.children('thead')
								)
						)
				)
		)
		.append(
			$(_div, { 'class': classes.body } )
				.css( {
					position: 'relative',
					overflow: 'auto',
					width: size( scrollX )
				} )
				.append( table )
		);

	if ( footer ) {
		scroller.append(
			$(_div, { 'class': classes.footer.self } )
				.css( {
					overflow: 'hidden',
					border: 0,
					width: scrollX ? size(scrollX) : '100%'
				} )
				.append(
					$(_div, { 'class': classes.footer.inner } )
						.append(
							footerClone
								.removeAttr('id')
								.css( 'margin-left', 0 )
								.append( captionSide === 'bottom' ? caption : null )
								.append(
									table.children('tfoot')
								)
						)
				)
		);
	}

	var children = scroller.children();
	var scrollHead = children[0];
	var scrollBody = children[1];
	var scrollFoot = footer ? children[2] : null;

	// When the body is scrolled, then we also want to scroll the headers
	$(scrollBody).on( 'scroll.DT', function () {
		var scrollLeft = this.scrollLeft;

		scrollHead.scrollLeft = scrollLeft;

		if ( footer ) {
			scrollFoot.scrollLeft = scrollLeft;
		}
	} );

	// When focus is put on the header cells, we might need to scroll the body
	$('th, td', scrollHead).on('focus', function () {
		var scrollLeft = scrollHead.scrollLeft;

		scrollBody.scrollLeft = scrollLeft;

		if ( footer ) {
			scrollBody.scrollLeft = scrollLeft;
		}
	});

	$(scrollBody).css('max-height', scrollY);
	if (! scroll.bCollapse) {
		$(scrollBody).css('height', scrollY);
	}

	settings.nScrollHead = scrollHead;
	settings.nScrollBody = scrollBody;
	settings.nScrollFoot = scrollFoot;

	// On redraw - align columns
	settings.aoDrawCallback.push(_fnScrollDraw);

	return scroller[0];
}



/**
 * Update the header, footer and body tables for resizing - i.e. column
 * alignment.
 *
 * Welcome to the most horrible function DataTables. The process that this
 * function follows is basically:
 *   1. Re-create the table inside the scrolling div
 *   2. Correct colgroup > col values if needed
 *   3. Copy colgroup > col over to header and footer
 *   4. Clean up
 *
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnScrollDraw ( settings )
{
	// Given that this is such a monster function, a lot of variables are use
	// to try and keep the minimised size as small as possible
	var
		scroll         = settings.oScroll,
		barWidth       = scroll.iBarWidth,
		divHeader      = $(settings.nScrollHead),
		divHeaderInner = divHeader.children('div'),
		divHeaderTable = divHeaderInner.children('table'),
		divBodyEl      = settings.nScrollBody,
		divBody        = $(divBodyEl),
		divFooter      = $(settings.nScrollFoot),
		divFooterInner = divFooter.children('div'),
		divFooterTable = divFooterInner.children('table'),
		header         = $(settings.nTHead),
		table          = $(settings.nTable),
		footer         = settings.nTFoot && $('th, td', settings.nTFoot).length ? $(settings.nTFoot) : null,
		browser        = settings.oBrowser,
		headerCopy, footerCopy;

	// If the scrollbar visibility has changed from the last draw, we need to
	// adjust the column sizes as the table width will have changed to account
	// for the scrollbar
	var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
	
	if ( settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined ) {
		settings.scrollBarVis = scrollBarVis;
		_fnAdjustColumnSizing( settings );
		return; // adjust column sizing will call this function again
	}
	else {
		settings.scrollBarVis = scrollBarVis;
	}

	// 1. Re-create the table inside the scrolling div
	// Remove the old minimised thead and tfoot elements in the inner table
	table.children('thead, tfoot').remove();

	// Clone the current header and footer elements and then place it into the inner table
	headerCopy = header.clone().prependTo( table );
	headerCopy.find('th, td').removeAttr('tabindex');
	headerCopy.find('[id]').removeAttr('id');

	if ( footer ) {
		footerCopy = footer.clone().prependTo( table );
		footerCopy.find('[id]').removeAttr('id');
	}

	// 2. Correct colgroup > col values if needed
	// It is possible that the cell sizes are smaller than the content, so we need to
	// correct colgroup>col for such cases. This can happen if the auto width detection
	// uses a cell which has a longer string, but isn't the widest! For example 
	// "Chief Executive Officer (CEO)" is the longest string in the demo, but
	// "Systems Administrator" is actually the widest string since it doesn't collapse.
	// Note the use of translating into a column index to get the `col` element. This
	// is because of Responsive which might remove `col` elements, knocking the alignment
	// of the indexes out.
	if (settings.aiDisplay.length) {
		// Get the column sizes from the first row in the table
		var colSizes = table.children('tbody').eq(0).children('tr').eq(0).children('th, td').map(function (vis) {
			return {
				idx: _fnVisibleToColumnIndex(settings, vis),
				width: $(this).outerWidth()
			}
		});

		// Check against what the colgroup > col is set to and correct if needed
		for (var i=0 ; i<colSizes.length ; i++) {
			var colEl = settings.aoColumns[ colSizes[i].idx ].colEl[0];
			var colWidth = colEl.style.width.replace('px', '');

			if (colWidth !== colSizes[i].width) {
				colEl.style.width = colSizes[i].width + 'px';
			}
		}
	}

	// 3. Copy the colgroup over to the header and footer
	divHeaderTable
		.find('colgroup')
		.remove();

	divHeaderTable.append(settings.colgroup.clone());

	if ( footer ) {
		divFooterTable
			.find('colgroup')
			.remove();

		divFooterTable.append(settings.colgroup.clone());
	}

	// "Hide" the header and footer that we used for the sizing. We need to keep
	// the content of the cell so that the width applied to the header and body
	// both match, but we want to hide it completely.
	$('th, td', headerCopy).each(function () {
		$(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
	});

	if ( footer ) {
		$('th, td', footerCopy).each(function () {
			$(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
		});
	}

	// 4. Clean up
	// Figure out if there are scrollbar present - if so then we need a the header and footer to
	// provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
	var isScrolling = Math.floor(table.height()) > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
	var paddingSide = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right' );

	// Set the width's of the header and footer tables
	var outerWidth = table.outerWidth();

	divHeaderTable.css('width', _fnStringToCss( outerWidth ));
	divHeaderInner
		.css('width', _fnStringToCss( outerWidth ))
		.css(paddingSide, isScrolling ? barWidth+"px" : "0px");

	if ( footer ) {
		divFooterTable.css('width', _fnStringToCss( outerWidth ));
		divFooterInner
			.css('width', _fnStringToCss( outerWidth ))
			.css(paddingSide, isScrolling ? barWidth+"px" : "0px");
	}

	// Correct DOM ordering for colgroup - comes before the thead
	table.children('colgroup').prependTo(table);

	// Adjust the position of the header in case we loose the y-scrollbar
	divBody.trigger('scroll');

	// If sorting or filtering has occurred, jump the scrolling back to the top
	// only if we aren't holding the position
	if ( (settings.bSorted || settings.bFiltered) && ! settings._drawHold ) {
		divBodyEl.scrollTop = 0;
	}
}

/**
 * Calculate the width of columns for the table
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnCalculateColumnWidths ( settings )
{
	// Not interested in doing column width calculation if auto-width is disabled
	if (! settings.oFeatures.bAutoWidth) {
		return;
	}

	var
		table = settings.nTable,
		columns = settings.aoColumns,
		scroll = settings.oScroll,
		scrollY = scroll.sY,
		scrollX = scroll.sX,
		scrollXInner = scroll.sXInner,
		visibleColumns = _fnGetColumns( settings, 'bVisible' ),
		tableWidthAttr = table.getAttribute('width'), // from DOM element
		tableContainer = table.parentNode,
		i, column, columnIdx;

	var styleWidth = table.style.width;
	if ( styleWidth && styleWidth.indexOf('%') !== -1 ) {
		tableWidthAttr = styleWidth;
	}

	// Let plug-ins know that we are doing a recalc, in case they have changed any of the
	// visible columns their own way (e.g. Responsive uses display:none).
	_fnCallbackFire(
		settings,
		null,
		'column-calc',
		{visible: visibleColumns},
		false
	);

	// Construct a single row, worst case, table with the widest
	// node in the data, assign any user defined widths, then insert it into
	// the DOM and allow the browser to do all the hard work of calculating
	// table widths
	var tmpTable = $(table.cloneNode())
		.css( 'visibility', 'hidden' )
		.removeAttr( 'id' );

	// Clean up the table body
	tmpTable.append('<tbody>')
	var tr = $('<tr/>').appendTo( tmpTable.find('tbody') );

	// Clone the table header and footer - we can't use the header / footer
	// from the cloned table, since if scrolling is active, the table's
	// real header and footer are contained in different table tags
	tmpTable
		.append( $(settings.nTHead).clone() )
		.append( $(settings.nTFoot).clone() );

	// Remove any assigned widths from the footer (from scrolling)
	tmpTable.find('tfoot th, tfoot td').css('width', '');

	// Apply custom sizing to the cloned header
	tmpTable.find('thead th, thead td').each( function () {
		// Get the `width` from the header layout
		var width = _fnColumnsSumWidth( settings, this, true, false );

		if ( width ) {
			this.style.width = width;

			// For scrollX we need to force the column width otherwise the
			// browser will collapse it. If this width is smaller than the
			// width the column requires, then it will have no effect
			if ( scrollX ) {
				$( this ).append( $('<div/>').css( {
					width: width,
					margin: 0,
					padding: 0,
					border: 0,
					height: 1
				} ) );
			}
		}
		else {
			this.style.width = '';
		}
	} );

	// Find the widest piece of data for each column and put it into the table
	for ( i=0 ; i<visibleColumns.length ; i++ ) {
		columnIdx = visibleColumns[i];
		column = columns[ columnIdx ];

		var longest = _fnGetMaxLenString(settings, columnIdx);
		var autoClass = _ext.type.className[column.sType];
		var text = longest + column.sContentPadding;
		var insert = longest.indexOf('<') === -1
			? document.createTextNode(text)
			: text
		
		$('<td/>')
			.addClass(autoClass)
			.addClass(column.sClass)
			.append(insert)
			.appendTo(tr);
	}

	// Tidy the temporary table - remove name attributes so there aren't
	// duplicated in the dom (radio elements for example)
	$('[name]', tmpTable).removeAttr('name');

	// Table has been built, attach to the document so we can work with it.
	// A holding element is used, positioned at the top of the container
	// with minimal height, so it has no effect on if the container scrolls
	// or not. Otherwise it might trigger scrolling when it actually isn't
	// needed
	var holder = $('<div/>').css( scrollX || scrollY ?
			{
				position: 'absolute',
				top: 0,
				left: 0,
				height: 1,
				right: 0,
				overflow: 'hidden'
			} :
			{}
		)
		.append( tmpTable )
		.appendTo( tableContainer );

	// When scrolling (X or Y) we want to set the width of the table as 
	// appropriate. However, when not scrolling leave the table width as it
	// is. This results in slightly different, but I think correct behaviour
	if ( scrollX && scrollXInner ) {
		tmpTable.width( scrollXInner );
	}
	else if ( scrollX ) {
		tmpTable.css( 'width', 'auto' );
		tmpTable.removeAttr('width');

		// If there is no width attribute or style, then allow the table to
		// collapse
		if ( tmpTable.width() < tableContainer.clientWidth && tableWidthAttr ) {
			tmpTable.width( tableContainer.clientWidth );
		}
	}
	else if ( scrollY ) {
		tmpTable.width( tableContainer.clientWidth );
	}
	else if ( tableWidthAttr ) {
		tmpTable.width( tableWidthAttr );
	}

	// Get the width of each column in the constructed table
	var total = 0;
	var bodyCells = tmpTable.find('tbody tr').eq(0).children();

	for ( i=0 ; i<visibleColumns.length ; i++ ) {
		// Use getBounding for sub-pixel accuracy, which we then want to round up!
		var bounding = bodyCells[i].getBoundingClientRect().width;

		// Total is tracked to remove any sub-pixel errors as the outerWidth
		// of the table might not equal the total given here
		total += bounding;

		// Width for each column to use
		columns[ visibleColumns[i] ].sWidth = _fnStringToCss( bounding );
	}

	table.style.width = _fnStringToCss( total );

	// Finished with the table - ditch it
	holder.remove();

	// If there is a width attr, we want to attach an event listener which
	// allows the table sizing to automatically adjust when the window is
	// resized. Use the width attr rather than CSS, since we can't know if the
	// CSS is a relative value or absolute - DOM read is always px.
	if ( tableWidthAttr ) {
		table.style.width = _fnStringToCss( tableWidthAttr );
	}

	if ( (tableWidthAttr || scrollX) && ! settings._reszEvt ) {
		var bindResize = function () {
			$(window).on('resize.DT-'+settings.sInstance, DataTable.util.throttle( function () {
				if (! settings.bDestroying) {
					_fnAdjustColumnSizing( settings );
				}
			} ) );
		};

		bindResize();

		settings._reszEvt = true;
	}
}


/**
 * Get the maximum strlen for each data column
 *  @param {object} settings dataTables settings object
 *  @param {int} colIdx column of interest
 *  @returns {string} string of the max length
 *  @memberof DataTable#oApi
 */
function _fnGetMaxLenString( settings, colIdx )
{
	var column = settings.aoColumns[colIdx];

	if (! column.maxLenString) {
		var s, max='', maxLen = -1;
	
		for ( var i=0, ien=settings.aiDisplayMaster.length ; i<ien ; i++ ) {
			var rowIdx = settings.aiDisplayMaster[i];
			var data = _fnGetRowDisplay(settings, rowIdx)[colIdx];

			var cellString = data && typeof data === 'object' && data.nodeType
				? data.innerHTML
				: data+'';

			// Remove id / name attributes from elements so they
			// don't interfere with existing elements
			cellString = cellString
				.replace(/id=".*?"/g, '')
				.replace(/name=".*?"/g, '');

			s = _stripHtml(cellString)
				.replace( /&nbsp;/g, ' ' );
	
			if ( s.length > maxLen ) {
				// We want the HTML in the string, but the length that
				// is important is the stripped string
				max = cellString;
				maxLen = s.length;
			}
		}

		column.maxLenString = max;
	}

	return column.maxLenString;
}


/**
 * Append a CSS unit (only if required) to a string
 *  @param {string} value to css-ify
 *  @returns {string} value with css unit
 *  @memberof DataTable#oApi
 */
function _fnStringToCss( s )
{
	if ( s === null ) {
		return '0px';
	}

	if ( typeof s == 'number' ) {
		return s < 0 ?
			'0px' :
			s+'px';
	}

	// Check it has a unit character already
	return s.match(/\d$/) ?
		s+'px' :
		s;
}

/**
 * Re-insert the `col` elements for current visibility
 *
 * @param {*} settings DT settings
 */
function _colGroup( settings ) {
	var cols = settings.aoColumns;

	settings.colgroup.empty();

	for (i=0 ; i<cols.length ; i++) {
		if (cols[i].bVisible) {
			settings.colgroup.append(cols[i].colEl);
		}
	}
}


function _fnSortInit( settings ) {
	var target = settings.nTHead;
	var headerRows = target.querySelectorAll('tr');
	var legacyTop = settings.bSortCellsTop;
	var notSelector = ':not([data-dt-order="disable"]):not([data-dt-order="icon-only"])';
	
	// Legacy support for `orderCellsTop`
	if (legacyTop === true) {
		target = headerRows[0];
	}
	else if (legacyTop === false) {
		target = headerRows[ headerRows.length - 1 ];
	}

	_fnSortAttachListener(
		settings,
		target,
		target === settings.nTHead
			? 'tr'+notSelector+' th'+notSelector+', tr'+notSelector+' td'+notSelector
			: 'th'+notSelector+', td'+notSelector
	);

	// Need to resolve the user input array into our internal structure
	var order = [];
	_fnSortResolve( settings, order, settings.aaSorting );

	settings.aaSorting = order;
}


function _fnSortAttachListener(settings, node, selector, column, callback) {
	_fnBindAction( node, selector, function (e) {
		var run = false;
		var columns = column === undefined
			? _fnColumnsFromHeader( e.target )
			: [column];

		if ( columns.length ) {
			for ( var i=0, ien=columns.length ; i<ien ; i++ ) {
				var ret = _fnSortAdd( settings, columns[i], i, e.shiftKey );

				if (ret !== false) {
					run = true;
				}					

				// If the first entry is no sort, then subsequent
				// sort columns are ignored
				if (settings.aaSorting.length === 1 && settings.aaSorting[0][1] === '') {
					break;
				}
			}

			if (run) {
				_fnProcessingDisplay( settings, true );

				// Allow the processing display to show
				setTimeout( function () {
					_fnSort( settings );
					_fnSortDisplay( settings, settings.aiDisplay );

					// Sort processing done - redraw has its own processing display
					_fnProcessingDisplay( settings, false );

					_fnReDraw( settings, false, false );

					if (callback) {
						callback();
					}
				}, 0);
			}
		}
	} );
}

/**
 * Sort the display array to match the master's order
 * @param {*} settings
 */
function _fnSortDisplay(settings, display) {
	if (display.length < 2) {
		return;
	}

	var master = settings.aiDisplayMaster;
	var masterMap = {};
	var map = {};
	var i;

	// Rather than needing an `indexOf` on master array, we can create a map
	for (i=0 ; i<master.length ; i++) {
		masterMap[master[i]] = i;
	}

	// And then cache what would be the indexOf fom the display
	for (i=0 ; i<display.length ; i++) {
		map[display[i]] = masterMap[display[i]];
	}

	display.sort(function(a, b){
		// Short version of this function is simply `master.indexOf(a) - master.indexOf(b);`
		return map[a] - map[b];
	});
}


function _fnSortResolve (settings, nestedSort, sort) {
	var push = function ( a ) {
		if ($.isPlainObject(a)) {
			if (a.idx !== undefined) {
				// Index based ordering
				nestedSort.push([a.idx, a.dir]);
			}
			else if (a.name) {
				// Name based ordering
				var cols = _pluck( settings.aoColumns, 'sName');
				var idx = cols.indexOf(a.name);

				if (idx !== -1) {
					nestedSort.push([idx, a.dir]);
				}
			}
		}
		else {
			// Plain column index and direction pair
			nestedSort.push(a);
		}
	};

	if ( $.isPlainObject(sort) ) {
		// Object
		push(sort);
	}
	else if ( sort.length && typeof sort[0] === 'number' ) {
		// 1D array
		push(sort);
	}
	else if ( sort.length ) {
		// 2D array
		for (var z=0; z<sort.length; z++) {
			push(sort[z]); // Object or array
		}
	}
}


function _fnSortFlatten ( settings )
{
	var
		i, k, kLen,
		aSort = [],
		extSort = DataTable.ext.type.order,
		aoColumns = settings.aoColumns,
		aDataSort, iCol, sType, srcCol,
		fixed = settings.aaSortingFixed,
		fixedObj = $.isPlainObject( fixed ),
		nestedSort = [];
	
	if ( ! settings.oFeatures.bSort ) {
		return aSort;
	}

	// Build the sort array, with pre-fix and post-fix options if they have been
	// specified
	if ( Array.isArray( fixed ) ) {
		_fnSortResolve( settings, nestedSort, fixed );
	}

	if ( fixedObj && fixed.pre ) {
		_fnSortResolve( settings, nestedSort, fixed.pre );
	}

	_fnSortResolve( settings, nestedSort, settings.aaSorting );

	if (fixedObj && fixed.post ) {
		_fnSortResolve( settings, nestedSort, fixed.post );
	}

	for ( i=0 ; i<nestedSort.length ; i++ )
	{
		srcCol = nestedSort[i][0];

		if ( aoColumns[ srcCol ] ) {
			aDataSort = aoColumns[ srcCol ].aDataSort;

			for ( k=0, kLen=aDataSort.length ; k<kLen ; k++ )
			{
				iCol = aDataSort[k];
				sType = aoColumns[ iCol ].sType || 'string';

				if ( nestedSort[i]._idx === undefined ) {
					nestedSort[i]._idx = aoColumns[iCol].asSorting.indexOf(nestedSort[i][1]);
				}

				if ( nestedSort[i][1] ) {
					aSort.push( {
						src:       srcCol,
						col:       iCol,
						dir:       nestedSort[i][1],
						index:     nestedSort[i]._idx,
						type:      sType,
						formatter: extSort[ sType+"-pre" ],
						sorter:    extSort[ sType+"-"+nestedSort[i][1] ]
					} );
				}
			}
		}
	}

	return aSort;
}

/**
 * Change the order of the table
 *  @param {object} oSettings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnSort ( oSettings, col, dir )
{
	var
		i, ien, iLen,
		aiOrig = [],
		extSort = DataTable.ext.type.order,
		aoData = oSettings.aoData,
		sortCol,
		displayMaster = oSettings.aiDisplayMaster,
		aSort;

	// Resolve any column types that are unknown due to addition or invalidation
	// @todo Can this be moved into a 'data-ready' handler which is called when
	//   data is going to be used in the table?
	_fnColumnTypes( oSettings );

	// Allow a specific column to be sorted, which will _not_ alter the display
	// master
	if (col !== undefined) {
		var srcCol = oSettings.aoColumns[col];
		aSort = [{
			src:       col,
			col:       col,
			dir:       dir,
			index:     0,
			type:      srcCol.sType,
			formatter: extSort[ srcCol.sType+"-pre" ],
			sorter:    extSort[ srcCol.sType+"-"+dir ]
		}];
		displayMaster = displayMaster.slice();
	}
	else {
		aSort = _fnSortFlatten( oSettings );
	}

	for ( i=0, ien=aSort.length ; i<ien ; i++ ) {
		sortCol = aSort[i];

		// Load the data needed for the sort, for each cell
		_fnSortData( oSettings, sortCol.col );
	}

	/* No sorting required if server-side or no sorting array */
	if ( _fnDataSource( oSettings ) != 'ssp' && aSort.length !== 0 )
	{
		// Reset the initial positions on each pass so we get a stable sort
		for ( i=0, iLen=displayMaster.length ; i<iLen ; i++ ) {
			aiOrig[ i ] = i;
		}

		// If the first sort is desc, then reverse the array to preserve original
		// order, just in reverse
		if (aSort.length && aSort[0].dir === 'desc') {
			aiOrig.reverse();
		}

		/* Do the sort - here we want multi-column sorting based on a given data source (column)
		 * and sorting function (from oSort) in a certain direction. It's reasonably complex to
		 * follow on it's own, but this is what we want (example two column sorting):
		 *  fnLocalSorting = function(a,b){
		 *    var test;
		 *    test = oSort['string-asc']('data11', 'data12');
		 *      if (test !== 0)
		 *        return test;
		 *    test = oSort['numeric-desc']('data21', 'data22');
		 *    if (test !== 0)
		 *      return test;
		 *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
		 *  }
		 * Basically we have a test for each sorting column, if the data in that column is equal,
		 * test the next column. If all columns match, then we use a numeric sort on the row
		 * positions in the original data array to provide a stable sort.
		 */
		displayMaster.sort( function ( a, b ) {
			var
				x, y, k, test, sort,
				len=aSort.length,
				dataA = aoData[a]._aSortData,
				dataB = aoData[b]._aSortData;

			for ( k=0 ; k<len ; k++ ) {
				sort = aSort[k];

				// Data, which may have already been through a `-pre` function
				x = dataA[ sort.col ];
				y = dataB[ sort.col ];

				if (sort.sorter) {
					// If there is a custom sorter (`-asc` or `-desc`) for this
					// data type, use it
					test = sort.sorter(x, y);

					if ( test !== 0 ) {
						return test;
					}
				}
				else {
					// Otherwise, use generic sorting
					test = x<y ? -1 : x>y ? 1 : 0;

					if ( test !== 0 ) {
						return sort.dir === 'asc' ? test : -test;
					}
				}
			}

			x = aiOrig[a];
			y = aiOrig[b];

			return x<y ? -1 : x>y ? 1 : 0;
		} );
	}
	else if ( aSort.length === 0 ) {
		// Apply index order
		displayMaster.sort(function (x, y) {
			return x<y ? -1 : x>y ? 1 : 0;
		});
	}

	if (col === undefined) {
		// Tell the draw function that we have sorted the data
		oSettings.bSorted = true;

		_fnCallbackFire( oSettings, null, 'order', [oSettings, aSort] );
	}

	return displayMaster;
}


/**
 * Function to run on user sort request
 *  @param {object} settings dataTables settings object
 *  @param {node} attachTo node to attach the handler to
 *  @param {int} colIdx column sorting index
 *  @param {int} addIndex Counter
 *  @param {boolean} [shift=false] Shift click add
 *  @param {function} [callback] callback function
 *  @memberof DataTable#oApi
 */
function _fnSortAdd ( settings, colIdx, addIndex, shift )
{
	var col = settings.aoColumns[ colIdx ];
	var sorting = settings.aaSorting;
	var asSorting = col.asSorting;
	var nextSortIdx;
	var next = function ( a, overflow ) {
		var idx = a._idx;
		if ( idx === undefined ) {
			idx = asSorting.indexOf(a[1]);
		}

		return idx+1 < asSorting.length ?
			idx+1 :
			overflow ?
				null :
				0;
	};

	if ( ! col.bSortable ) {
		return false;
	}

	// Convert to 2D array if needed
	if ( typeof sorting[0] === 'number' ) {
		sorting = settings.aaSorting = [ sorting ];
	}

	// If appending the sort then we are multi-column sorting
	if ( (shift || addIndex) && settings.oFeatures.bSortMulti ) {
		// Are we already doing some kind of sort on this column?
		var sortIdx = _pluck(sorting, '0').indexOf(colIdx);

		if ( sortIdx !== -1 ) {
			// Yes, modify the sort
			nextSortIdx = next( sorting[sortIdx], true );

			if ( nextSortIdx === null && sorting.length === 1 ) {
				nextSortIdx = 0; // can't remove sorting completely
			}

			if ( nextSortIdx === null ) {
				sorting.splice( sortIdx, 1 );
			}
			else {
				sorting[sortIdx][1] = asSorting[ nextSortIdx ];
				sorting[sortIdx]._idx = nextSortIdx;
			}
		}
		else if (shift) {
			// No sort on this column yet, being added by shift click
			// add it as itself
			sorting.push( [ colIdx, asSorting[0], 0 ] );
			sorting[sorting.length-1]._idx = 0;
		}
		else {
			// No sort on this column yet, being added from a colspan
			// so add with same direction as first column
			sorting.push( [ colIdx, sorting[0][1], 0 ] );
			sorting[sorting.length-1]._idx = 0;
		}
	}
	else if ( sorting.length && sorting[0][0] == colIdx ) {
		// Single column - already sorting on this column, modify the sort
		nextSortIdx = next( sorting[0] );

		sorting.length = 1;
		sorting[0][1] = asSorting[ nextSortIdx ];
		sorting[0]._idx = nextSortIdx;
	}
	else {
		// Single column - sort only on this column
		sorting.length = 0;
		sorting.push( [ colIdx, asSorting[0] ] );
		sorting[0]._idx = 0;
	}
}


/**
 * Set the sorting classes on table's body, Note: it is safe to call this function
 * when bSort and bSortClasses are false
 *  @param {object} oSettings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnSortingClasses( settings )
{
	var oldSort = settings.aLastSort;
	var sortClass = settings.oClasses.order.position;
	var sort = _fnSortFlatten( settings );
	var features = settings.oFeatures;
	var i, ien, colIdx;

	if ( features.bSort && features.bSortClasses ) {
		// Remove old sorting classes
		for ( i=0, ien=oldSort.length ; i<ien ; i++ ) {
			colIdx = oldSort[i].src;

			// Remove column sorting
			$( _pluck( settings.aoData, 'anCells', colIdx ) )
				.removeClass( sortClass + (i<2 ? i+1 : 3) );
		}

		// Add new column sorting
		for ( i=0, ien=sort.length ; i<ien ; i++ ) {
			colIdx = sort[i].src;

			$( _pluck( settings.aoData, 'anCells', colIdx ) )
				.addClass( sortClass + (i<2 ? i+1 : 3) );
		}
	}

	settings.aLastSort = sort;
}


// Get the data to sort a column, be it from cache, fresh (populating the
// cache), or from a sort formatter
function _fnSortData( settings, colIdx )
{
	// Custom sorting function - provided by the sort data type
	var column = settings.aoColumns[ colIdx ];
	var customSort = DataTable.ext.order[ column.sSortDataType ];
	var customData;

	if ( customSort ) {
		customData = customSort.call( settings.oInstance, settings, colIdx,
			_fnColumnIndexToVisible( settings, colIdx )
		);
	}

	// Use / populate cache
	var row, cellData;
	var formatter = DataTable.ext.type.order[ column.sType+"-pre" ];
	var data = settings.aoData;

	for ( var rowIdx=0 ; rowIdx<data.length ; rowIdx++ ) {
		// Sparse array
		if (! data[rowIdx]) {
			continue;
		}

		row = data[rowIdx];

		if ( ! row._aSortData ) {
			row._aSortData = [];
		}

		if ( ! row._aSortData[colIdx] || customSort ) {
			cellData = customSort ?
				customData[rowIdx] : // If there was a custom sort function, use data from there
				_fnGetCellData( settings, rowIdx, colIdx, 'sort' );

			row._aSortData[ colIdx ] = formatter ?
				formatter( cellData, settings ) :
				cellData;
		}
	}
}


/**
 * State information for a table
 *
 * @param {*} settings
 * @returns State object
 */
function _fnSaveState ( settings )
{
	if (settings._bLoadingState) {
		return;
	}

	/* Store the interesting variables */
	var state = {
		time:    +new Date(),
		start:   settings._iDisplayStart,
		length:  settings._iDisplayLength,
		order:   $.extend( true, [], settings.aaSorting ),
		search:  $.extend({}, settings.oPreviousSearch),
		columns: settings.aoColumns.map( function ( col, i ) {
			return {
				visible: col.bVisible,
				search: $.extend({}, settings.aoPreSearchCols[i])
			};
		} )
	};

	settings.oSavedState = state;
	_fnCallbackFire( settings, "aoStateSaveParams", 'stateSaveParams', [settings, state] );
	
	if ( settings.oFeatures.bStateSave && !settings.bDestroying )
	{
		settings.fnStateSaveCallback.call( settings.oInstance, settings, state );
	}	
}


/**
 * Attempt to load a saved table state
 *  @param {object} oSettings dataTables settings object
 *  @param {object} oInit DataTables init object so we can override settings
 *  @param {function} callback Callback to execute when the state has been loaded
 *  @memberof DataTable#oApi
 */
function _fnLoadState ( settings, init, callback )
{
	if ( ! settings.oFeatures.bStateSave ) {
		callback();
		return;
	}

	var loaded = function(state) {
		_fnImplementState(settings, state, callback);
	}

	var state = settings.fnStateLoadCallback.call( settings.oInstance, settings, loaded );

	if ( state !== undefined ) {
		_fnImplementState( settings, state, callback );
	}
	// otherwise, wait for the loaded callback to be executed

	return true;
}

function _fnImplementState ( settings, s, callback) {
	var i, ien;
	var columns = settings.aoColumns;
	settings._bLoadingState = true;

	// When StateRestore was introduced the state could now be implemented at any time
	// Not just initialisation. To do this an api instance is required in some places
	var api = settings._bInitComplete ? new DataTable.Api(settings) : null;

	if ( ! s || ! s.time ) {
		settings._bLoadingState = false;
		callback();
		return;
	}

	// Reject old data
	var duration = settings.iStateDuration;
	if ( duration > 0 && s.time < +new Date() - (duration*1000) ) {
		settings._bLoadingState = false;
		callback();
		return;
	}

	// Allow custom and plug-in manipulation functions to alter the saved data set and
	// cancelling of loading by returning false
	var abStateLoad = _fnCallbackFire( settings, 'aoStateLoadParams', 'stateLoadParams', [settings, s] );
	if ( abStateLoad.indexOf(false) !== -1 ) {
		settings._bLoadingState = false;
		callback();
		return;
	}

	// Number of columns have changed - all bets are off, no restore of settings
	if ( s.columns && columns.length !== s.columns.length ) {
		settings._bLoadingState = false;
		callback();
		return;
	}

	// Store the saved state so it might be accessed at any time
	settings.oLoadedState = $.extend( true, {}, s );

	// This is needed for ColReorder, which has to happen first to allow all
	// the stored indexes to be usable. It is not publicly documented.
	_fnCallbackFire( settings, null, 'stateLoadInit', [settings, s], true );

	// Page Length
	if ( s.length !== undefined ) {
		// If already initialised just set the value directly so that the select element is also updated
		if (api) {
			api.page.len(s.length)
		}
		else {
			settings._iDisplayLength   = s.length;
		}
	}

	// Restore key features - todo - for 1.11 this needs to be done by
	// subscribed events
	if ( s.start !== undefined ) {
		if(api === null) {
			settings._iDisplayStart    = s.start;
			settings.iInitDisplayStart = s.start;
		}
		else {
			_fnPageChange(settings, s.start/settings._iDisplayLength);
		}
	}

	// Order
	if ( s.order !== undefined ) {
		settings.aaSorting = [];
		$.each( s.order, function ( i, col ) {
			settings.aaSorting.push( col[0] >= columns.length ?
				[ 0, col[1] ] :
				col
			);
		} );
	}

	// Search
	if ( s.search !== undefined ) {
		$.extend( settings.oPreviousSearch, s.search );
	}

	// Columns
	if ( s.columns ) {
		for ( i=0, ien=s.columns.length ; i<ien ; i++ ) {
			var col = s.columns[i];

			// Visibility
			if ( col.visible !== undefined ) {
				// If the api is defined, the table has been initialised so we need to use it rather than internal settings
				if (api) {
					// Don't redraw the columns on every iteration of this loop, we will do this at the end instead
					api.column(i).visible(col.visible, false);
				}
				else {
					columns[i].bVisible = col.visible;
				}
			}

			// Search
			if ( col.search !== undefined ) {
				$.extend( settings.aoPreSearchCols[i], col.search );
			}
		}
		
		// If the api is defined then we need to adjust the columns once the visibility has been changed
		if (api) {
			api.columns.adjust();
		}
	}

	settings._bLoadingState = false;
	_fnCallbackFire( settings, 'aoStateLoaded', 'stateLoaded', [settings, s] );
	callback();
}

/**
 * Log an error message
 *  @param {object} settings dataTables settings object
 *  @param {int} level log error messages, or display them to the user
 *  @param {string} msg error message
 *  @param {int} tn Technical note id to get more information about the error.
 *  @memberof DataTable#oApi
 */
function _fnLog( settings, level, msg, tn )
{
	msg = 'DataTables warning: '+
		(settings ? 'table id='+settings.sTableId+' - ' : '')+msg;

	if ( tn ) {
		msg += '. For more information about this error, please see '+
		'https://datatables.net/tn/'+tn;
	}

	if ( ! level  ) {
		// Backwards compatibility pre 1.10
		var ext = DataTable.ext;
		var type = ext.sErrMode || ext.errMode;

		if ( settings ) {
			_fnCallbackFire( settings, null, 'dt-error', [ settings, tn, msg ], true );
		}

		if ( type == 'alert' ) {
			alert( msg );
		}
		else if ( type == 'throw' ) {
			throw new Error(msg);
		}
		else if ( typeof type == 'function' ) {
			type( settings, tn, msg );
		}
	}
	else if ( window.console && console.log ) {
		console.log( msg );
	}
}


/**
 * See if a property is defined on one object, if so assign it to the other object
 *  @param {object} ret target object
 *  @param {object} src source object
 *  @param {string} name property
 *  @param {string} [mappedName] name to map too - optional, name used if not given
 *  @memberof DataTable#oApi
 */
function _fnMap( ret, src, name, mappedName )
{
	if ( Array.isArray( name ) ) {
		$.each( name, function (i, val) {
			if ( Array.isArray( val ) ) {
				_fnMap( ret, src, val[0], val[1] );
			}
			else {
				_fnMap( ret, src, val );
			}
		} );

		return;
	}

	if ( mappedName === undefined ) {
		mappedName = name;
	}

	if ( src[name] !== undefined ) {
		ret[mappedName] = src[name];
	}
}


/**
 * Extend objects - very similar to jQuery.extend, but deep copy objects, and
 * shallow copy arrays. The reason we need to do this, is that we don't want to
 * deep copy array init values (such as aaSorting) since the dev wouldn't be
 * able to override them, but we do want to deep copy arrays.
 *  @param {object} out Object to extend
 *  @param {object} extender Object from which the properties will be applied to
 *      out
 *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
 *      independent copy with the exception of the `data` or `aaData` parameters
 *      if they are present. This is so you can pass in a collection to
 *      DataTables and have that used as your data source without breaking the
 *      references
 *  @returns {object} out Reference, just for convenience - out === the return.
 *  @memberof DataTable#oApi
 *  @todo This doesn't take account of arrays inside the deep copied objects.
 */
function _fnExtend( out, extender, breakRefs )
{
	var val;

	for ( var prop in extender ) {
		if ( Object.prototype.hasOwnProperty.call(extender, prop) ) {
			val = extender[prop];

			if ( $.isPlainObject( val ) ) {
				if ( ! $.isPlainObject( out[prop] ) ) {
					out[prop] = {};
				}
				$.extend( true, out[prop], val );
			}
			else if ( breakRefs && prop !== 'data' && prop !== 'aaData' && Array.isArray(val) ) {
				out[prop] = val.slice();
			}
			else {
				out[prop] = val;
			}
		}
	}

	return out;
}


/**
 * Bind an event handers to allow a click or return key to activate the callback.
 * This is good for accessibility since a return on the keyboard will have the
 * same effect as a click, if the element has focus.
 *  @param {element} n Element to bind the action to
 *  @param {object|string} selector Selector (for delegated events) or data object
 *   to pass to the triggered function
 *  @param {function} fn Callback function for when the event is triggered
 *  @memberof DataTable#oApi
 */
function _fnBindAction( n, selector, fn )
{
	$(n)
		.on( 'click.DT', selector, function (e) {
			fn(e);
		} )
		.on( 'keypress.DT', selector, function (e){
			if ( e.which === 13 ) {
				e.preventDefault();
				fn(e);
			}
		} )
		.on( 'selectstart.DT', selector, function () {
			// Don't want a double click resulting in text selection
			return false;
		} );
}


/**
 * Register a callback function. Easily allows a callback function to be added to
 * an array store of callback functions that can then all be called together.
 *  @param {object} settings dataTables settings object
 *  @param {string} store Name of the array storage for the callbacks in oSettings
 *  @param {function} fn Function to be called back
 *  @memberof DataTable#oApi
 */
function _fnCallbackReg( settings, store, fn )
{
	if ( fn ) {
		settings[store].push(fn);
	}
}


/**
 * Fire callback functions and trigger events. Note that the loop over the
 * callback array store is done backwards! Further note that you do not want to
 * fire off triggers in time sensitive applications (for example cell creation)
 * as its slow.
 *  @param {object} settings dataTables settings object
 *  @param {string} callbackArr Name of the array storage for the callbacks in
 *      oSettings
 *  @param {string} eventName Name of the jQuery custom event to trigger. If
 *      null no trigger is fired
 *  @param {array} args Array of arguments to pass to the callback function /
 *      trigger
 *  @param {boolean} [bubbles] True if the event should bubble
 *  @memberof DataTable#oApi
 */
function _fnCallbackFire( settings, callbackArr, eventName, args, bubbles )
{
	var ret = [];

	if ( callbackArr ) {
		ret = settings[callbackArr].slice().reverse().map( function (val) {
			return val.apply( settings.oInstance, args );
		} );
	}

	if ( eventName !== null) {
		var e = $.Event( eventName+'.dt' );
		var table = $(settings.nTable);
		
		// Expose the DataTables API on the event object for easy access
		e.dt = settings.api;

		table[bubbles ?  'trigger' : 'triggerHandler']( e, args );

		// If not yet attached to the document, trigger the event
		// on the body directly to sort of simulate the bubble
		if (bubbles && table.parents('body').length === 0) {
			$('body').trigger( e, args );
		}

		ret.push( e.result );
	}

	return ret;
}


function _fnLengthOverflow ( settings )
{
	var
		start = settings._iDisplayStart,
		end = settings.fnDisplayEnd(),
		len = settings._iDisplayLength;

	/* If we have space to show extra rows (backing up from the end point - then do so */
	if ( start >= end )
	{
		start = end - len;
	}

	// Keep the start record on the current page
	start -= (start % len);

	if ( len === -1 || start < 0 )
	{
		start = 0;
	}

	settings._iDisplayStart = start;
}


function _fnRenderer( settings, type )
{
	var renderer = settings.renderer;
	var host = DataTable.ext.renderer[type];

	if ( $.isPlainObject( renderer ) && renderer[type] ) {
		// Specific renderer for this type. If available use it, otherwise use
		// the default.
		return host[renderer[type]] || host._;
	}
	else if ( typeof renderer === 'string' ) {
		// Common renderer - if there is one available for this type use it,
		// otherwise use the default
		return host[renderer] || host._;
	}

	// Use the default
	return host._;
}


/**
 * Detect the data source being used for the table. Used to simplify the code
 * a little (ajax) and to make it compress a little smaller.
 *
 *  @param {object} settings dataTables settings object
 *  @returns {string} Data source
 *  @memberof DataTable#oApi
 */
function _fnDataSource ( settings )
{
	if ( settings.oFeatures.bServerSide ) {
		return 'ssp';
	}
	else if ( settings.ajax ) {
		return 'ajax';
	}
	return 'dom';
}

/**
 * Common replacement for language strings
 *
 * @param {*} settings DT settings object
 * @param {*} str String with values to replace
 * @param {*} entries Plural number for _ENTRIES_ - can be undefined
 * @returns String
 */
function _fnMacros ( settings, str, entries )
{
	// When infinite scrolling, we are always starting at 1. _iDisplayStart is
	// used only internally
	var
		formatter  = settings.fnFormatNumber,
		start      = settings._iDisplayStart+1,
		len        = settings._iDisplayLength,
		vis        = settings.fnRecordsDisplay(),
		max        = settings.fnRecordsTotal(),
		all        = len === -1;

	return str.
		replace(/_START_/g, formatter.call( settings, start ) ).
		replace(/_END_/g,   formatter.call( settings, settings.fnDisplayEnd() ) ).
		replace(/_MAX_/g,   formatter.call( settings, max ) ).
		replace(/_TOTAL_/g, formatter.call( settings, vis ) ).
		replace(/_PAGE_/g,  formatter.call( settings, all ? 1 : Math.ceil( start / len ) ) ).
		replace(/_PAGES_/g, formatter.call( settings, all ? 1 : Math.ceil( vis / len ) ) ).
		replace(/_ENTRIES_/g, settings.api.i18n('entries', '', entries) ).
		replace(/_ENTRIES-MAX_/g, settings.api.i18n('entries', '', max) ).
		replace(/_ENTRIES-TOTAL_/g, settings.api.i18n('entries', '', vis) );
}



/**
 * Computed structure of the DataTables API, defined by the options passed to
 * `DataTable.Api.register()` when building the API.
 *
 * The structure is built in order to speed creation and extension of the Api
 * objects since the extensions are effectively pre-parsed.
 *
 * The array is an array of objects with the following structure, where this
 * base array represents the Api prototype base:
 *
 *     [
 *       {
 *         name:      'data'                -- string   - Property name
 *         val:       function () {},       -- function - Api method (or undefined if just an object
 *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
 *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
 *       },
 *       {
 *         name:     'row'
 *         val:       {},
 *         methodExt: [ ... ],
 *         propExt:   [
 *           {
 *             name:      'data'
 *             val:       function () {},
 *             methodExt: [ ... ],
 *             propExt:   [ ... ]
 *           },
 *           ...
 *         ]
 *       }
 *     ]
 *
 * @type {Array}
 * @ignore
 */
var __apiStruct = [];


/**
 * `Array.prototype` reference.
 *
 * @type object
 * @ignore
 */
var __arrayProto = Array.prototype;


/**
 * Abstraction for `context` parameter of the `Api` constructor to allow it to
 * take several different forms for ease of use.
 *
 * Each of the input parameter types will be converted to a DataTables settings
 * object where possible.
 *
 * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
 *   of:
 *
 *   * `string` - jQuery selector. Any DataTables' matching the given selector
 *     with be found and used.
 *   * `node` - `TABLE` node which has already been formed into a DataTable.
 *   * `jQuery` - A jQuery object of `TABLE` nodes.
 *   * `object` - DataTables settings object
 *   * `DataTables.Api` - API instance
 * @return {array|null} Matching DataTables settings objects. `null` or
 *   `undefined` is returned if no matching DataTable is found.
 * @ignore
 */
var _toSettings = function ( mixed )
{
	var idx, jq;
	var settings = DataTable.settings;
	var tables = _pluck(settings, 'nTable');

	if ( ! mixed ) {
		return [];
	}
	else if ( mixed.nTable && mixed.oFeatures ) {
		// DataTables settings object
		return [ mixed ];
	}
	else if ( mixed.nodeName && mixed.nodeName.toLowerCase() === 'table' ) {
		// Table node
		idx = tables.indexOf(mixed);
		return idx !== -1 ? [ settings[idx] ] : null;
	}
	else if ( mixed && typeof mixed.settings === 'function' ) {
		return mixed.settings().toArray();
	}
	else if ( typeof mixed === 'string' ) {
		// jQuery selector
		jq = $(mixed).get();
	}
	else if ( mixed instanceof $ ) {
		// jQuery object (also DataTables instance)
		jq = mixed.get();
	}

	if ( jq ) {
		return settings.filter(function (v, idx) {
			return jq.includes(tables[idx]);
		});
	}
};


/**
 * DataTables API class - used to control and interface with  one or more
 * DataTables enhanced tables.
 *
 * The API class is heavily based on jQuery, presenting a chainable interface
 * that you can use to interact with tables. Each instance of the API class has
 * a "context" - i.e. the tables that it will operate on. This could be a single
 * table, all tables on a page or a sub-set thereof.
 *
 * Additionally the API is designed to allow you to easily work with the data in
 * the tables, retrieving and manipulating it as required. This is done by
 * presenting the API class as an array like interface. The contents of the
 * array depend upon the actions requested by each method (for example
 * `rows().nodes()` will return an array of nodes, while `rows().data()` will
 * return an array of objects or arrays depending upon your table's
 * configuration). The API object has a number of array like methods (`push`,
 * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
 * `unique` etc) to assist your working with the data held in a table.
 *
 * Most methods (those which return an Api instance) are chainable, which means
 * the return from a method call also has all of the methods available that the
 * top level object had. For example, these two calls are equivalent:
 *
 *     // Not chained
 *     api.row.add( {...} );
 *     api.draw();
 *
 *     // Chained
 *     api.row.add( {...} ).draw();
 *
 * @class DataTable.Api
 * @param {array|object|string|jQuery} context DataTable identifier. This is
 *   used to define which DataTables enhanced tables this API will operate on.
 *   Can be one of:
 *
 *   * `string` - jQuery selector. Any DataTables' matching the given selector
 *     with be found and used.
 *   * `node` - `TABLE` node which has already been formed into a DataTable.
 *   * `jQuery` - A jQuery object of `TABLE` nodes.
 *   * `object` - DataTables settings object
 * @param {array} [data] Data to initialise the Api instance with.
 *
 * @example
 *   // Direct initialisation during DataTables construction
 *   var api = $('#example').DataTable();
 *
 * @example
 *   // Initialisation using a DataTables jQuery object
 *   var api = $('#example').dataTable().api();
 *
 * @example
 *   // Initialisation as a constructor
 *   var api = new DataTable.Api( 'table.dataTable' );
 */
_Api = function ( context, data )
{
	if ( ! (this instanceof _Api) ) {
		return new _Api( context, data );
	}

	var settings = [];
	var ctxSettings = function ( o ) {
		var a = _toSettings( o );
		if ( a ) {
			settings.push.apply( settings, a );
		}
	};

	if ( Array.isArray( context ) ) {
		for ( var i=0, ien=context.length ; i<ien ; i++ ) {
			ctxSettings( context[i] );
		}
	}
	else {
		ctxSettings( context );
	}

	// Remove duplicates
	this.context = settings.length > 1
		? _unique( settings )
		: settings;

	// Initial data
	if ( data ) {
		this.push.apply(this, data);
	}

	// selector
	this.selector = {
		rows: null,
		cols: null,
		opts: null
	};

	_Api.extend( this, this, __apiStruct );
};

DataTable.Api = _Api;

// Don't destroy the existing prototype, just extend it. Required for jQuery 2's
// isPlainObject.
$.extend( _Api.prototype, {
	any: function ()
	{
		return this.count() !== 0;
	},

	context: [], // array of table settings objects

	count: function ()
	{
		return this.flatten().length;
	},

	each: function ( fn )
	{
		for ( var i=0, ien=this.length ; i<ien; i++ ) {
			fn.call( this, this[i], i, this );
		}

		return this;
	},

	eq: function ( idx )
	{
		var ctx = this.context;

		return ctx.length > idx ?
			new _Api( ctx[idx], this[idx] ) :
			null;
	},

	filter: function ( fn )
	{
		var a = __arrayProto.filter.call( this, fn, this );

		return new _Api( this.context, a );
	},

	flatten: function ()
	{
		var a = [];

		return new _Api( this.context, a.concat.apply( a, this.toArray() ) );
	},

	get: function ( idx )
	{
		return this[ idx ];
	},

	join:    __arrayProto.join,

	includes: function ( find ) {
		return this.indexOf( find ) === -1 ? false : true;
	},

	indexOf: __arrayProto.indexOf,

	iterator: function ( flatten, type, fn, alwaysNew ) {
		var
			a = [], ret,
			i, ien, j, jen,
			context = this.context,
			rows, items, item,
			selector = this.selector;

		// Argument shifting
		if ( typeof flatten === 'string' ) {
			alwaysNew = fn;
			fn = type;
			type = flatten;
			flatten = false;
		}

		for ( i=0, ien=context.length ; i<ien ; i++ ) {
			var apiInst = new _Api( context[i] );

			if ( type === 'table' ) {
				ret = fn.call( apiInst, context[i], i );

				if ( ret !== undefined ) {
					a.push( ret );
				}
			}
			else if ( type === 'columns' || type === 'rows' ) {
				// this has same length as context - one entry for each table
				ret = fn.call( apiInst, context[i], this[i], i );

				if ( ret !== undefined ) {
					a.push( ret );
				}
			}
			else if ( type === 'every' || type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell' ) {
				// columns and rows share the same structure.
				// 'this' is an array of column indexes for each context
				items = this[i];

				if ( type === 'column-rows' ) {
					rows = _selector_row_indexes( context[i], selector.opts );
				}

				for ( j=0, jen=items.length ; j<jen ; j++ ) {
					item = items[j];

					if ( type === 'cell' ) {
						ret = fn.call( apiInst, context[i], item.row, item.column, i, j );
					}
					else {
						ret = fn.call( apiInst, context[i], item, i, j, rows );
					}

					if ( ret !== undefined ) {
						a.push( ret );
					}
				}
			}
		}

		if ( a.length || alwaysNew ) {
			var api = new _Api( context, flatten ? a.concat.apply( [], a ) : a );
			var apiSelector = api.selector;
			apiSelector.rows = selector.rows;
			apiSelector.cols = selector.cols;
			apiSelector.opts = selector.opts;
			return api;
		}
		return this;
	},

	lastIndexOf: __arrayProto.lastIndexOf,

	length:  0,

	map: function ( fn )
	{
		var a = __arrayProto.map.call( this, fn, this );

		return new _Api( this.context, a );
	},

	pluck: function ( prop )
	{
		var fn = DataTable.util.get(prop);

		return this.map( function ( el ) {
			return fn(el);
		} );
	},

	pop:     __arrayProto.pop,

	push:    __arrayProto.push,

	reduce: __arrayProto.reduce,

	reduceRight: __arrayProto.reduceRight,

	reverse: __arrayProto.reverse,

	// Object with rows, columns and opts
	selector: null,

	shift:   __arrayProto.shift,

	slice: function () {
		return new _Api( this.context, this );
	},

	sort:    __arrayProto.sort,

	splice:  __arrayProto.splice,

	toArray: function ()
	{
		return __arrayProto.slice.call( this );
	},

	to$: function ()
	{
		return $( this );
	},

	toJQuery: function ()
	{
		return $( this );
	},

	unique: function ()
	{
		return new _Api( this.context, _unique(this.toArray()) );
	},

	unshift: __arrayProto.unshift
} );


function _api_scope( scope, fn, struc ) {
	return function () {
		var ret = fn.apply( scope || this, arguments );

		// Method extension
		_Api.extend( ret, ret, struc.methodExt );
		return ret;
	};
}

function _api_find( src, name ) {
	for ( var i=0, ien=src.length ; i<ien ; i++ ) {
		if ( src[i].name === name ) {
			return src[i];
		}
	}
	return null;
}

window.__apiStruct = __apiStruct;

_Api.extend = function ( scope, obj, ext )
{
	// Only extend API instances and static properties of the API
	if ( ! ext.length || ! obj || ( ! (obj instanceof _Api) && ! obj.__dt_wrapper ) ) {
		return;
	}

	var
		i, ien,
		struct;

	for ( i=0, ien=ext.length ; i<ien ; i++ ) {
		struct = ext[i];

		if (struct.name === '__proto__') {
			continue;
		}

		// Value
		obj[ struct.name ] = struct.type === 'function' ?
			_api_scope( scope, struct.val, struct ) :
			struct.type === 'object' ?
				{} :
				struct.val;

		obj[ struct.name ].__dt_wrapper = true;

		// Property extension
		_Api.extend( scope, obj[ struct.name ], struct.propExt );
	}
};

//     [
//       {
//         name:      'data'                -- string   - Property name
//         val:       function () {},       -- function - Api method (or undefined if just an object
//         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
//         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
//       },
//       {
//         name:     'row'
//         val:       {},
//         methodExt: [ ... ],
//         propExt:   [
//           {
//             name:      'data'
//             val:       function () {},
//             methodExt: [ ... ],
//             propExt:   [ ... ]
//           },
//           ...
//         ]
//       }
//     ]


_Api.register = _api_register = function ( name, val )
{
	if ( Array.isArray( name ) ) {
		for ( var j=0, jen=name.length ; j<jen ; j++ ) {
			_Api.register( name[j], val );
		}
		return;
	}

	var
		i, ien,
		heir = name.split('.'),
		struct = __apiStruct,
		key, method;

	for ( i=0, ien=heir.length ; i<ien ; i++ ) {
		method = heir[i].indexOf('()') !== -1;
		key = method ?
			heir[i].replace('()', '') :
			heir[i];

		var src = _api_find( struct, key );
		if ( ! src ) {
			src = {
				name:      key,
				val:       {},
				methodExt: [],
				propExt:   [],
				type:      'object'
			};
			struct.push( src );
		}

		if ( i === ien-1 ) {
			src.val = val;
			src.type = typeof val === 'function' ?
				'function' :
				$.isPlainObject( val ) ?
					'object' :
					'other';
		}
		else {
			struct = method ?
				src.methodExt :
				src.propExt;
		}
	}
};

_Api.registerPlural = _api_registerPlural = function ( pluralName, singularName, val ) {
	_Api.register( pluralName, val );

	_Api.register( singularName, function () {
		var ret = val.apply( this, arguments );

		if ( ret === this ) {
			// Returned item is the API instance that was passed in, return it
			return this;
		}
		else if ( ret instanceof _Api ) {
			// New API instance returned, want the value from the first item
			// in the returned array for the singular result.
			return ret.length ?
				Array.isArray( ret[0] ) ?
					new _Api( ret.context, ret[0] ) : // Array results are 'enhanced'
					ret[0] :
				undefined;
		}

		// Non-API return - just fire it back
		return ret;
	} );
};


/**
 * Selector for HTML tables. Apply the given selector to the give array of
 * DataTables settings objects.
 *
 * @param {string|integer} [selector] jQuery selector string or integer
 * @param  {array} Array of DataTables settings objects to be filtered
 * @return {array}
 * @ignore
 */
var __table_selector = function ( selector, a )
{
	if ( Array.isArray(selector) ) {
		var result = [];

		selector.forEach(function (sel) {
			var inner = __table_selector(sel, a);

			result.push.apply(result, inner);
		});

		return result.filter( function (item) {
			return item;
		});
	}

	// Integer is used to pick out a table by index
	if ( typeof selector === 'number' ) {
		return [ a[ selector ] ];
	}

	// Perform a jQuery selector on the table nodes
	var nodes = a.map( function (el) {
		return el.nTable;
	} );

	return $(nodes)
		.filter( selector )
		.map( function () {
			// Need to translate back from the table node to the settings
			var idx = nodes.indexOf(this);
			return a[ idx ];
		} )
		.toArray();
};



/**
 * Context selector for the API's context (i.e. the tables the API instance
 * refers to.
 *
 * @name    DataTable.Api#tables
 * @param {string|integer} [selector] Selector to pick which tables the iterator
 *   should operate on. If not given, all tables in the current context are
 *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
 *   select multiple tables or as an integer to select a single table.
 * @returns {DataTable.Api} Returns a new API instance if a selector is given.
 */
_api_register( 'tables()', function ( selector ) {
	// A new instance is created if there was a selector specified
	return selector !== undefined && selector !== null ?
		new _Api( __table_selector( selector, this.context ) ) :
		this;
} );


_api_register( 'table()', function ( selector ) {
	var tables = this.tables( selector );
	var ctx = tables.context;

	// Truncate to the first matched table
	return ctx.length ?
		new _Api( ctx[0] ) :
		tables;
} );

// Common methods, combined to reduce size
[
	['nodes', 'node', 'nTable'],
	['body', 'body', 'nTBody'],
	['header', 'header', 'nTHead'],
	['footer', 'footer', 'nTFoot'],
].forEach(function (item) {
	_api_registerPlural(
		'tables().' + item[0] + '()',
		'table().' + item[1] + '()' ,
		function () {
			return this.iterator( 'table', function ( ctx ) {
				return ctx[item[2]];
			}, 1 );
		}
	);
});

// Structure methods
[
	['header', 'aoHeader'],
	['footer', 'aoFooter'],
].forEach(function (item) {
	_api_register( 'table().' + item[0] + '.structure()' , function (selector) {
		var indexes = this.columns(selector).indexes().flatten();
		var ctx = this.context[0];
		
		return _fnHeaderLayout(ctx, ctx[item[1]], indexes);
	} );
})


_api_registerPlural( 'tables().containers()', 'table().container()' , function () {
	return this.iterator( 'table', function ( ctx ) {
		return ctx.nTableWrapper;
	}, 1 );
} );

_api_register( 'tables().every()', function ( fn ) {
	var that = this;

	return this.iterator('table', function (s, i) {
		fn.call(that.table(i), i);
	});
});

_api_register( 'caption()', function ( value, side ) {
	var context = this.context;

	// Getter - return existing node's content
	if ( value === undefined ) {
		var caption = context[0].captionNode;

		return caption && context.length ?
			caption.innerHTML : 
			null;
	}

	return this.iterator( 'table', function ( ctx ) {
		var table = $(ctx.nTable);
		var caption = $(ctx.captionNode);
		var container = $(ctx.nTableWrapper);

		// Create the node if it doesn't exist yet
		if ( ! caption.length ) {
			caption = $('<caption/>').html( value );
			ctx.captionNode = caption[0];

			// If side isn't set, we need to insert into the document to let the
			// CSS decide so we can read it back, otherwise there is no way to
			// know if the CSS would put it top or bottom for scrolling
			if (! side) {
				table.prepend(caption);

				side = caption.css('caption-side');
			}
		}

		caption.html( value );

		if ( side ) {
			caption.css( 'caption-side', side );
			caption[0]._captionSide = side;
		}

		if (container.find('div.dataTables_scroll').length) {
			var selector = (side === 'top' ? 'Head' : 'Foot');

			container.find('div.dataTables_scroll'+ selector +' table').prepend(caption);
		}
		else {
			table.prepend(caption);
		}
	}, 1 );
} );

_api_register( 'caption.node()', function () {
	var ctx = this.context;

	return ctx.length ? ctx[0].captionNode : null;
} );


/**
 * Redraw the tables in the current context.
 */
_api_register( 'draw()', function ( paging ) {
	return this.iterator( 'table', function ( settings ) {
		if ( paging === 'page' ) {
			_fnDraw( settings );
		}
		else {
			if ( typeof paging === 'string' ) {
				paging = paging === 'full-hold' ?
					false :
					true;
			}

			_fnReDraw( settings, paging===false );
		}
	} );
} );



/**
 * Get the current page index.
 *
 * @return {integer} Current page index (zero based)
 *//**
 * Set the current page.
 *
 * Note that if you attempt to show a page which does not exist, DataTables will
 * not throw an error, but rather reset the paging.
 *
 * @param {integer|string} action The paging action to take. This can be one of:
 *  * `integer` - The page index to jump to
 *  * `string` - An action to take:
 *    * `first` - Jump to first page.
 *    * `next` - Jump to the next page
 *    * `previous` - Jump to previous page
 *    * `last` - Jump to the last page.
 * @returns {DataTables.Api} this
 */
_api_register( 'page()', function ( action ) {
	if ( action === undefined ) {
		return this.page.info().page; // not an expensive call
	}

	// else, have an action to take on all tables
	return this.iterator( 'table', function ( settings ) {
		_fnPageChange( settings, action );
	} );
} );


/**
 * Paging information for the first table in the current context.
 *
 * If you require paging information for another table, use the `table()` method
 * with a suitable selector.
 *
 * @return {object} Object with the following properties set:
 *  * `page` - Current page index (zero based - i.e. the first page is `0`)
 *  * `pages` - Total number of pages
 *  * `start` - Display index for the first record shown on the current page
 *  * `end` - Display index for the last record shown on the current page
 *  * `length` - Display length (number of records). Note that generally `start
 *    + length = end`, but this is not always true, for example if there are
 *    only 2 records to show on the final page, with a length of 10.
 *  * `recordsTotal` - Full data set length
 *  * `recordsDisplay` - Data set length once the current filtering criterion
 *    are applied.
 */
_api_register( 'page.info()', function () {
	if ( this.context.length === 0 ) {
		return undefined;
	}

	var
		settings   = this.context[0],
		start      = settings._iDisplayStart,
		len        = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,
		visRecords = settings.fnRecordsDisplay(),
		all        = len === -1;

	return {
		"page":           all ? 0 : Math.floor( start / len ),
		"pages":          all ? 1 : Math.ceil( visRecords / len ),
		"start":          start,
		"end":            settings.fnDisplayEnd(),
		"length":         len,
		"recordsTotal":   settings.fnRecordsTotal(),
		"recordsDisplay": visRecords,
		"serverSide":     _fnDataSource( settings ) === 'ssp'
	};
} );


/**
 * Get the current page length.
 *
 * @return {integer} Current page length. Note `-1` indicates that all records
 *   are to be shown.
 *//**
 * Set the current page length.
 *
 * @param {integer} Page length to set. Use `-1` to show all records.
 * @returns {DataTables.Api} this
 */
_api_register( 'page.len()', function ( len ) {
	// Note that we can't call this function 'length()' because `length`
	// is a Javascript property of functions which defines how many arguments
	// the function expects.
	if ( len === undefined ) {
		return this.context.length !== 0 ?
			this.context[0]._iDisplayLength :
			undefined;
	}

	// else, set the page length
	return this.iterator( 'table', function ( settings ) {
		_fnLengthChange( settings, len );
	} );
} );



var __reload = function ( settings, holdPosition, callback ) {
	// Use the draw event to trigger a callback
	if ( callback ) {
		var api = new _Api( settings );

		api.one( 'draw', function () {
			callback( api.ajax.json() );
		} );
	}

	if ( _fnDataSource( settings ) == 'ssp' ) {
		_fnReDraw( settings, holdPosition );
	}
	else {
		_fnProcessingDisplay( settings, true );

		// Cancel an existing request
		var xhr = settings.jqXHR;
		if ( xhr && xhr.readyState !== 4 ) {
			xhr.abort();
		}

		// Trigger xhr
		_fnBuildAjax( settings, {}, function( json ) {
			_fnClearTable( settings );

			var data = _fnAjaxDataSrc( settings, json );
			for ( var i=0, ien=data.length ; i<ien ; i++ ) {
				_fnAddData( settings, data[i] );
			}

			_fnReDraw( settings, holdPosition );
			_fnInitComplete( settings );
			_fnProcessingDisplay( settings, false );
		} );
	}
};


/**
 * Get the JSON response from the last Ajax request that DataTables made to the
 * server. Note that this returns the JSON from the first table in the current
 * context.
 *
 * @return {object} JSON received from the server.
 */
_api_register( 'ajax.json()', function () {
	var ctx = this.context;

	if ( ctx.length > 0 ) {
		return ctx[0].json;
	}

	// else return undefined;
} );


/**
 * Get the data submitted in the last Ajax request
 */
_api_register( 'ajax.params()', function () {
	var ctx = this.context;

	if ( ctx.length > 0 ) {
		return ctx[0].oAjaxData;
	}

	// else return undefined;
} );


/**
 * Reload tables from the Ajax data source. Note that this function will
 * automatically re-draw the table when the remote data has been loaded.
 *
 * @param {boolean} [reset=true] Reset (default) or hold the current paging
 *   position. A full re-sort and re-filter is performed when this method is
 *   called, which is why the pagination reset is the default action.
 * @returns {DataTables.Api} this
 */
_api_register( 'ajax.reload()', function ( callback, resetPaging ) {
	return this.iterator( 'table', function (settings) {
		__reload( settings, resetPaging===false, callback );
	} );
} );


/**
 * Get the current Ajax URL. Note that this returns the URL from the first
 * table in the current context.
 *
 * @return {string} Current Ajax source URL
 *//**
 * Set the Ajax URL. Note that this will set the URL for all tables in the
 * current context.
 *
 * @param {string} url URL to set.
 * @returns {DataTables.Api} this
 */
_api_register( 'ajax.url()', function ( url ) {
	var ctx = this.context;

	if ( url === undefined ) {
		// get
		if ( ctx.length === 0 ) {
			return undefined;
		}
		ctx = ctx[0];

		return $.isPlainObject( ctx.ajax ) ?
			ctx.ajax.url :
			ctx.ajax;
	}

	// set
	return this.iterator( 'table', function ( settings ) {
		if ( $.isPlainObject( settings.ajax ) ) {
			settings.ajax.url = url;
		}
		else {
			settings.ajax = url;
		}
	} );
} );


/**
 * Load data from the newly set Ajax URL. Note that this method is only
 * available when `ajax.url()` is used to set a URL. Additionally, this method
 * has the same effect as calling `ajax.reload()` but is provided for
 * convenience when setting a new URL. Like `ajax.reload()` it will
 * automatically redraw the table once the remote data has been loaded.
 *
 * @returns {DataTables.Api} this
 */
_api_register( 'ajax.url().load()', function ( callback, resetPaging ) {
	// Same as a reload, but makes sense to present it for easy access after a
	// url change
	return this.iterator( 'table', function ( ctx ) {
		__reload( ctx, resetPaging===false, callback );
	} );
} );




var _selector_run = function ( type, selector, selectFn, settings, opts )
{
	var
		out = [], res,
		a, i, ien, j, jen,
		selectorType = typeof selector;

	// Can't just check for isArray here, as an API or jQuery instance might be
	// given with their array like look
	if ( ! selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined ) {
		selector = [ selector ];
	}

	for ( i=0, ien=selector.length ; i<ien ; i++ ) {
		// Only split on simple strings - complex expressions will be jQuery selectors
		a = selector[i] && selector[i].split && ! selector[i].match(/[[(:]/) ?
			selector[i].split(',') :
			[ selector[i] ];

		for ( j=0, jen=a.length ; j<jen ; j++ ) {
			res = selectFn( typeof a[j] === 'string' ? (a[j]).trim() : a[j] );

			// Remove empty items
			res = res.filter( function (item) {
				return item !== null && item !== undefined;
			});

			if ( res && res.length ) {
				out = out.concat( res );
			}
		}
	}

	// selector extensions
	var ext = _ext.selector[ type ];
	if ( ext.length ) {
		for ( i=0, ien=ext.length ; i<ien ; i++ ) {
			out = ext[i]( settings, opts, out );
		}
	}

	return _unique( out );
};


var _selector_opts = function ( opts )
{
	if ( ! opts ) {
		opts = {};
	}

	// Backwards compatibility for 1.9- which used the terminology filter rather
	// than search
	if ( opts.filter && opts.search === undefined ) {
		opts.search = opts.filter;
	}

	return $.extend( {
		search: 'none',
		order: 'current',
		page: 'all'
	}, opts );
};


// Reduce the API instance to the first item found
var _selector_first = function ( old )
{
	let inst = new _Api(old.context[0]);

	// Use a push rather than passing to the constructor, since it will
	// merge arrays down automatically, which isn't what is wanted here
	if (old.length) {
		inst.push( old[0] );
	}

	inst.selector = old.selector;

	// Limit to a single row / column / cell
	if (inst.length && inst[0].length > 1) {
		inst[0].splice(1);
	}

	return inst;
};


var _selector_row_indexes = function ( settings, opts )
{
	var
		i, ien, tmp, a=[],
		displayFiltered = settings.aiDisplay,
		displayMaster = settings.aiDisplayMaster;

	var
		search = opts.search,  // none, applied, removed
		order  = opts.order,   // applied, current, index (original - compatibility with 1.9)
		page   = opts.page;    // all, current

	if ( _fnDataSource( settings ) == 'ssp' ) {
		// In server-side processing mode, most options are irrelevant since
		// rows not shown don't exist and the index order is the applied order
		// Removed is a special case - for consistency just return an empty
		// array
		return search === 'removed' ?
			[] :
			_range( 0, displayMaster.length );
	}

	if ( page == 'current' ) {
		// Current page implies that order=current and filter=applied, since it is
		// fairly senseless otherwise, regardless of what order and search actually
		// are
		for ( i=settings._iDisplayStart, ien=settings.fnDisplayEnd() ; i<ien ; i++ ) {
			a.push( displayFiltered[i] );
		}
	}
	else if ( order == 'current' || order == 'applied' ) {
		if ( search == 'none') {
			a = displayMaster.slice();
		}
		else if ( search == 'applied' ) {
			a = displayFiltered.slice();
		}
		else if ( search == 'removed' ) {
			// O(n+m) solution by creating a hash map
			var displayFilteredMap = {};

			for ( i=0, ien=displayFiltered.length ; i<ien ; i++ ) {
				displayFilteredMap[displayFiltered[i]] = null;
			}

			displayMaster.forEach(function (item) {
				if (! Object.prototype.hasOwnProperty.call(displayFilteredMap, item)) {
					a.push(item);
				}
			});
		}
	}
	else if ( order == 'index' || order == 'original' ) {
		for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
			if (! settings.aoData[i]) {
				continue;
			}

			if ( search == 'none' ) {
				a.push( i );
			}
			else { // applied | removed
				tmp = displayFiltered.indexOf(i);

				if ((tmp === -1 && search == 'removed') ||
					(tmp >= 0   && search == 'applied') )
				{
					a.push( i );
				}
			}
		}
	}
	else if ( typeof order === 'number' ) {
		// Order the rows by the given column
		var ordered = _fnSort(settings, order, 'asc');

		if (search === 'none') {
			a = ordered;
		}
		else { // applied | removed
			for (i=0; i<ordered.length; i++) {
				tmp = displayFiltered.indexOf(ordered[i]);

				if ((tmp === -1 && search == 'removed') ||
					(tmp >= 0   && search == 'applied') )
				{
					a.push( ordered[i] );
				}
			}
		}
	}

	return a;
};


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Rows
 *
 * {}          - no selector - use all available rows
 * {integer}   - row aoData index
 * {node}      - TR node
 * {string}    - jQuery selector to apply to the TR elements
 * {array}     - jQuery array of nodes, or simply an array of TR nodes
 *
 */
var __row_selector = function ( settings, selector, opts )
{
	var rows;
	var run = function ( sel ) {
		var selInt = _intVal( sel );
		var aoData = settings.aoData;

		// Short cut - selector is a number and no options provided (default is
		// all records, so no need to check if the index is in there, since it
		// must be - dev error if the index doesn't exist).
		if ( selInt !== null && ! opts ) {
			return [ selInt ];
		}

		if ( ! rows ) {
			rows = _selector_row_indexes( settings, opts );
		}

		if ( selInt !== null && rows.indexOf(selInt) !== -1 ) {
			// Selector - integer
			return [ selInt ];
		}
		else if ( sel === null || sel === undefined || sel === '' ) {
			// Selector - none
			return rows;
		}

		// Selector - function
		if ( typeof sel === 'function' ) {
			return rows.map( function (idx) {
				var row = aoData[ idx ];
				return sel( idx, row._aData, row.nTr ) ? idx : null;
			} );
		}

		// Selector - node
		if ( sel.nodeName ) {
			var rowIdx = sel._DT_RowIndex;  // Property added by DT for fast lookup
			var cellIdx = sel._DT_CellIndex;

			if ( rowIdx !== undefined ) {
				// Make sure that the row is actually still present in the table
				return aoData[ rowIdx ] && aoData[ rowIdx ].nTr === sel ?
					[ rowIdx ] :
					[];
			}
			else if ( cellIdx ) {
				return aoData[ cellIdx.row ] && aoData[ cellIdx.row ].nTr === sel.parentNode ?
					[ cellIdx.row ] :
					[];
			}
			else {
				var host = $(sel).closest('*[data-dt-row]');
				return host.length ?
					[ host.data('dt-row') ] :
					[];
			}
		}

		// ID selector. Want to always be able to select rows by id, regardless
		// of if the tr element has been created or not, so can't rely upon
		// jQuery here - hence a custom implementation. This does not match
		// Sizzle's fast selector or HTML4 - in HTML5 the ID can be anything,
		// but to select it using a CSS selector engine (like Sizzle or
		// querySelect) it would need to need to be escaped for some characters.
		// DataTables simplifies this for row selectors since you can select
		// only a row. A # indicates an id any anything that follows is the id -
		// unescaped.
		if ( typeof sel === 'string' && sel.charAt(0) === '#' ) {
			// get row index from id
			var rowObj = settings.aIds[ sel.replace( /^#/, '' ) ];
			if ( rowObj !== undefined ) {
				return [ rowObj.idx ];
			}

			// need to fall through to jQuery in case there is DOM id that
			// matches
		}
		
		// Get nodes in the order from the `rows` array with null values removed
		var nodes = _removeEmpty(
			_pluck_order( settings.aoData, rows, 'nTr' )
		);

		// Selector - jQuery selector string, array of nodes or jQuery object/
		// As jQuery's .filter() allows jQuery objects to be passed in filter,
		// it also allows arrays, so this will cope with all three options
		return $(nodes)
			.filter( sel )
			.map( function () {
				return this._DT_RowIndex;
			} )
			.toArray();
	};

	var matched = _selector_run( 'row', selector, run, settings, opts );

	if (opts.order === 'current' || opts.order === 'applied') {
		_fnSortDisplay(settings, matched);
	}

	return matched;
};


_api_register( 'rows()', function ( selector, opts ) {
	// argument shifting
	if ( selector === undefined ) {
		selector = '';
	}
	else if ( $.isPlainObject( selector ) ) {
		opts = selector;
		selector = '';
	}

	opts = _selector_opts( opts );

	var inst = this.iterator( 'table', function ( settings ) {
		return __row_selector( settings, selector, opts );
	}, 1 );

	// Want argument shifting here and in __row_selector?
	inst.selector.rows = selector;
	inst.selector.opts = opts;

	return inst;
} );

_api_register( 'rows().nodes()', function () {
	return this.iterator( 'row', function ( settings, row ) {
		return settings.aoData[ row ].nTr || undefined;
	}, 1 );
} );

_api_register( 'rows().data()', function () {
	return this.iterator( true, 'rows', function ( settings, rows ) {
		return _pluck_order( settings.aoData, rows, '_aData' );
	}, 1 );
} );

_api_registerPlural( 'rows().cache()', 'row().cache()', function ( type ) {
	return this.iterator( 'row', function ( settings, row ) {
		var r = settings.aoData[ row ];
		return type === 'search' ? r._aFilterData : r._aSortData;
	}, 1 );
} );

_api_registerPlural( 'rows().invalidate()', 'row().invalidate()', function ( src ) {
	return this.iterator( 'row', function ( settings, row ) {
		_fnInvalidate( settings, row, src );
	} );
} );

_api_registerPlural( 'rows().indexes()', 'row().index()', function () {
	return this.iterator( 'row', function ( settings, row ) {
		return row;
	}, 1 );
} );

_api_registerPlural( 'rows().ids()', 'row().id()', function ( hash ) {
	var a = [];
	var context = this.context;

	// `iterator` will drop undefined values, but in this case we want them
	for ( var i=0, ien=context.length ; i<ien ; i++ ) {
		for ( var j=0, jen=this[i].length ; j<jen ; j++ ) {
			var id = context[i].rowIdFn( context[i].aoData[ this[i][j] ]._aData );
			a.push( (hash === true ? '#' : '' )+ id );
		}
	}

	return new _Api( context, a );
} );

_api_registerPlural( 'rows().remove()', 'row().remove()', function () {
	this.iterator( 'row', function ( settings, row ) {
		var data = settings.aoData;
		var rowData = data[ row ];

		// Delete from the display arrays
		var idx = settings.aiDisplayMaster.indexOf(row);
		if (idx !== -1) {
			settings.aiDisplayMaster.splice(idx, 1);
		}

		// For server-side processing tables - subtract the deleted row from the count
		if ( settings._iRecordsDisplay > 0 ) {
			settings._iRecordsDisplay--;
		}

		// Check for an 'overflow' they case for displaying the table
		_fnLengthOverflow( settings );

		// Remove the row's ID reference if there is one
		var id = settings.rowIdFn( rowData._aData );
		if ( id !== undefined ) {
			delete settings.aIds[ id ];
		}

		data[row] = null;
	} );

	return this;
} );


_api_register( 'rows.add()', function ( rows ) {
	var newRows = this.iterator( 'table', function ( settings ) {
			var row, i, ien;
			var out = [];

			for ( i=0, ien=rows.length ; i<ien ; i++ ) {
				row = rows[i];

				if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
					out.push( _fnAddTr( settings, row )[0] );
				}
				else {
					out.push( _fnAddData( settings, row ) );
				}
			}

			return out;
		}, 1 );

	// Return an Api.rows() extended instance, so rows().nodes() etc can be used
	var modRows = this.rows( -1 );
	modRows.pop();
	modRows.push.apply(modRows, newRows);

	return modRows;
} );





/**
 *
 */
_api_register( 'row()', function ( selector, opts ) {
	return _selector_first( this.rows( selector, opts ) );
} );


_api_register( 'row().data()', function ( data ) {
	var ctx = this.context;

	if ( data === undefined ) {
		// Get
		return ctx.length && this.length && this[0].length ?
			ctx[0].aoData[ this[0] ]._aData :
			undefined;
	}

	// Set
	var row = ctx[0].aoData[ this[0] ];
	row._aData = data;

	// If the DOM has an id, and the data source is an array
	if ( Array.isArray( data ) && row.nTr && row.nTr.id ) {
		_fnSetObjectDataFn( ctx[0].rowId )( data, row.nTr.id );
	}

	// Automatically invalidate
	_fnInvalidate( ctx[0], this[0], 'data' );

	return this;
} );


_api_register( 'row().node()', function () {
	var ctx = this.context;

	if (ctx.length && this.length && this[0].length) {
		var row = ctx[0].aoData[ this[0] ];

		if (row && row.nTr) {
			return row.nTr;
		}
	}

	return null;
} );


_api_register( 'row.add()', function ( row ) {
	// Allow a jQuery object to be passed in - only a single row is added from
	// it though - the first element in the set
	if ( row instanceof $ && row.length ) {
		row = row[0];
	}

	var rows = this.iterator( 'table', function ( settings ) {
		if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
			return _fnAddTr( settings, row )[0];
		}
		return _fnAddData( settings, row );
	} );

	// Return an Api.rows() extended instance, with the newly added row selected
	return this.row( rows[0] );
} );


$(document).on('plugin-init.dt', function (e, context) {
	var api = new _Api( context );

	api.on( 'stateSaveParams.DT', function ( e, settings, d ) {
		// This could be more compact with the API, but it is a lot faster as a simple
		// internal loop
		var idFn = settings.rowIdFn;
		var rows = settings.aiDisplayMaster;
		var ids = [];

		for (var i=0 ; i<rows.length ; i++) {
			var rowIdx = rows[i];
			var data = settings.aoData[rowIdx];

			if (data._detailsShow) {
				ids.push( '#' + idFn(data._aData) );
			}
		}

		d.childRows = ids;
	});

	// For future state loads (e.g. with StateRestore)
	api.on( 'stateLoaded.DT', function (e, settings, state) {
		__details_state_load( api, state );
	});

	// And the initial load state
	__details_state_load( api, api.state.loaded() );
});

var __details_state_load = function (api, state)
{
	if ( state && state.childRows ) {
		api
			.rows( state.childRows.map(function (id) {
				// Escape any `:` characters from the row id. Accounts for
				// already escaped characters.
				return id.replace(/([^:\\]*(?:\\.[^:\\]*)*):/g, "$1\\:");
			}) )
			.every( function () {
				_fnCallbackFire( api.settings()[0], null, 'requestChild', [ this ] )
			});
	}
}

var __details_add = function ( ctx, row, data, klass )
{
	// Convert to array of TR elements
	var rows = [];
	var addRow = function ( r, k ) {
		// Recursion to allow for arrays of jQuery objects
		if ( Array.isArray( r ) || r instanceof $ ) {
			for ( var i=0, ien=r.length ; i<ien ; i++ ) {
				addRow( r[i], k );
			}
			return;
		}

		// If we get a TR element, then just add it directly - up to the dev
		// to add the correct number of columns etc
		if ( r.nodeName && r.nodeName.toLowerCase() === 'tr' ) {
			r.setAttribute( 'data-dt-row', row.idx );
			rows.push( r );
		}
		else {
			// Otherwise create a row with a wrapper
			var created = $('<tr><td></td></tr>')
				.attr( 'data-dt-row', row.idx )
				.addClass( k );
			
			$('td', created)
				.addClass( k )
				.html( r )[0].colSpan = _fnVisbleColumns( ctx );

			rows.push( created[0] );
		}
	};

	addRow( data, klass );

	if ( row._details ) {
		row._details.detach();
	}

	row._details = $(rows);

	// If the children were already shown, that state should be retained
	if ( row._detailsShow ) {
		row._details.insertAfter( row.nTr );
	}
};


// Make state saving of child row details async to allow them to be batch processed
var __details_state = DataTable.util.throttle(
	function (ctx) {
		_fnSaveState( ctx[0] )
	},
	500
);


var __details_remove = function ( api, idx )
{
	var ctx = api.context;

	if ( ctx.length ) {
		var row = ctx[0].aoData[ idx !== undefined ? idx : api[0] ];

		if ( row && row._details ) {
			row._details.remove();

			row._detailsShow = undefined;
			row._details = undefined;
			$( row.nTr ).removeClass( 'dt-hasChild' );
			__details_state( ctx );
		}
	}
};


var __details_display = function ( api, show ) {
	var ctx = api.context;

	if ( ctx.length && api.length ) {
		var row = ctx[0].aoData[ api[0] ];

		if ( row._details ) {
			row._detailsShow = show;

			if ( show ) {
				row._details.insertAfter( row.nTr );
				$( row.nTr ).addClass( 'dt-hasChild' );
			}
			else {
				row._details.detach();
				$( row.nTr ).removeClass( 'dt-hasChild' );
			}

			_fnCallbackFire( ctx[0], null, 'childRow', [ show, api.row( api[0] ) ] )

			__details_events( ctx[0] );
			__details_state( ctx );
		}
	}
};


var __details_events = function ( settings )
{
	var api = new _Api( settings );
	var namespace = '.dt.DT_details';
	var drawEvent = 'draw'+namespace;
	var colvisEvent = 'column-sizing'+namespace;
	var destroyEvent = 'destroy'+namespace;
	var data = settings.aoData;

	api.off( drawEvent +' '+ colvisEvent +' '+ destroyEvent );

	if ( _pluck( data, '_details' ).length > 0 ) {
		// On each draw, insert the required elements into the document
		api.on( drawEvent, function ( e, ctx ) {
			if ( settings !== ctx ) {
				return;
			}

			api.rows( {page:'current'} ).eq(0).each( function (idx) {
				// Internal data grab
				var row = data[ idx ];

				if ( row._detailsShow ) {
					row._details.insertAfter( row.nTr );
				}
			} );
		} );

		// Column visibility change - update the colspan
		api.on( colvisEvent, function ( e, ctx ) {
			if ( settings !== ctx ) {
				return;
			}

			// Update the colspan for the details rows (note, only if it already has
			// a colspan)
			var row, visible = _fnVisbleColumns( ctx );

			for ( var i=0, ien=data.length ; i<ien ; i++ ) {
				row = data[i];

				if ( row && row._details ) {
					row._details.each(function () {
						var el = $(this).children('td');

						if (el.length == 1) {
							el.attr('colspan', visible);
						}
					});
				}
			}
		} );

		// Table destroyed - nuke any child rows
		api.on( destroyEvent, function ( e, ctx ) {
			if ( settings !== ctx ) {
				return;
			}

			for ( var i=0, ien=data.length ; i<ien ; i++ ) {
				if ( data[i] && data[i]._details ) {
					__details_remove( api, i );
				}
			}
		} );
	}
};

// Strings for the method names to help minification
var _emp = '';
var _child_obj = _emp+'row().child';
var _child_mth = _child_obj+'()';

// data can be:
//  tr
//  string
//  jQuery or array of any of the above
_api_register( _child_mth, function ( data, klass ) {
	var ctx = this.context;

	if ( data === undefined ) {
		// get
		return ctx.length && this.length && ctx[0].aoData[ this[0] ]
			? ctx[0].aoData[ this[0] ]._details
			: undefined;
	}
	else if ( data === true ) {
		// show
		this.child.show();
	}
	else if ( data === false ) {
		// remove
		__details_remove( this );
	}
	else if ( ctx.length && this.length ) {
		// set
		__details_add( ctx[0], ctx[0].aoData[ this[0] ], data, klass );
	}

	return this;
} );


_api_register( [
	_child_obj+'.show()',
	_child_mth+'.show()' // only when `child()` was called with parameters (without
], function () {         // it returns an object and this method is not executed)
	__details_display( this, true );
	return this;
} );


_api_register( [
	_child_obj+'.hide()',
	_child_mth+'.hide()' // only when `child()` was called with parameters (without
], function () {         // it returns an object and this method is not executed)
	__details_display( this, false );
	return this;
} );


_api_register( [
	_child_obj+'.remove()',
	_child_mth+'.remove()' // only when `child()` was called with parameters (without
], function () {           // it returns an object and this method is not executed)
	__details_remove( this );
	return this;
} );


_api_register( _child_obj+'.isShown()', function () {
	var ctx = this.context;

	if ( ctx.length && this.length && ctx[0].aoData[ this[0] ] ) {
		// _detailsShown as false or undefined will fall through to return false
		return ctx[0].aoData[ this[0] ]._detailsShow || false;
	}
	return false;
} );



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Columns
 *
 * {integer}           - column index (>=0 count from left, <0 count from right)
 * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
 * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
 * "{string}:name"     - column name
 * "{string}"          - jQuery selector on column header nodes
 *
 */

// can be an array of these items, comma separated list, or an array of comma
// separated lists

var __re_column_selector = /^([^:]+)?:(name|title|visIdx|visible)$/;


// r1 and r2 are redundant - but it means that the parameters match for the
// iterator callback in columns().data()
var __columnData = function ( settings, column, r1, r2, rows, type ) {
	var a = [];
	for ( var row=0, ien=rows.length ; row<ien ; row++ ) {
		a.push( _fnGetCellData( settings, rows[row], column, type ) );
	}
	return a;
};


var __column_header = function ( settings, column, row ) {
	var header = settings.aoHeader;
	var target = row !== undefined
		? row
		: settings.bSortCellsTop // legacy support
			? 0
			: header.length - 1;

	return header[target][column].cell;
};

var __column_selector = function ( settings, selector, opts )
{
	var
		columns = settings.aoColumns,
		names = _pluck( columns, 'sName' ),
		titles = _pluck( columns, 'sTitle' ),
		cells = DataTable.util.get('[].[].cell')(settings.aoHeader),
		nodes = _unique( _flatten([], cells) );
	
	var run = function ( s ) {
		var selInt = _intVal( s );

		// Selector - all
		if ( s === '' ) {
			return _range( columns.length );
		}

		// Selector - index
		if ( selInt !== null ) {
			return [ selInt >= 0 ?
				selInt : // Count from left
				columns.length + selInt // Count from right (+ because its a negative value)
			];
		}

		// Selector = function
		if ( typeof s === 'function' ) {
			var rows = _selector_row_indexes( settings, opts );

			return columns.map(function (col, idx) {
				return s(
						idx,
						__columnData( settings, idx, 0, 0, rows ),
						__column_header( settings, idx )
					) ? idx : null;
			});
		}

		// jQuery or string selector
		var match = typeof s === 'string' ?
			s.match( __re_column_selector ) :
			'';

		if ( match ) {
			switch( match[2] ) {
				case 'visIdx':
				case 'visible':
					if (match[1]) {
						var idx = parseInt( match[1], 10 );
						// Visible index given, convert to column index
						if ( idx < 0 ) {
							// Counting from the right
							var visColumns = columns.map( function (col,i) {
								return col.bVisible ? i : null;
							} );
							return [ visColumns[ visColumns.length + idx ] ];
						}
						// Counting from the left
						return [ _fnVisibleToColumnIndex( settings, idx ) ];
					}
					
					// `:visible` on its own
					return columns.map( function (col, i) {
						return col.bVisible ? i : null;
					} );

				case 'name':
					// match by name. `names` is column index complete and in order
					return names.map( function (name, i) {
						return name === match[1] ? i : null;
					} );

				case 'title':
					// match by column title
					return titles.map( function (title, i) {
						return title === match[1] ? i : null;
					} );

				default:
					return [];
			}
		}

		// Cell in the table body
		if ( s.nodeName && s._DT_CellIndex ) {
			return [ s._DT_CellIndex.column ];
		}

		// jQuery selector on the TH elements for the columns
		var jqResult = $( nodes )
			.filter( s )
			.map( function () {
				return _fnColumnsFromHeader( this ); // `nodes` is column index complete and in order
			} )
			.toArray();

		if ( jqResult.length || ! s.nodeName ) {
			return jqResult;
		}

		// Otherwise a node which might have a `dt-column` data attribute, or be
		// a child or such an element
		var host = $(s).closest('*[data-dt-column]');
		return host.length ?
			[ host.data('dt-column') ] :
			[];
	};

	return _selector_run( 'column', selector, run, settings, opts );
};


var __setColumnVis = function ( settings, column, vis ) {
	var
		cols = settings.aoColumns,
		col  = cols[ column ],
		data = settings.aoData,
		cells, i, ien, tr;

	// Get
	if ( vis === undefined ) {
		return col.bVisible;
	}

	// Set
	// No change
	if ( col.bVisible === vis ) {
		return false;
	}

	if ( vis ) {
		// Insert column
		// Need to decide if we should use appendChild or insertBefore
		var insertBefore = _pluck(cols, 'bVisible').indexOf(true, column+1);

		for ( i=0, ien=data.length ; i<ien ; i++ ) {
			if (data[i]) {
				tr = data[i].nTr;
				cells = data[i].anCells;

				if ( tr ) {
					// insertBefore can act like appendChild if 2nd arg is null
					tr.insertBefore( cells[ column ], cells[ insertBefore ] || null );
				}
			}
		}
	}
	else {
		// Remove column
		$( _pluck( settings.aoData, 'anCells', column ) ).detach();
	}

	// Common actions
	col.bVisible = vis;

	_colGroup(settings);
	
	return true;
};


_api_register( 'columns()', function ( selector, opts ) {
	// argument shifting
	if ( selector === undefined ) {
		selector = '';
	}
	else if ( $.isPlainObject( selector ) ) {
		opts = selector;
		selector = '';
	}

	opts = _selector_opts( opts );

	var inst = this.iterator( 'table', function ( settings ) {
		return __column_selector( settings, selector, opts );
	}, 1 );

	// Want argument shifting here and in _row_selector?
	inst.selector.cols = selector;
	inst.selector.opts = opts;

	return inst;
} );

_api_registerPlural( 'columns().header()', 'column().header()', function ( row ) {
	return this.iterator( 'column', function (settings, column) {
		return __column_header(settings, column, row);
	}, 1 );
} );

_api_registerPlural( 'columns().footer()', 'column().footer()', function ( row ) {
	return this.iterator( 'column', function ( settings, column ) {
		var footer = settings.aoFooter;

		if (! footer.length) {
			return null;
		}

		return settings.aoFooter[row !== undefined ? row : 0][column].cell;
	}, 1 );
} );

_api_registerPlural( 'columns().data()', 'column().data()', function () {
	return this.iterator( 'column-rows', __columnData, 1 );
} );

_api_registerPlural( 'columns().render()', 'column().render()', function ( type ) {
	return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
		return __columnData( settings, column, i, j, rows, type );
	}, 1 );
} );

_api_registerPlural( 'columns().dataSrc()', 'column().dataSrc()', function () {
	return this.iterator( 'column', function ( settings, column ) {
		return settings.aoColumns[column].mData;
	}, 1 );
} );

_api_registerPlural( 'columns().cache()', 'column().cache()', function ( type ) {
	return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
		return _pluck_order( settings.aoData, rows,
			type === 'search' ? '_aFilterData' : '_aSortData', column
		);
	}, 1 );
} );

_api_registerPlural( 'columns().init()', 'column().init()', function () {
	return this.iterator( 'column', function ( settings, column ) {
		return settings.aoColumns[column];
	}, 1 );
} );

_api_registerPlural( 'columns().nodes()', 'column().nodes()', function () {
	return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
		return _pluck_order( settings.aoData, rows, 'anCells', column ) ;
	}, 1 );
} );

_api_registerPlural( 'columns().titles()', 'column().title()', function (title, row) {
	return this.iterator( 'column', function ( settings, column ) {
		// Argument shifting
		if (typeof title === 'number') {
			row = title;
			title = undefined;
		}

		var span = $('span.dt-column-title', this.column(column).header(row));

		if (title !== undefined) {
			span.html(title);
			return this;
		}

		return span.html();
	}, 1 );
} );

_api_registerPlural( 'columns().types()', 'column().type()', function () {
	return this.iterator( 'column', function ( settings, column ) {
		var type = settings.aoColumns[column].sType;

		// If the type was invalidated, then resolve it. This actually does
		// all columns at the moment. Would only happen once if getting all
		// column's data types.
		if (! type) {
			_fnColumnTypes(settings);
		}

		return type;
	}, 1 );
} );

_api_registerPlural( 'columns().visible()', 'column().visible()', function ( vis, calc ) {
	var that = this;
	var changed = [];
	var ret = this.iterator( 'column', function ( settings, column ) {
		if ( vis === undefined ) {
			return settings.aoColumns[ column ].bVisible;
		} // else
		
		if (__setColumnVis( settings, column, vis )) {
			changed.push(column);
		}
	} );

	// Group the column visibility changes
	if ( vis !== undefined ) {
		this.iterator( 'table', function ( settings ) {
			// Redraw the header after changes
			_fnDrawHead( settings, settings.aoHeader );
			_fnDrawHead( settings, settings.aoFooter );
	
			// Update colspan for no records display. Child rows and extensions will use their own
			// listeners to do this - only need to update the empty table item here
			if ( ! settings.aiDisplay.length ) {
				$(settings.nTBody).find('td[colspan]').attr('colspan', _fnVisbleColumns(settings));
			}
	
			_fnSaveState( settings );

			// Second loop once the first is done for events
			that.iterator( 'column', function ( settings, column ) {
				if (changed.includes(column)) {
					_fnCallbackFire( settings, null, 'column-visibility', [settings, column, vis, calc] );
				}
			} );

			if ( changed.length && (calc === undefined || calc) ) {
				that.columns.adjust();
			}
		});
	}

	return ret;
} );

_api_registerPlural( 'columns().widths()', 'column().width()', function () {
	// Injects a fake row into the table for just a moment so the widths can
	// be read, regardless of colspan in the header and rows being present in
	// the body
	var columns = this.columns(':visible').count();
	var row = $('<tr>').html('<td>' + Array(columns).join('</td><td>') + '</td>');

	$(this.table().body()).append(row);

	var widths = row.children().map(function () {
		return $(this).outerWidth();
	});

	row.remove();
	
	return this.iterator( 'column', function ( settings, column ) {
		var visIdx = _fnColumnIndexToVisible( settings, column );

		return visIdx !== null ? widths[visIdx] : 0;
	}, 1);
} );

_api_registerPlural( 'columns().indexes()', 'column().index()', function ( type ) {
	return this.iterator( 'column', function ( settings, column ) {
		return type === 'visible' ?
			_fnColumnIndexToVisible( settings, column ) :
			column;
	}, 1 );
} );

_api_register( 'columns.adjust()', function () {
	return this.iterator( 'table', function ( settings ) {
		_fnAdjustColumnSizing( settings );
	}, 1 );
} );

_api_register( 'column.index()', function ( type, idx ) {
	if ( this.context.length !== 0 ) {
		var ctx = this.context[0];

		if ( type === 'fromVisible' || type === 'toData' ) {
			return _fnVisibleToColumnIndex( ctx, idx );
		}
		else if ( type === 'fromData' || type === 'toVisible' ) {
			return _fnColumnIndexToVisible( ctx, idx );
		}
	}
} );

_api_register( 'column()', function ( selector, opts ) {
	return _selector_first( this.columns( selector, opts ) );
} );

var __cell_selector = function ( settings, selector, opts )
{
	var data = settings.aoData;
	var rows = _selector_row_indexes( settings, opts );
	var cells = _removeEmpty( _pluck_order( data, rows, 'anCells' ) );
	var allCells = $(_flatten( [], cells ));
	var row;
	var columns = settings.aoColumns.length;
	var a, i, ien, j, o, host;

	var run = function ( s ) {
		var fnSelector = typeof s === 'function';

		if ( s === null || s === undefined || fnSelector ) {
			// All cells and function selectors
			a = [];

			for ( i=0, ien=rows.length ; i<ien ; i++ ) {
				row = rows[i];

				for ( j=0 ; j<columns ; j++ ) {
					o = {
						row: row,
						column: j
					};

					if ( fnSelector ) {
						// Selector - function
						host = data[ row ];

						if ( s( o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null ) ) {
							a.push( o );
						}
					}
					else {
						// Selector - all
						a.push( o );
					}
				}
			}

			return a;
		}
		
		// Selector - index
		if ( $.isPlainObject( s ) ) {
			// Valid cell index and its in the array of selectable rows
			return s.column !== undefined && s.row !== undefined && rows.indexOf(s.row) !== -1 ?
				[s] :
				[];
		}

		// Selector - jQuery filtered cells
		var jqResult = allCells
			.filter( s )
			.map( function (i, el) {
				return { // use a new object, in case someone changes the values
					row:    el._DT_CellIndex.row,
					column: el._DT_CellIndex.column
				};
			} )
			.toArray();

		if ( jqResult.length || ! s.nodeName ) {
			return jqResult;
		}

		// Otherwise the selector is a node, and there is one last option - the
		// element might be a child of an element which has dt-row and dt-column
		// data attributes
		host = $(s).closest('*[data-dt-row]');
		return host.length ?
			[ {
				row: host.data('dt-row'),
				column: host.data('dt-column')
			} ] :
			[];
	};

	return _selector_run( 'cell', selector, run, settings, opts );
};




_api_register( 'cells()', function ( rowSelector, columnSelector, opts ) {
	// Argument shifting
	if ( $.isPlainObject( rowSelector ) ) {
		// Indexes
		if ( rowSelector.row === undefined ) {
			// Selector options in first parameter
			opts = rowSelector;
			rowSelector = null;
		}
		else {
			// Cell index objects in first parameter
			opts = columnSelector;
			columnSelector = null;
		}
	}
	if ( $.isPlainObject( columnSelector ) ) {
		opts = columnSelector;
		columnSelector = null;
	}

	// Cell selector
	if ( columnSelector === null || columnSelector === undefined ) {
		return this.iterator( 'table', function ( settings ) {
			return __cell_selector( settings, rowSelector, _selector_opts( opts ) );
		} );
	}

	// The default built in options need to apply to row and columns
	var internalOpts = opts ? {
		page: opts.page,
		order: opts.order,
		search: opts.search
	} : {};

	// Row + column selector
	var columns = this.columns( columnSelector, internalOpts );
	var rows = this.rows( rowSelector, internalOpts );
	var i, ien, j, jen;

	var cellsNoOpts = this.iterator( 'table', function ( settings, idx ) {
		var a = [];

		for ( i=0, ien=rows[idx].length ; i<ien ; i++ ) {
			for ( j=0, jen=columns[idx].length ; j<jen ; j++ ) {
				a.push( {
					row:    rows[idx][i],
					column: columns[idx][j]
				} );
			}
		}

		return a;
	}, 1 );

	// There is currently only one extension which uses a cell selector extension
	// It is a _major_ performance drag to run this if it isn't needed, so this is
	// an extension specific check at the moment
	var cells = opts && opts.selected ?
		this.cells( cellsNoOpts, opts ) :
		cellsNoOpts;

	$.extend( cells.selector, {
		cols: columnSelector,
		rows: rowSelector,
		opts: opts
	} );

	return cells;
} );


_api_registerPlural( 'cells().nodes()', 'cell().node()', function () {
	return this.iterator( 'cell', function ( settings, row, column ) {
		var data = settings.aoData[ row ];

		return data && data.anCells ?
			data.anCells[ column ] :
			undefined;
	}, 1 );
} );


_api_register( 'cells().data()', function () {
	return this.iterator( 'cell', function ( settings, row, column ) {
		return _fnGetCellData( settings, row, column );
	}, 1 );
} );


_api_registerPlural( 'cells().cache()', 'cell().cache()', function ( type ) {
	type = type === 'search' ? '_aFilterData' : '_aSortData';

	return this.iterator( 'cell', function ( settings, row, column ) {
		return settings.aoData[ row ][ type ][ column ];
	}, 1 );
} );


_api_registerPlural( 'cells().render()', 'cell().render()', function ( type ) {
	return this.iterator( 'cell', function ( settings, row, column ) {
		return _fnGetCellData( settings, row, column, type );
	}, 1 );
} );


_api_registerPlural( 'cells().indexes()', 'cell().index()', function () {
	return this.iterator( 'cell', function ( settings, row, column ) {
		return {
			row: row,
			column: column,
			columnVisible: _fnColumnIndexToVisible( settings, column )
		};
	}, 1 );
} );


_api_registerPlural( 'cells().invalidate()', 'cell().invalidate()', function ( src ) {
	return this.iterator( 'cell', function ( settings, row, column ) {
		_fnInvalidate( settings, row, src, column );
	} );
} );



_api_register( 'cell()', function ( rowSelector, columnSelector, opts ) {
	return _selector_first( this.cells( rowSelector, columnSelector, opts ) );
} );


_api_register( 'cell().data()', function ( data ) {
	var ctx = this.context;
	var cell = this[0];

	if ( data === undefined ) {
		// Get
		return ctx.length && cell.length ?
			_fnGetCellData( ctx[0], cell[0].row, cell[0].column ) :
			undefined;
	}

	// Set
	_fnSetCellData( ctx[0], cell[0].row, cell[0].column, data );
	_fnInvalidate( ctx[0], cell[0].row, 'data', cell[0].column );

	return this;
} );



/**
 * Get current ordering (sorting) that has been applied to the table.
 *
 * @returns {array} 2D array containing the sorting information for the first
 *   table in the current context. Each element in the parent array represents
 *   a column being sorted upon (i.e. multi-sorting with two columns would have
 *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
 *   the column index that the sorting condition applies to, the second is the
 *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
 *   index of the sorting order from the `column.sorting` initialisation array.
 *//**
 * Set the ordering for the table.
 *
 * @param {integer} order Column index to sort upon.
 * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
 * @returns {DataTables.Api} this
 *//**
 * Set the ordering for the table.
 *
 * @param {array} order 1D array of sorting information to be applied.
 * @param {array} [...] Optional additional sorting conditions
 * @returns {DataTables.Api} this
 *//**
 * Set the ordering for the table.
 *
 * @param {array} order 2D array of sorting information to be applied.
 * @returns {DataTables.Api} this
 */
_api_register( 'order()', function ( order, dir ) {
	var ctx = this.context;
	var args = Array.prototype.slice.call( arguments );

	if ( order === undefined ) {
		// get
		return ctx.length !== 0 ?
			ctx[0].aaSorting :
			undefined;
	}

	// set
	if ( typeof order === 'number' ) {
		// Simple column / direction passed in
		order = [ [ order, dir ] ];
	}
	else if ( args.length > 1 ) {
		// Arguments passed in (list of 1D arrays)
		order = args;
	}
	// otherwise a 2D array was passed in

	return this.iterator( 'table', function ( settings ) {
		settings.aaSorting = Array.isArray(order) ? order.slice() : order;
	} );
} );


/**
 * Attach a sort listener to an element for a given column
 *
 * @param {node|jQuery|string} node Identifier for the element(s) to attach the
 *   listener to. This can take the form of a single DOM node, a jQuery
 *   collection of nodes or a jQuery selector which will identify the node(s).
 * @param {integer} column the column that a click on this node will sort on
 * @param {function} [callback] callback function when sort is run
 * @returns {DataTables.Api} this
 */
_api_register( 'order.listener()', function ( node, column, callback ) {
	return this.iterator( 'table', function ( settings ) {
		_fnSortAttachListener(settings, node, {}, column, callback);
	} );
} );


_api_register( 'order.fixed()', function ( set ) {
	if ( ! set ) {
		var ctx = this.context;
		var fixed = ctx.length ?
			ctx[0].aaSortingFixed :
			undefined;

		return Array.isArray( fixed ) ?
			{ pre: fixed } :
			fixed;
	}

	return this.iterator( 'table', function ( settings ) {
		settings.aaSortingFixed = $.extend( true, {}, set );
	} );
} );


// Order by the selected column(s)
_api_register( [
	'columns().order()',
	'column().order()'
], function ( dir ) {
	var that = this;

	if ( ! dir ) {
		return this.iterator( 'column', function ( settings, idx ) {
			var sort = _fnSortFlatten( settings );

			for ( var i=0, ien=sort.length ; i<ien ; i++ ) {
				if ( sort[i].col === idx ) {
					return sort[i].dir;
				}
			}

			return null;
		}, 1 );
	}
	else {
		return this.iterator( 'table', function ( settings, i ) {
			settings.aaSorting = that[i].map( function (col) {
				return [ col, dir ];
			} );
		} );
	}
} );

_api_registerPlural('columns().orderable()', 'column().orderable()', function ( directions ) {
	return this.iterator( 'column', function ( settings, idx ) {
		var col = settings.aoColumns[idx];

		return directions ?
			col.asSorting :
			col.bSortable;
	}, 1 );
} );


_api_register( 'processing()', function ( show ) {
	return this.iterator( 'table', function ( ctx ) {
		_fnProcessingDisplay( ctx, show );
	} );
} );


_api_register( 'search()', function ( input, regex, smart, caseInsen ) {
	var ctx = this.context;

	if ( input === undefined ) {
		// get
		return ctx.length !== 0 ?
			ctx[0].oPreviousSearch.search :
			undefined;
	}

	// set
	return this.iterator( 'table', function ( settings ) {
		if ( ! settings.oFeatures.bFilter ) {
			return;
		}

		if (typeof regex === 'object') {
			// New style options to pass to the search builder
			_fnFilterComplete( settings, $.extend( settings.oPreviousSearch, regex, {
				search: input
			} ) );
		}
		else {
			// Compat for the old options
			_fnFilterComplete( settings, $.extend( settings.oPreviousSearch, {
				search: input,
				regex:  regex === null ? false : regex,
				smart:  smart === null ? true  : smart,
				caseInsensitive: caseInsen === null ? true : caseInsen
			} ) );
		}
	} );
} );

_api_register( 'search.fixed()', function ( name, search ) {
	var ret = this.iterator( true, 'table', function ( settings ) {
		var fixed = settings.searchFixed;

		if (! name) {
			return Object.keys(fixed)
		}
		else if (search === undefined) {
			return fixed[name];
		}
		else if (search === null) {
			delete fixed[name];
		}
		else {
			fixed[name] = search;
		}

		return this;
	} );

	return name !== undefined && search === undefined
		? ret[0]
		: ret;
} );

_api_registerPlural(
	'columns().search()',
	'column().search()',
	function ( input, regex, smart, caseInsen ) {
		return this.iterator( 'column', function ( settings, column ) {
			var preSearch = settings.aoPreSearchCols;

			if ( input === undefined ) {
				// get
				return preSearch[ column ].search;
			}

			// set
			if ( ! settings.oFeatures.bFilter ) {
				return;
			}

			if (typeof regex === 'object') {
				// New style options to pass to the search builder
				$.extend( preSearch[ column ], regex, {
					search: input
				} );
			}
			else {
				// Old style (with not all options available)
				$.extend( preSearch[ column ], {
					search: input,
					regex:  regex === null ? false : regex,
					smart:  smart === null ? true  : smart,
					caseInsensitive: caseInsen === null ? true : caseInsen
				} );
			}

			_fnFilterComplete( settings, settings.oPreviousSearch );
		} );
	}
);

_api_register([
		'columns().search.fixed()',
		'column().search.fixed()'
	],
	function ( name, search ) {
		var ret = this.iterator( true, 'column', function ( settings, colIdx ) {
			var fixed = settings.aoColumns[colIdx].searchFixed;

			if (! name) {
				return Object.keys(fixed)
			}
			else if (search === undefined) {
				return fixed[name];
			}
			else if (search === null) {
				delete fixed[name];
			}
			else {
				fixed[name] = search;
			}

			return this;
		} );

		return name !== undefined && search === undefined
			? ret[0]
			: ret;
	}
);
/*
 * State API methods
 */

_api_register( 'state()', function ( set, ignoreTime ) {
	// getter
	if ( ! set ) {
		return this.context.length ?
			this.context[0].oSavedState :
			null;
	}

	var setMutate = $.extend( true, {}, set );

	// setter
	return this.iterator( 'table', function ( settings ) {
		if ( ignoreTime !== false ) {
			setMutate.time = +new Date() + 100;
		}

		_fnImplementState( settings, setMutate, function(){} );
	} );
} );


_api_register( 'state.clear()', function () {
	return this.iterator( 'table', function ( settings ) {
		// Save an empty object
		settings.fnStateSaveCallback.call( settings.oInstance, settings, {} );
	} );
} );


_api_register( 'state.loaded()', function () {
	return this.context.length ?
		this.context[0].oLoadedState :
		null;
} );


_api_register( 'state.save()', function () {
	return this.iterator( 'table', function ( settings ) {
		_fnSaveState( settings );
	} );
} );

/**
 * Set the jQuery or window object to be used by DataTables
 *
 * @param {*} module Library / container object
 * @param {string} [type] Library or container type `lib`, `win` or `datetime`.
 *   If not provided, automatic detection is attempted.
 */
DataTable.use = function (module, type) {
	if (type === 'lib' || module.fn) {
		$ = module;
	}
	else if (type == 'win' || module.document) {
		window = module;
		document = module.document;
	}
	else if (type === 'datetime' || module.type === 'DateTime') {
		DataTable.DateTime = module;
	}
}

/**
 * CommonJS factory function pass through. This will check if the arguments
 * given are a window object or a jQuery object. If so they are set
 * accordingly.
 * @param {*} root Window
 * @param {*} jq jQUery
 * @returns {boolean} Indicator
 */
DataTable.factory = function (root, jq) {
	var is = false;

	// Test if the first parameter is a window object
	if (root && root.document) {
		window = root;
		document = root.document;
	}

	// Test if the second parameter is a jQuery object
	if (jq && jq.fn && jq.fn.jquery) {
		$ = jq;
		is = true;
	}

	return is;
}

/**
 * Provide a common method for plug-ins to check the version of DataTables being
 * used, in order to ensure compatibility.
 *
 *  @param {string} version Version string to check for, in the format "X.Y.Z".
 *    Note that the formats "X" and "X.Y" are also acceptable.
 *  @param {string} [version2=current DataTables version] As above, but optional.
 *   If not given the current DataTables version will be used.
 *  @returns {boolean} true if this version of DataTables is greater or equal to
 *    the required version, or false if this version of DataTales is not
 *    suitable
 *  @static
 *  @dtopt API-Static
 *
 *  @example
 *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
 */
DataTable.versionCheck = function( version, version2 )
{
	var aThis = version2 ?
		version2.split('.') :
		DataTable.version.split('.');
	var aThat = version.split('.');
	var iThis, iThat;

	for ( var i=0, iLen=aThat.length ; i<iLen ; i++ ) {
		iThis = parseInt( aThis[i], 10 ) || 0;
		iThat = parseInt( aThat[i], 10 ) || 0;

		// Parts are the same, keep comparing
		if (iThis === iThat) {
			continue;
		}

		// Parts are different, return immediately
		return iThis > iThat;
	}

	return true;
};


/**
 * Check if a `<table>` node is a DataTable table already or not.
 *
 *  @param {node|jquery|string} table Table node, jQuery object or jQuery
 *      selector for the table to test. Note that if more than more than one
 *      table is passed on, only the first will be checked
 *  @returns {boolean} true the table given is a DataTable, or false otherwise
 *  @static
 *  @dtopt API-Static
 *
 *  @example
 *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
 *      $('#example').dataTable();
 *    }
 */
DataTable.isDataTable = function ( table )
{
	var t = $(table).get(0);
	var is = false;

	if ( table instanceof DataTable.Api ) {
		return true;
	}

	$.each( DataTable.settings, function (i, o) {
		var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;
		var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;

		if ( o.nTable === t || head === t || foot === t ) {
			is = true;
		}
	} );

	return is;
};


/**
 * Get all DataTable tables that have been initialised - optionally you can
 * select to get only currently visible tables.
 *
 *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
 *    or visible tables only.
 *  @returns {array} Array of `table` nodes (not DataTable instances) which are
 *    DataTables
 *  @static
 *  @dtopt API-Static
 *
 *  @example
 *    $.each( $.fn.dataTable.tables(true), function () {
 *      $(table).DataTable().columns.adjust();
 *    } );
 */
DataTable.tables = function ( visible )
{
	var api = false;

	if ( $.isPlainObject( visible ) ) {
		api = visible.api;
		visible = visible.visible;
	}

	var a = DataTable.settings
		.filter( function (o) {
			return !visible || (visible && $(o.nTable).is(':visible')) 
				? true
				: false;
		} )
		.map( function (o) {
			return o.nTable;
		});

	return api ?
		new _Api( a ) :
		a;
};


/**
 * Convert from camel case parameters to Hungarian notation. This is made public
 * for the extensions to provide the same ability as DataTables core to accept
 * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
 * parameters.
 *
 *  @param {object} src The model object which holds all parameters that can be
 *    mapped.
 *  @param {object} user The object to convert from camel case to Hungarian.
 *  @param {boolean} force When set to `true`, properties which already have a
 *    Hungarian value in the `user` object will be overwritten. Otherwise they
 *    won't be.
 */
DataTable.camelToHungarian = _fnCamelToHungarian;



/**
 *
 */
_api_register( '$()', function ( selector, opts ) {
	var
		rows   = this.rows( opts ).nodes(), // Get all rows
		jqRows = $(rows);

	return $( [].concat(
		jqRows.filter( selector ).toArray(),
		jqRows.find( selector ).toArray()
	) );
} );


// jQuery functions to operate on the tables
$.each( [ 'on', 'one', 'off' ], function (i, key) {
	_api_register( key+'()', function ( /* event, handler */ ) {
		var args = Array.prototype.slice.call(arguments);

		// Add the `dt` namespace automatically if it isn't already present
		args[0] = args[0].split( /\s/ ).map( function ( e ) {
			return ! e.match(/\.dt\b/) ?
				e+'.dt' :
				e;
			} ).join( ' ' );

		var inst = $( this.tables().nodes() );
		inst[key].apply( inst, args );
		return this;
	} );
} );


_api_register( 'clear()', function () {
	return this.iterator( 'table', function ( settings ) {
		_fnClearTable( settings );
	} );
} );


_api_register( 'error()', function (msg) {
	return this.iterator( 'table', function ( settings ) {
		_fnLog( settings, 0, msg );
	} );
} );


_api_register( 'settings()', function () {
	return new _Api( this.context, this.context );
} );


_api_register( 'init()', function () {
	var ctx = this.context;
	return ctx.length ? ctx[0].oInit : null;
} );


_api_register( 'data()', function () {
	return this.iterator( 'table', function ( settings ) {
		return _pluck( settings.aoData, '_aData' );
	} ).flatten();
} );


_api_register( 'trigger()', function ( name, args, bubbles ) {
	return this.iterator( 'table', function ( settings ) {
		return _fnCallbackFire( settings, null, name, args, bubbles );
	} ).flatten();
} );


_api_register( 'ready()', function ( fn ) {
	var ctx = this.context;

	// Get status of first table
	if (! fn) {
		return ctx.length
			? (ctx[0]._bInitComplete || false)
			: null;
	}

	// Function to run either once the table becomes ready or
	// immediately if it is already ready.
	return this.tables().every(function () {
		if (this.context[0]._bInitComplete) {
			fn.call(this);
		}
		else {
			this.on('init', function () {
				fn.call(this);
			});
		}
	} );
} );


_api_register( 'destroy()', function ( remove ) {
	remove = remove || false;

	return this.iterator( 'table', function ( settings ) {
		var classes   = settings.oClasses;
		var table     = settings.nTable;
		var tbody     = settings.nTBody;
		var thead     = settings.nTHead;
		var tfoot     = settings.nTFoot;
		var jqTable   = $(table);
		var jqTbody   = $(tbody);
		var jqWrapper = $(settings.nTableWrapper);
		var rows      = settings.aoData.map( function (r) { return r ? r.nTr : null; } );
		var orderClasses = classes.order;

		// Flag to note that the table is currently being destroyed - no action
		// should be taken
		settings.bDestroying = true;

		// Fire off the destroy callbacks for plug-ins etc
		_fnCallbackFire( settings, "aoDestroyCallback", "destroy", [settings], true );

		// If not being removed from the document, make all columns visible
		if ( ! remove ) {
			new _Api( settings ).columns().visible( true );
		}

		// Blitz all `DT` namespaced events (these are internal events, the
		// lowercase, `dt` events are user subscribed and they are responsible
		// for removing them
		jqWrapper.off('.DT').find(':not(tbody *)').off('.DT');
		$(window).off('.DT-'+settings.sInstance);

		// When scrolling we had to break the table up - restore it
		if ( table != thead.parentNode ) {
			jqTable.children('thead').detach();
			jqTable.append( thead );
		}

		if ( tfoot && table != tfoot.parentNode ) {
			jqTable.children('tfoot').detach();
			jqTable.append( tfoot );
		}

		settings.colgroup.remove();

		settings.aaSorting = [];
		settings.aaSortingFixed = [];
		_fnSortingClasses( settings );

		$('th, td', thead)
			.removeClass(
				orderClasses.canAsc + ' ' +
				orderClasses.canDesc + ' ' +
				orderClasses.isAsc + ' ' +
				orderClasses.isDesc
			)
			.css('width', '');

		// Add the TR elements back into the table in their original order
		jqTbody.children().detach();
		jqTbody.append( rows );

		var orig = settings.nTableWrapper.parentNode;
		var insertBefore = settings.nTableWrapper.nextSibling;

		// Remove the DataTables generated nodes, events and classes
		var removedMethod = remove ? 'remove' : 'detach';
		jqTable[ removedMethod ]();
		jqWrapper[ removedMethod ]();

		// If we need to reattach the table to the document
		if ( ! remove && orig ) {
			// insertBefore acts like appendChild if !arg[1]
			orig.insertBefore( table, insertBefore );

			// Restore the width of the original table - was read from the style property,
			// so we can restore directly to that
			jqTable
				.css( 'width', settings.sDestroyWidth )
				.removeClass( classes.table );
		}

		/* Remove the settings object from the settings array */
		var idx = DataTable.settings.indexOf(settings);
		if ( idx !== -1 ) {
			DataTable.settings.splice( idx, 1 );
		}
	} );
} );


// Add the `every()` method for rows, columns and cells in a compact form
$.each( [ 'column', 'row', 'cell' ], function ( i, type ) {
	_api_register( type+'s().every()', function ( fn ) {
		var opts = this.selector.opts;
		var api = this;
		var inst;
		var counter = 0;

		return this.iterator( 'every', function ( settings, selectedIdx, tableIdx ) {
			inst = api[ type ](selectedIdx, opts);

			if (type === 'cell') {
				fn.call(inst, inst[0][0].row, inst[0][0].column, tableIdx, counter);
			}
			else {
				fn.call(inst, selectedIdx, tableIdx, counter);
			}

			counter++;
		} );
	} );
} );


// i18n method for extensions to be able to use the language object from the
// DataTable
_api_register( 'i18n()', function ( token, def, plural ) {
	var ctx = this.context[0];
	var resolved = _fnGetObjectDataFn( token )( ctx.oLanguage );

	if ( resolved === undefined ) {
		resolved = def;
	}

	if ( $.isPlainObject( resolved ) ) {
		resolved = plural !== undefined && resolved[ plural ] !== undefined ?
			resolved[ plural ] :
			resolved._;
	}

	return typeof resolved === 'string'
		? resolved.replace( '%d', plural ) // nb: plural might be undefined,
		: resolved;
} );

/**
 * Version string for plug-ins to check compatibility. Allowed format is
 * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
 * only for non-release builds. See https://semver.org/ for more information.
 *  @member
 *  @type string
 *  @default Version number
 */
DataTable.version = "2.0.8";

/**
 * Private data store, containing all of the settings objects that are
 * created for the tables on a given page.
 *
 * Note that the `DataTable.settings` object is aliased to
 * `jQuery.fn.dataTableExt` through which it may be accessed and
 * manipulated, or `jQuery.fn.dataTable.settings`.
 *  @member
 *  @type array
 *  @default []
 *  @private
 */
DataTable.settings = [];

/**
 * Object models container, for the various models that DataTables has
 * available to it. These models define the objects that are used to hold
 * the active state and configuration of the table.
 *  @namespace
 */
DataTable.models = {};



/**
 * Template object for the way in which DataTables holds information about
 * search information for the global filter and individual column filters.
 *  @namespace
 */
DataTable.models.oSearch = {
	/**
	 * Flag to indicate if the filtering should be case insensitive or not
	 */
	"caseInsensitive": true,

	/**
	 * Applied search term
	 */
	"search": "",

	/**
	 * Flag to indicate if the search term should be interpreted as a
	 * regular expression (true) or not (false) and therefore and special
	 * regex characters escaped.
	 */
	"regex": false,

	/**
	 * Flag to indicate if DataTables is to use its smart filtering or not.
	 */
	"smart": true,

	/**
	 * Flag to indicate if DataTables should only trigger a search when
	 * the return key is pressed.
	 */
	"return": false
};




/**
 * Template object for the way in which DataTables holds information about
 * each individual row. This is the object format used for the settings
 * aoData array.
 *  @namespace
 */
DataTable.models.oRow = {
	/**
	 * TR element for the row
	 */
	"nTr": null,

	/**
	 * Array of TD elements for each row. This is null until the row has been
	 * created.
	 */
	"anCells": null,

	/**
	 * Data object from the original data source for the row. This is either
	 * an array if using the traditional form of DataTables, or an object if
	 * using mData options. The exact type will depend on the passed in
	 * data from the data source, or will be an array if using DOM a data
	 * source.
	 */
	"_aData": [],

	/**
	 * Sorting data cache - this array is ostensibly the same length as the
	 * number of columns (although each index is generated only as it is
	 * needed), and holds the data that is used for sorting each column in the
	 * row. We do this cache generation at the start of the sort in order that
	 * the formatting of the sort data need be done only once for each cell
	 * per sort. This array should not be read from or written to by anything
	 * other than the master sorting methods.
	 */
	"_aSortData": null,

	/**
	 * Per cell filtering data cache. As per the sort data cache, used to
	 * increase the performance of the filtering in DataTables
	 */
	"_aFilterData": null,

	/**
	 * Filtering data cache. This is the same as the cell filtering cache, but
	 * in this case a string rather than an array. This is easily computed with
	 * a join on `_aFilterData`, but is provided as a cache so the join isn't
	 * needed on every search (memory traded for performance)
	 */
	"_sFilterRow": null,

	/**
	 * Denote if the original data source was from the DOM, or the data source
	 * object. This is used for invalidating data, so DataTables can
	 * automatically read data from the original source, unless uninstructed
	 * otherwise.
	 */
	"src": null,

	/**
	 * Index in the aoData array. This saves an indexOf lookup when we have the
	 * object, but want to know the index
	 */
	"idx": -1,

	/**
	 * Cached display value
	 */
	displayData: null
};


/**
 * Template object for the column information object in DataTables. This object
 * is held in the settings aoColumns array and contains all the information that
 * DataTables needs about each individual column.
 *
 * Note that this object is related to {@link DataTable.defaults.column}
 * but this one is the internal data store for DataTables's cache of columns.
 * It should NOT be manipulated outside of DataTables. Any configuration should
 * be done through the initialisation options.
 *  @namespace
 */
DataTable.models.oColumn = {
	/**
	 * Column index.
	 */
	"idx": null,

	/**
	 * A list of the columns that sorting should occur on when this column
	 * is sorted. That this property is an array allows multi-column sorting
	 * to be defined for a column (for example first name / last name columns
	 * would benefit from this). The values are integers pointing to the
	 * columns to be sorted on (typically it will be a single integer pointing
	 * at itself, but that doesn't need to be the case).
	 */
	"aDataSort": null,

	/**
	 * Define the sorting directions that are applied to the column, in sequence
	 * as the column is repeatedly sorted upon - i.e. the first value is used
	 * as the sorting direction when the column if first sorted (clicked on).
	 * Sort it again (click again) and it will move on to the next index.
	 * Repeat until loop.
	 */
	"asSorting": null,

	/**
	 * Flag to indicate if the column is searchable, and thus should be included
	 * in the filtering or not.
	 */
	"bSearchable": null,

	/**
	 * Flag to indicate if the column is sortable or not.
	 */
	"bSortable": null,

	/**
	 * Flag to indicate if the column is currently visible in the table or not
	 */
	"bVisible": null,

	/**
	 * Store for manual type assignment using the `column.type` option. This
	 * is held in store so we can manipulate the column's `sType` property.
	 */
	"_sManualType": null,

	/**
	 * Flag to indicate if HTML5 data attributes should be used as the data
	 * source for filtering or sorting. True is either are.
	 */
	"_bAttrSrc": false,

	/**
	 * Developer definable function that is called whenever a cell is created (Ajax source,
	 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
	 * allowing you to modify the DOM element (add background colour for example) when the
	 * element is available.
	 */
	"fnCreatedCell": null,

	/**
	 * Function to get data from a cell in a column. You should <b>never</b>
	 * access data directly through _aData internally in DataTables - always use
	 * the method attached to this property. It allows mData to function as
	 * required. This function is automatically assigned by the column
	 * initialisation method
	 */
	"fnGetData": null,

	/**
	 * Function to set data for a cell in the column. You should <b>never</b>
	 * set the data directly to _aData internally in DataTables - always use
	 * this method. It allows mData to function as required. This function
	 * is automatically assigned by the column initialisation method
	 */
	"fnSetData": null,

	/**
	 * Property to read the value for the cells in the column from the data
	 * source array / object. If null, then the default content is used, if a
	 * function is given then the return from the function is used.
	 */
	"mData": null,

	/**
	 * Partner property to mData which is used (only when defined) to get
	 * the data - i.e. it is basically the same as mData, but without the
	 * 'set' option, and also the data fed to it is the result from mData.
	 * This is the rendering method to match the data method of mData.
	 */
	"mRender": null,

	/**
	 * The class to apply to all TD elements in the table's TBODY for the column
	 */
	"sClass": null,

	/**
	 * When DataTables calculates the column widths to assign to each column,
	 * it finds the longest string in each column and then constructs a
	 * temporary table and reads the widths from that. The problem with this
	 * is that "mmm" is much wider then "iiii", but the latter is a longer
	 * string - thus the calculation can go wrong (doing it properly and putting
	 * it into an DOM object and measuring that is horribly(!) slow). Thus as
	 * a "work around" we provide this option. It will append its value to the
	 * text that is found to be the longest string for the column - i.e. padding.
	 */
	"sContentPadding": null,

	/**
	 * Allows a default value to be given for a column's data, and will be used
	 * whenever a null data source is encountered (this can be because mData
	 * is set to null, or because the data source itself is null).
	 */
	"sDefaultContent": null,

	/**
	 * Name for the column, allowing reference to the column by name as well as
	 * by index (needs a lookup to work by name).
	 */
	"sName": null,

	/**
	 * Custom sorting data type - defines which of the available plug-ins in
	 * afnSortData the custom sorting will use - if any is defined.
	 */
	"sSortDataType": 'std',

	/**
	 * Class to be applied to the header element when sorting on this column
	 */
	"sSortingClass": null,

	/**
	 * Title of the column - what is seen in the TH element (nTh).
	 */
	"sTitle": null,

	/**
	 * Column sorting and filtering type
	 */
	"sType": null,

	/**
	 * Width of the column
	 */
	"sWidth": null,

	/**
	 * Width of the column when it was first "encountered"
	 */
	"sWidthOrig": null,

	/** Cached string which is the longest in the column */
	maxLenString: null,

	/**
	 * Store for named searches
	 */
	searchFixed: null
};


/*
 * Developer note: The properties of the object below are given in Hungarian
 * notation, that was used as the interface for DataTables prior to v1.10, however
 * from v1.10 onwards the primary interface is camel case. In order to avoid
 * breaking backwards compatibility utterly with this change, the Hungarian
 * version is still, internally the primary interface, but is is not documented
 * - hence the @name tags in each doc comment. This allows a Javascript function
 * to create a map from Hungarian notation to camel case (going the other direction
 * would require each property to be listed, which would add around 3K to the size
 * of DataTables, while this method is about a 0.5K hit).
 *
 * Ultimately this does pave the way for Hungarian notation to be dropped
 * completely, but that is a massive amount of work and will break current
 * installs (therefore is on-hold until v2).
 */

/**
 * Initialisation options that can be given to DataTables at initialisation
 * time.
 *  @namespace
 */
DataTable.defaults = {
	/**
	 * An array of data to use for the table, passed in at initialisation which
	 * will be used in preference to any data which is already in the DOM. This is
	 * particularly useful for constructing tables purely in Javascript, for
	 * example with a custom Ajax call.
	 */
	"aaData": null,


	/**
	 * If ordering is enabled, then DataTables will perform a first pass sort on
	 * initialisation. You can define which column(s) the sort is performed
	 * upon, and the sorting direction, with this variable. The `sorting` array
	 * should contain an array for each column to be sorted initially containing
	 * the column's index and a direction string ('asc' or 'desc').
	 */
	"aaSorting": [[0,'asc']],


	/**
	 * This parameter is basically identical to the `sorting` parameter, but
	 * cannot be overridden by user interaction with the table. What this means
	 * is that you could have a column (visible or hidden) which the sorting
	 * will always be forced on first - any sorting after that (from the user)
	 * will then be performed as required. This can be useful for grouping rows
	 * together.
	 */
	"aaSortingFixed": [],


	/**
	 * DataTables can be instructed to load data to display in the table from a
	 * Ajax source. This option defines how that Ajax call is made and where to.
	 *
	 * The `ajax` property has three different modes of operation, depending on
	 * how it is defined. These are:
	 *
	 * * `string` - Set the URL from where the data should be loaded from.
	 * * `object` - Define properties for `jQuery.ajax`.
	 * * `function` - Custom data get function
	 *
	 * `string`
	 * --------
	 *
	 * As a string, the `ajax` property simply defines the URL from which
	 * DataTables will load data.
	 *
	 * `object`
	 * --------
	 *
	 * As an object, the parameters in the object are passed to
	 * [jQuery.ajax](https://api.jquery.com/jQuery.ajax/) allowing fine control
	 * of the Ajax request. DataTables has a number of default parameters which
	 * you can override using this option. Please refer to the jQuery
	 * documentation for a full description of the options available, although
	 * the following parameters provide additional options in DataTables or
	 * require special consideration:
	 *
	 * * `data` - As with jQuery, `data` can be provided as an object, but it
	 *   can also be used as a function to manipulate the data DataTables sends
	 *   to the server. The function takes a single parameter, an object of
	 *   parameters with the values that DataTables has readied for sending. An
	 *   object may be returned which will be merged into the DataTables
	 *   defaults, or you can add the items to the object that was passed in and
	 *   not return anything from the function. This supersedes `fnServerParams`
	 *   from DataTables 1.9-.
	 *
	 * * `dataSrc` - By default DataTables will look for the property `data` (or
	 *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
	 *   from an Ajax source or for server-side processing - this parameter
	 *   allows that property to be changed. You can use Javascript dotted
	 *   object notation to get a data source for multiple levels of nesting, or
	 *   it my be used as a function. As a function it takes a single parameter,
	 *   the JSON returned from the server, which can be manipulated as
	 *   required, with the returned value being that used by DataTables as the
	 *   data source for the table.
	 *
	 * * `success` - Should not be overridden it is used internally in
	 *   DataTables. To manipulate / transform the data returned by the server
	 *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
	 *
	 * `function`
	 * ----------
	 *
	 * As a function, making the Ajax call is left up to yourself allowing
	 * complete control of the Ajax request. Indeed, if desired, a method other
	 * than Ajax could be used to obtain the required data, such as Web storage
	 * or an AIR database.
	 *
	 * The function is given four parameters and no return is required. The
	 * parameters are:
	 *
	 * 1. _object_ - Data to send to the server
	 * 2. _function_ - Callback function that must be executed when the required
	 *    data has been obtained. That data should be passed into the callback
	 *    as the only parameter
	 * 3. _object_ - DataTables settings object for the table
	 */
	"ajax": null,


	/**
	 * This parameter allows you to readily specify the entries in the length drop
	 * down menu that DataTables shows when pagination is enabled. It can be
	 * either a 1D array of options which will be used for both the displayed
	 * option and the value, or a 2D array which will use the array in the first
	 * position as the value, and the array in the second position as the
	 * displayed options (useful for language strings such as 'All').
	 *
	 * Note that the `pageLength` property will be automatically set to the
	 * first value given in this array, unless `pageLength` is also provided.
	 */
	"aLengthMenu": [ 10, 25, 50, 100 ],


	/**
	 * The `columns` option in the initialisation parameter allows you to define
	 * details about the way individual columns behave. For a full list of
	 * column options that can be set, please see
	 * {@link DataTable.defaults.column}. Note that if you use `columns` to
	 * define your columns, you must have an entry in the array for every single
	 * column that you have in your table (these can be null if you don't which
	 * to specify any options).
	 */
	"aoColumns": null,

	/**
	 * Very similar to `columns`, `columnDefs` allows you to target a specific
	 * column, multiple columns, or all columns, using the `targets` property of
	 * each object in the array. This allows great flexibility when creating
	 * tables, as the `columnDefs` arrays can be of any length, targeting the
	 * columns you specifically want. `columnDefs` may use any of the column
	 * options available: {@link DataTable.defaults.column}, but it _must_
	 * have `targets` defined in each object in the array. Values in the `targets`
	 * array may be:
	 *   <ul>
	 *     <li>a string - class name will be matched on the TH for the column</li>
	 *     <li>0 or a positive integer - column index counting from the left</li>
	 *     <li>a negative integer - column index counting from the right</li>
	 *     <li>the string "_all" - all columns (i.e. assign a default)</li>
	 *   </ul>
	 */
	"aoColumnDefs": null,


	/**
	 * Basically the same as `search`, this parameter defines the individual column
	 * filtering state at initialisation time. The array must be of the same size
	 * as the number of columns, and each element be an object with the parameters
	 * `search` and `escapeRegex` (the latter is optional). 'null' is also
	 * accepted and the default will be used.
	 */
	"aoSearchCols": [],


	/**
	 * Enable or disable automatic column width calculation. This can be disabled
	 * as an optimisation (it takes some time to calculate the widths) if the
	 * tables widths are passed in using `columns`.
	 */
	"bAutoWidth": true,


	/**
	 * Deferred rendering can provide DataTables with a huge speed boost when you
	 * are using an Ajax or JS data source for the table. This option, when set to
	 * true, will cause DataTables to defer the creation of the table elements for
	 * each row until they are needed for a draw - saving a significant amount of
	 * time.
	 */
	"bDeferRender": true,


	/**
	 * Replace a DataTable which matches the given selector and replace it with
	 * one which has the properties of the new initialisation object passed. If no
	 * table matches the selector, then the new DataTable will be constructed as
	 * per normal.
	 */
	"bDestroy": false,


	/**
	 * Enable or disable filtering of data. Filtering in DataTables is "smart" in
	 * that it allows the end user to input multiple words (space separated) and
	 * will match a row containing those words, even if not in the order that was
	 * specified (this allow matching across multiple columns). Note that if you
	 * wish to use filtering in DataTables this must remain 'true' - to remove the
	 * default filtering input box and retain filtering abilities, please use
	 * {@link DataTable.defaults.dom}.
	 */
	"bFilter": true,

	/**
	 * Used only for compatiblity with DT1
	 * @deprecated
	 */
	"bInfo": true,

	/**
	 * Used only for compatiblity with DT1
	 * @deprecated
	 */
	"bLengthChange": true,

	/**
	 * Enable or disable pagination.
	 */
	"bPaginate": true,


	/**
	 * Enable or disable the display of a 'processing' indicator when the table is
	 * being processed (e.g. a sort). This is particularly useful for tables with
	 * large amounts of data where it can take a noticeable amount of time to sort
	 * the entries.
	 */
	"bProcessing": false,


	/**
	 * Retrieve the DataTables object for the given selector. Note that if the
	 * table has already been initialised, this parameter will cause DataTables
	 * to simply return the object that has already been set up - it will not take
	 * account of any changes you might have made to the initialisation object
	 * passed to DataTables (setting this parameter to true is an acknowledgement
	 * that you understand this). `destroy` can be used to reinitialise a table if
	 * you need.
	 */
	"bRetrieve": false,


	/**
	 * When vertical (y) scrolling is enabled, DataTables will force the height of
	 * the table's viewport to the given height at all times (useful for layout).
	 * However, this can look odd when filtering data down to a small data set,
	 * and the footer is left "floating" further down. This parameter (when
	 * enabled) will cause DataTables to collapse the table's viewport down when
	 * the result set will fit within the given Y height.
	 */
	"bScrollCollapse": false,


	/**
	 * Configure DataTables to use server-side processing. Note that the
	 * `ajax` parameter must also be given in order to give DataTables a
	 * source to obtain the required data for each draw.
	 */
	"bServerSide": false,


	/**
	 * Enable or disable sorting of columns. Sorting of individual columns can be
	 * disabled by the `sortable` option for each column.
	 */
	"bSort": true,


	/**
	 * Enable or display DataTables' ability to sort multiple columns at the
	 * same time (activated by shift-click by the user).
	 */
	"bSortMulti": true,


	/**
	 * Allows control over whether DataTables should use the top (true) unique
	 * cell that is found for a single column, or the bottom (false - default).
	 * This is useful when using complex headers.
	 */
	"bSortCellsTop": null,


	/**
	 * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
	 * `sorting\_3` to the columns which are currently being sorted on. This is
	 * presented as a feature switch as it can increase processing time (while
	 * classes are removed and added) so for large data sets you might want to
	 * turn this off.
	 */
	"bSortClasses": true,


	/**
	 * Enable or disable state saving. When enabled HTML5 `localStorage` will be
	 * used to save table display information such as pagination information,
	 * display length, filtering and sorting. As such when the end user reloads
	 * the page the display display will match what thy had previously set up.
	 */
	"bStateSave": false,


	/**
	 * This function is called when a TR element is created (and all TD child
	 * elements have been inserted), or registered if using a DOM source, allowing
	 * manipulation of the TR element (adding classes etc).
	 */
	"fnCreatedRow": null,


	/**
	 * This function is called on every 'draw' event, and allows you to
	 * dynamically modify any aspect you want about the created DOM.
	 */
	"fnDrawCallback": null,


	/**
	 * Identical to fnHeaderCallback() but for the table footer this function
	 * allows you to modify the table footer on every 'draw' event.
	 */
	"fnFooterCallback": null,


	/**
	 * When rendering large numbers in the information element for the table
	 * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
	 * to have a comma separator for the 'thousands' units (e.g. 1 million is
	 * rendered as "1,000,000") to help readability for the end user. This
	 * function will override the default method DataTables uses.
	 */
	"fnFormatNumber": function ( toFormat ) {
		return toFormat.toString().replace(
			/\B(?=(\d{3})+(?!\d))/g,
			this.oLanguage.sThousands
		);
	},


	/**
	 * This function is called on every 'draw' event, and allows you to
	 * dynamically modify the header row. This can be used to calculate and
	 * display useful information about the table.
	 */
	"fnHeaderCallback": null,


	/**
	 * The information element can be used to convey information about the current
	 * state of the table. Although the internationalisation options presented by
	 * DataTables are quite capable of dealing with most customisations, there may
	 * be times where you wish to customise the string further. This callback
	 * allows you to do exactly that.
	 */
	"fnInfoCallback": null,


	/**
	 * Called when the table has been initialised. Normally DataTables will
	 * initialise sequentially and there will be no need for this function,
	 * however, this does not hold true when using external language information
	 * since that is obtained using an async XHR call.
	 */
	"fnInitComplete": null,


	/**
	 * Called at the very start of each table draw and can be used to cancel the
	 * draw by returning false, any other return (including undefined) results in
	 * the full draw occurring).
	 */
	"fnPreDrawCallback": null,


	/**
	 * This function allows you to 'post process' each row after it have been
	 * generated for each table draw, but before it is rendered on screen. This
	 * function might be used for setting the row class name etc.
	 */
	"fnRowCallback": null,


	/**
	 * Load the table state. With this function you can define from where, and how, the
	 * state of a table is loaded. By default DataTables will load from `localStorage`
	 * but you might wish to use a server-side database or cookies.
	 */
	"fnStateLoadCallback": function ( settings ) {
		try {
			return JSON.parse(
				(settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
					'DataTables_'+settings.sInstance+'_'+location.pathname
				)
			);
		} catch (e) {
			return {};
		}
	},


	/**
	 * Callback which allows modification of the saved state prior to loading that state.
	 * This callback is called when the table is loading state from the stored data, but
	 * prior to the settings object being modified by the saved state. Note that for
	 * plug-in authors, you should use the `stateLoadParams` event to load parameters for
	 * a plug-in.
	 */
	"fnStateLoadParams": null,


	/**
	 * Callback that is called when the state has been loaded from the state saving method
	 * and the DataTables settings object has been modified as a result of the loaded state.
	 */
	"fnStateLoaded": null,


	/**
	 * Save the table state. This function allows you to define where and how the state
	 * information for the table is stored By default DataTables will use `localStorage`
	 * but you might wish to use a server-side database or cookies.
	 */
	"fnStateSaveCallback": function ( settings, data ) {
		try {
			(settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
				'DataTables_'+settings.sInstance+'_'+location.pathname,
				JSON.stringify( data )
			);
		} catch (e) {
			// noop
		}
	},


	/**
	 * Callback which allows modification of the state to be saved. Called when the table
	 * has changed state a new state save is required. This method allows modification of
	 * the state saving object prior to actually doing the save, including addition or
	 * other state properties or modification. Note that for plug-in authors, you should
	 * use the `stateSaveParams` event to save parameters for a plug-in.
	 */
	"fnStateSaveParams": null,


	/**
	 * Duration for which the saved state information is considered valid. After this period
	 * has elapsed the state will be returned to the default.
	 * Value is given in seconds.
	 */
	"iStateDuration": 7200,


	/**
	 * Number of rows to display on a single page when using pagination. If
	 * feature enabled (`lengthChange`) then the end user will be able to override
	 * this to a custom setting using a pop-up menu.
	 */
	"iDisplayLength": 10,


	/**
	 * Define the starting point for data display when using DataTables with
	 * pagination. Note that this parameter is the number of records, rather than
	 * the page number, so if you have 10 records per page and want to start on
	 * the third page, it should be "20".
	 */
	"iDisplayStart": 0,


	/**
	 * By default DataTables allows keyboard navigation of the table (sorting, paging,
	 * and filtering) by adding a `tabindex` attribute to the required elements. This
	 * allows you to tab through the controls and press the enter key to activate them.
	 * The tabindex is default 0, meaning that the tab follows the flow of the document.
	 * You can overrule this using this parameter if you wish. Use a value of -1 to
	 * disable built-in keyboard navigation.
	 */
	"iTabIndex": 0,


	/**
	 * Classes that DataTables assigns to the various components and features
	 * that it adds to the HTML table. This allows classes to be configured
	 * during initialisation in addition to through the static
	 * {@link DataTable.ext.oStdClasses} object).
	 */
	"oClasses": {},


	/**
	 * All strings that DataTables uses in the user interface that it creates
	 * are defined in this object, allowing you to modified them individually or
	 * completely replace them all as required.
	 */
	"oLanguage": {
		/**
		 * Strings that are used for WAI-ARIA labels and controls only (these are not
		 * actually visible on the page, but will be read by screenreaders, and thus
		 * must be internationalised as well).
		 */
		"oAria": {
			/**
			 * ARIA label that is added to the table headers when the column may be sorted
			 */
			"orderable": ": Activate to sort",

			/**
			 * ARIA label that is added to the table headers when the column is currently being sorted
			 */
			"orderableReverse": ": Activate to invert sorting",

			/**
			 * ARIA label that is added to the table headers when the column is currently being 
			 * sorted and next step is to remove sorting
			 */
			"orderableRemove": ": Activate to remove sorting",

			paginate: {
				first: 'First',
				last: 'Last',
				next: 'Next',
				previous: 'Previous'
			}
		},

		/**
		 * Pagination string used by DataTables for the built-in pagination
		 * control types.
		 */
		"oPaginate": {
			/**
			 * Label and character for first page button («)
			 */
			"sFirst": "\u00AB",

			/**
			 * Last page button (»)
			 */
			"sLast": "\u00BB",

			/**
			 * Next page button (›)
			 */
			"sNext": "\u203A",

			/**
			 * Previous page button (‹)
			 */
			"sPrevious": "\u2039",
		},

		/**
		 * Plural object for the data type the table is showing
		 */
		entries: {
			_: "entries",
			1: "entry"
		},

		/**
		 * This string is shown in preference to `zeroRecords` when the table is
		 * empty of data (regardless of filtering). Note that this is an optional
		 * parameter - if it is not given, the value of `zeroRecords` will be used
		 * instead (either the default or given value).
		 */
		"sEmptyTable": "No data available in table",


		/**
		 * This string gives information to the end user about the information
		 * that is current on display on the page. The following tokens can be
		 * used in the string and will be dynamically replaced as the table
		 * display updates. This tokens can be placed anywhere in the string, or
		 * removed as needed by the language requires:
		 *
		 * * `\_START\_` - Display index of the first record on the current page
		 * * `\_END\_` - Display index of the last record on the current page
		 * * `\_TOTAL\_` - Number of records in the table after filtering
		 * * `\_MAX\_` - Number of records in the table without filtering
		 * * `\_PAGE\_` - Current page number
		 * * `\_PAGES\_` - Total number of pages of data in the table
		 */
		"sInfo": "Showing _START_ to _END_ of _TOTAL_ _ENTRIES-TOTAL_",


		/**
		 * Display information string for when the table is empty. Typically the
		 * format of this string should match `info`.
		 */
		"sInfoEmpty": "Showing 0 to 0 of 0 _ENTRIES-TOTAL_",


		/**
		 * When a user filters the information in a table, this string is appended
		 * to the information (`info`) to give an idea of how strong the filtering
		 * is. The variable _MAX_ is dynamically updated.
		 */
		"sInfoFiltered": "(filtered from _MAX_ total _ENTRIES-MAX_)",


		/**
		 * If can be useful to append extra information to the info string at times,
		 * and this variable does exactly that. This information will be appended to
		 * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
		 * being used) at all times.
		 */
		"sInfoPostFix": "",


		/**
		 * This decimal place operator is a little different from the other
		 * language options since DataTables doesn't output floating point
		 * numbers, so it won't ever use this for display of a number. Rather,
		 * what this parameter does is modify the sort methods of the table so
		 * that numbers which are in a format which has a character other than
		 * a period (`.`) as a decimal place will be sorted numerically.
		 *
		 * Note that numbers with different decimal places cannot be shown in
		 * the same table and still be sortable, the table must be consistent.
		 * However, multiple different tables on the page can use different
		 * decimal place characters.
		 */
		"sDecimal": "",


		/**
		 * DataTables has a build in number formatter (`formatNumber`) which is
		 * used to format large numbers that are used in the table information.
		 * By default a comma is used, but this can be trivially changed to any
		 * character you wish with this parameter.
		 */
		"sThousands": ",",


		/**
		 * Detail the action that will be taken when the drop down menu for the
		 * pagination length option is changed. The '_MENU_' variable is replaced
		 * with a default select list of 10, 25, 50 and 100, and can be replaced
		 * with a custom select box if required.
		 */
		"sLengthMenu": "_MENU_ _ENTRIES_ per page",


		/**
		 * When using Ajax sourced data and during the first draw when DataTables is
		 * gathering the data, this message is shown in an empty row in the table to
		 * indicate to the end user the the data is being loaded. Note that this
		 * parameter is not used when loading data by server-side processing, just
		 * Ajax sourced data with client-side processing.
		 */
		"sLoadingRecords": "Loading...",


		/**
		 * Text which is displayed when the table is processing a user action
		 * (usually a sort command or similar).
		 */
		"sProcessing": "",


		/**
		 * Details the actions that will be taken when the user types into the
		 * filtering input text box. The variable "_INPUT_", if used in the string,
		 * is replaced with the HTML text box for the filtering input allowing
		 * control over where it appears in the string. If "_INPUT_" is not given
		 * then the input box is appended to the string automatically.
		 */
		"sSearch": "Search:",


		/**
		 * Assign a `placeholder` attribute to the search `input` element
		 *  @type string
		 *  @default 
		 *
		 *  @dtopt Language
		 *  @name DataTable.defaults.language.searchPlaceholder
		 */
		"sSearchPlaceholder": "",


		/**
		 * All of the language information can be stored in a file on the
		 * server-side, which DataTables will look up if this parameter is passed.
		 * It must store the URL of the language file, which is in a JSON format,
		 * and the object has the same properties as the oLanguage object in the
		 * initialiser object (i.e. the above parameters). Please refer to one of
		 * the example language files to see how this works in action.
		 */
		"sUrl": "",


		/**
		 * Text shown inside the table records when the is no information to be
		 * displayed after filtering. `emptyTable` is shown when there is simply no
		 * information in the table at all (regardless of filtering).
		 */
		"sZeroRecords": "No matching records found"
	},


	/**
	 * This parameter allows you to have define the global filtering state at
	 * initialisation time. As an object the `search` parameter must be
	 * defined, but all other parameters are optional. When `regex` is true,
	 * the search string will be treated as a regular expression, when false
	 * (default) it will be treated as a straight string. When `smart`
	 * DataTables will use it's smart filtering methods (to word match at
	 * any point in the data), when false this will not be done.
	 */
	"oSearch": $.extend( {}, DataTable.models.oSearch ),


	/**
	 * Table and control layout. This replaces the legacy `dom` option.
	 */
	layout: {
		topStart: 'pageLength',
		topEnd: 'search',
		bottomStart: 'info',
		bottomEnd: 'paging'
	},


	/**
	 * Legacy DOM layout option
	 */
	"sDom": null,


	/**
	 * Search delay option. This will throttle full table searches that use the
	 * DataTables provided search input element (it does not effect calls to
	 * `dt-api search()`, providing a delay before the search is made.
	 */
	"searchDelay": null,


	/**
	 * DataTables features six different built-in options for the buttons to
	 * display for pagination control:
	 *
	 * * `numbers` - Page number buttons only
	 * * `simple` - 'Previous' and 'Next' buttons only
	 * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
	 * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
	 * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
	 * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
	 */
	"sPaginationType": "full_numbers",


	/**
	 * Enable horizontal scrolling. When a table is too wide to fit into a
	 * certain layout, or you have a large number of columns in the table, you
	 * can enable x-scrolling to show the table in a viewport, which can be
	 * scrolled. This property can be `true` which will allow the table to
	 * scroll horizontally when needed, or any CSS unit, or a number (in which
	 * case it will be treated as a pixel measurement). Setting as simply `true`
	 * is recommended.
	 */
	"sScrollX": "",


	/**
	 * This property can be used to force a DataTable to use more width than it
	 * might otherwise do when x-scrolling is enabled. For example if you have a
	 * table which requires to be well spaced, this parameter is useful for
	 * "over-sizing" the table, and thus forcing scrolling. This property can by
	 * any CSS unit, or a number (in which case it will be treated as a pixel
	 * measurement).
	 */
	"sScrollXInner": "",


	/**
	 * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
	 * to the given height, and enable scrolling for any data which overflows the
	 * current viewport. This can be used as an alternative to paging to display
	 * a lot of data in a small area (although paging and scrolling can both be
	 * enabled at the same time). This property can be any CSS unit, or a number
	 * (in which case it will be treated as a pixel measurement).
	 */
	"sScrollY": "",


	/**
	 * __Deprecated__ The functionality provided by this parameter has now been
	 * superseded by that provided through `ajax`, which should be used instead.
	 *
	 * Set the HTTP method that is used to make the Ajax call for server-side
	 * processing or Ajax sourced data.
	 */
	"sServerMethod": "GET",


	/**
	 * DataTables makes use of renderers when displaying HTML elements for
	 * a table. These renderers can be added or modified by plug-ins to
	 * generate suitable mark-up for a site. For example the Bootstrap
	 * integration plug-in for DataTables uses a paging button renderer to
	 * display pagination buttons in the mark-up required by Bootstrap.
	 *
	 * For further information about the renderers available see
	 * DataTable.ext.renderer
	 */
	"renderer": null,


	/**
	 * Set the data property name that DataTables should use to get a row's id
	 * to set as the `id` property in the node.
	 */
	"rowId": "DT_RowId",


	/**
	 * Caption value
	 */
	"caption": null
};

_fnHungarianMap( DataTable.defaults );



/*
 * Developer note - See note in model.defaults.js about the use of Hungarian
 * notation and camel case.
 */

/**
 * Column options that can be given to DataTables at initialisation time.
 *  @namespace
 */
DataTable.defaults.column = {
	/**
	 * Define which column(s) an order will occur on for this column. This
	 * allows a column's ordering to take multiple columns into account when
	 * doing a sort or use the data from a different column. For example first
	 * name / last name columns make sense to do a multi-column sort over the
	 * two columns.
	 */
	"aDataSort": null,
	"iDataSort": -1,

	ariaTitle: '',


	/**
	 * You can control the default ordering direction, and even alter the
	 * behaviour of the sort handler (i.e. only allow ascending ordering etc)
	 * using this parameter.
	 */
	"asSorting": [ 'asc', 'desc', '' ],


	/**
	 * Enable or disable filtering on the data in this column.
	 */
	"bSearchable": true,


	/**
	 * Enable or disable ordering on this column.
	 */
	"bSortable": true,


	/**
	 * Enable or disable the display of this column.
	 */
	"bVisible": true,


	/**
	 * Developer definable function that is called whenever a cell is created (Ajax source,
	 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
	 * allowing you to modify the DOM element (add background colour for example) when the
	 * element is available.
	 */
	"fnCreatedCell": null,


	/**
	 * This property can be used to read data from any data source property,
	 * including deeply nested objects / properties. `data` can be given in a
	 * number of different ways which effect its behaviour:
	 *
	 * * `integer` - treated as an array index for the data source. This is the
	 *   default that DataTables uses (incrementally increased for each column).
	 * * `string` - read an object property from the data source. There are
	 *   three 'special' options that can be used in the string to alter how
	 *   DataTables reads the data from the source object:
	 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
	 *      Javascript to read from nested objects, so to can the options
	 *      specified in `data`. For example: `browser.version` or
	 *      `browser.name`. If your object parameter name contains a period, use
	 *      `\\` to escape it - i.e. `first\\.name`.
	 *    * `[]` - Array notation. DataTables can automatically combine data
	 *      from and array source, joining the data with the characters provided
	 *      between the two brackets. For example: `name[, ]` would provide a
	 *      comma-space separated list from the source array. If no characters
	 *      are provided between the brackets, the original array source is
	 *      returned.
	 *    * `()` - Function notation. Adding `()` to the end of a parameter will
	 *      execute a function of the name given. For example: `browser()` for a
	 *      simple function on the data source, `browser.version()` for a
	 *      function in a nested property or even `browser().version` to get an
	 *      object property if the function called returns an object. Note that
	 *      function notation is recommended for use in `render` rather than
	 *      `data` as it is much simpler to use as a renderer.
	 * * `null` - use the original data source for the row rather than plucking
	 *   data directly from it. This action has effects on two other
	 *   initialisation options:
	 *    * `defaultContent` - When null is given as the `data` option and
	 *      `defaultContent` is specified for the column, the value defined by
	 *      `defaultContent` will be used for the cell.
	 *    * `render` - When null is used for the `data` option and the `render`
	 *      option is specified for the column, the whole data source for the
	 *      row is used for the renderer.
	 * * `function` - the function given will be executed whenever DataTables
	 *   needs to set or get the data for a cell in the column. The function
	 *   takes three parameters:
	 *    * Parameters:
	 *      * `{array|object}` The data source for the row
	 *      * `{string}` The type call data requested - this will be 'set' when
	 *        setting data or 'filter', 'display', 'type', 'sort' or undefined
	 *        when gathering data. Note that when `undefined` is given for the
	 *        type DataTables expects to get the raw data for the object back<
	 *      * `{*}` Data to set when the second parameter is 'set'.
	 *    * Return:
	 *      * The return value from the function is not required when 'set' is
	 *        the type of call, but otherwise the return is what will be used
	 *        for the data requested.
	 *
	 * Note that `data` is a getter and setter option. If you just require
	 * formatting of data for output, you will likely want to use `render` which
	 * is simply a getter and thus simpler to use.
	 *
	 * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
	 * name change reflects the flexibility of this property and is consistent
	 * with the naming of mRender. If 'mDataProp' is given, then it will still
	 * be used by DataTables, as it automatically maps the old name to the new
	 * if required.
	 */
	"mData": null,


	/**
	 * This property is the rendering partner to `data` and it is suggested that
	 * when you want to manipulate data for display (including filtering,
	 * sorting etc) without altering the underlying data for the table, use this
	 * property. `render` can be considered to be the the read only companion to
	 * `data` which is read / write (then as such more complex). Like `data`
	 * this option can be given in a number of different ways to effect its
	 * behaviour:
	 *
	 * * `integer` - treated as an array index for the data source. This is the
	 *   default that DataTables uses (incrementally increased for each column).
	 * * `string` - read an object property from the data source. There are
	 *   three 'special' options that can be used in the string to alter how
	 *   DataTables reads the data from the source object:
	 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
	 *      Javascript to read from nested objects, so to can the options
	 *      specified in `data`. For example: `browser.version` or
	 *      `browser.name`. If your object parameter name contains a period, use
	 *      `\\` to escape it - i.e. `first\\.name`.
	 *    * `[]` - Array notation. DataTables can automatically combine data
	 *      from and array source, joining the data with the characters provided
	 *      between the two brackets. For example: `name[, ]` would provide a
	 *      comma-space separated list from the source array. If no characters
	 *      are provided between the brackets, the original array source is
	 *      returned.
	 *    * `()` - Function notation. Adding `()` to the end of a parameter will
	 *      execute a function of the name given. For example: `browser()` for a
	 *      simple function on the data source, `browser.version()` for a
	 *      function in a nested property or even `browser().version` to get an
	 *      object property if the function called returns an object.
	 * * `object` - use different data for the different data types requested by
	 *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
	 *   of the object is the data type the property refers to and the value can
	 *   defined using an integer, string or function using the same rules as
	 *   `render` normally does. Note that an `_` option _must_ be specified.
	 *   This is the default value to use if you haven't specified a value for
	 *   the data type requested by DataTables.
	 * * `function` - the function given will be executed whenever DataTables
	 *   needs to set or get the data for a cell in the column. The function
	 *   takes three parameters:
	 *    * Parameters:
	 *      * {array|object} The data source for the row (based on `data`)
	 *      * {string} The type call data requested - this will be 'filter',
	 *        'display', 'type' or 'sort'.
	 *      * {array|object} The full data source for the row (not based on
	 *        `data`)
	 *    * Return:
	 *      * The return value from the function is what will be used for the
	 *        data requested.
	 */
	"mRender": null,


	/**
	 * Change the cell type created for the column - either TD cells or TH cells. This
	 * can be useful as TH cells have semantic meaning in the table body, allowing them
	 * to act as a header for a row (you may wish to add scope='row' to the TH elements).
	 */
	"sCellType": "td",


	/**
	 * Class to give to each cell in this column.
	 */
	"sClass": "",

	/**
	 * When DataTables calculates the column widths to assign to each column,
	 * it finds the longest string in each column and then constructs a
	 * temporary table and reads the widths from that. The problem with this
	 * is that "mmm" is much wider then "iiii", but the latter is a longer
	 * string - thus the calculation can go wrong (doing it properly and putting
	 * it into an DOM object and measuring that is horribly(!) slow). Thus as
	 * a "work around" we provide this option. It will append its value to the
	 * text that is found to be the longest string for the column - i.e. padding.
	 * Generally you shouldn't need this!
	 */
	"sContentPadding": "",


	/**
	 * Allows a default value to be given for a column's data, and will be used
	 * whenever a null data source is encountered (this can be because `data`
	 * is set to null, or because the data source itself is null).
	 */
	"sDefaultContent": null,


	/**
	 * This parameter is only used in DataTables' server-side processing. It can
	 * be exceptionally useful to know what columns are being displayed on the
	 * client side, and to map these to database fields. When defined, the names
	 * also allow DataTables to reorder information from the server if it comes
	 * back in an unexpected order (i.e. if you switch your columns around on the
	 * client-side, your server-side code does not also need updating).
	 */
	"sName": "",


	/**
	 * Defines a data source type for the ordering which can be used to read
	 * real-time information from the table (updating the internally cached
	 * version) prior to ordering. This allows ordering to occur on user
	 * editable elements such as form inputs.
	 */
	"sSortDataType": "std",


	/**
	 * The title of this column.
	 */
	"sTitle": null,


	/**
	 * The type allows you to specify how the data for this column will be
	 * ordered. Four types (string, numeric, date and html (which will strip
	 * HTML tags before ordering)) are currently available. Note that only date
	 * formats understood by Javascript's Date() object will be accepted as type
	 * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
	 * 'numeric', 'date' or 'html' (by default). Further types can be adding
	 * through plug-ins.
	 */
	"sType": null,


	/**
	 * Defining the width of the column, this parameter may take any CSS value
	 * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
	 * been given a specific width through this interface ensuring that the table
	 * remains readable.
	 */
	"sWidth": null
};

_fnHungarianMap( DataTable.defaults.column );



/**
 * DataTables settings object - this holds all the information needed for a
 * given table, including configuration, data and current application of the
 * table options. DataTables does not have a single instance for each DataTable
 * with the settings attached to that instance, but rather instances of the
 * DataTable "class" are created on-the-fly as needed (typically by a
 * $().dataTable() call) and the settings object is then applied to that
 * instance.
 *
 * Note that this object is related to {@link DataTable.defaults} but this
 * one is the internal data store for DataTables's cache of columns. It should
 * NOT be manipulated outside of DataTables. Any configuration should be done
 * through the initialisation options.
 */
DataTable.models.oSettings = {
	/**
	 * Primary features of DataTables and their enablement state.
	 */
	"oFeatures": {

		/**
		 * Flag to say if DataTables should automatically try to calculate the
		 * optimum table and columns widths (true) or not (false).
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bAutoWidth": null,

		/**
		 * Delay the creation of TR and TD elements until they are actually
		 * needed by a driven page draw. This can give a significant speed
		 * increase for Ajax source and Javascript source data, but makes no
		 * difference at all for DOM and server-side processing tables.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bDeferRender": null,

		/**
		 * Enable filtering on the table or not. Note that if this is disabled
		 * then there is no filtering at all on the table, including fnFilter.
		 * To just remove the filtering input use sDom and remove the 'f' option.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bFilter": null,

		/**
		 * Used only for compatiblity with DT1
		 * @deprecated
		 */
		"bInfo": true,

		/**
		 * Used only for compatiblity with DT1
		 * @deprecated
		 */
		"bLengthChange": true,

		/**
		 * Pagination enabled or not. Note that if this is disabled then length
		 * changing must also be disabled.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bPaginate": null,

		/**
		 * Processing indicator enable flag whenever DataTables is enacting a
		 * user request - typically an Ajax request for server-side processing.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bProcessing": null,

		/**
		 * Server-side processing enabled flag - when enabled DataTables will
		 * get all data from the server for every draw - there is no filtering,
		 * sorting or paging done on the client-side.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bServerSide": null,

		/**
		 * Sorting enablement flag.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bSort": null,

		/**
		 * Multi-column sorting
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bSortMulti": null,

		/**
		 * Apply a class to the columns which are being sorted to provide a
		 * visual highlight or not. This can slow things down when enabled since
		 * there is a lot of DOM interaction.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bSortClasses": null,

		/**
		 * State saving enablement flag.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bStateSave": null
	},


	/**
	 * Scrolling settings for a table.
	 */
	"oScroll": {
		/**
		 * When the table is shorter in height than sScrollY, collapse the
		 * table container down to the height of the table (when true).
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bCollapse": null,

		/**
		 * Width of the scrollbar for the web-browser's platform. Calculated
		 * during table initialisation.
		 */
		"iBarWidth": 0,

		/**
		 * Viewport width for horizontal scrolling. Horizontal scrolling is
		 * disabled if an empty string.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"sX": null,

		/**
		 * Width to expand the table to when using x-scrolling. Typically you
		 * should not need to use this.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @deprecated
		 */
		"sXInner": null,

		/**
		 * Viewport height for vertical scrolling. Vertical scrolling is disabled
		 * if an empty string.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"sY": null
	},

	/**
	 * Language information for the table.
	 */
	"oLanguage": {
		/**
		 * Information callback function. See
		 * {@link DataTable.defaults.fnInfoCallback}
		 */
		"fnInfoCallback": null
	},

	/**
	 * Browser support parameters
	 */
	"oBrowser": {
		/**
		 * Determine if the vertical scrollbar is on the right or left of the
		 * scrolling container - needed for rtl language layout, although not
		 * all browsers move the scrollbar (Safari).
		 */
		"bScrollbarLeft": false,

		/**
		 * Browser scrollbar width
		 */
		"barWidth": 0
	},


	"ajax": null,


	/**
	 * Array referencing the nodes which are used for the features. The
	 * parameters of this object match what is allowed by sDom - i.e.
	 *   <ul>
	 *     <li>'l' - Length changing</li>
	 *     <li>'f' - Filtering input</li>
	 *     <li>'t' - The table!</li>
	 *     <li>'i' - Information</li>
	 *     <li>'p' - Pagination</li>
	 *     <li>'r' - pRocessing</li>
	 *   </ul>
	 */
	"aanFeatures": [],

	/**
	 * Store data information - see {@link DataTable.models.oRow} for detailed
	 * information.
	 */
	"aoData": [],

	/**
	 * Array of indexes which are in the current display (after filtering etc)
	 */
	"aiDisplay": [],

	/**
	 * Array of indexes for display - no filtering
	 */
	"aiDisplayMaster": [],

	/**
	 * Map of row ids to data indexes
	 */
	"aIds": {},

	/**
	 * Store information about each column that is in use
	 */
	"aoColumns": [],

	/**
	 * Store information about the table's header
	 */
	"aoHeader": [],

	/**
	 * Store information about the table's footer
	 */
	"aoFooter": [],

	/**
	 * Store the applied global search information in case we want to force a
	 * research or compare the old search to a new one.
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"oPreviousSearch": {},

	/**
	 * Store for named searches
	 */
	searchFixed: {},

	/**
	 * Store the applied search for each column - see
	 * {@link DataTable.models.oSearch} for the format that is used for the
	 * filtering information for each column.
	 */
	"aoPreSearchCols": [],

	/**
	 * Sorting that is applied to the table. Note that the inner arrays are
	 * used in the following manner:
	 * <ul>
	 *   <li>Index 0 - column number</li>
	 *   <li>Index 1 - current sorting direction</li>
	 * </ul>
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"aaSorting": null,

	/**
	 * Sorting that is always applied to the table (i.e. prefixed in front of
	 * aaSorting).
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"aaSortingFixed": [],

	/**
	 * If restoring a table - we should restore its width
	 */
	"sDestroyWidth": 0,

	/**
	 * Callback functions array for every time a row is inserted (i.e. on a draw).
	 */
	"aoRowCallback": [],

	/**
	 * Callback functions for the header on each draw.
	 */
	"aoHeaderCallback": [],

	/**
	 * Callback function for the footer on each draw.
	 */
	"aoFooterCallback": [],

	/**
	 * Array of callback functions for draw callback functions
	 */
	"aoDrawCallback": [],

	/**
	 * Array of callback functions for row created function
	 */
	"aoRowCreatedCallback": [],

	/**
	 * Callback functions for just before the table is redrawn. A return of
	 * false will be used to cancel the draw.
	 */
	"aoPreDrawCallback": [],

	/**
	 * Callback functions for when the table has been initialised.
	 */
	"aoInitComplete": [],


	/**
	 * Callbacks for modifying the settings to be stored for state saving, prior to
	 * saving state.
	 */
	"aoStateSaveParams": [],

	/**
	 * Callbacks for modifying the settings that have been stored for state saving
	 * prior to using the stored values to restore the state.
	 */
	"aoStateLoadParams": [],

	/**
	 * Callbacks for operating on the settings object once the saved state has been
	 * loaded
	 */
	"aoStateLoaded": [],

	/**
	 * Cache the table ID for quick access
	 */
	"sTableId": "",

	/**
	 * The TABLE node for the main table
	 */
	"nTable": null,

	/**
	 * Permanent ref to the thead element
	 */
	"nTHead": null,

	/**
	 * Permanent ref to the tfoot element - if it exists
	 */
	"nTFoot": null,

	/**
	 * Permanent ref to the tbody element
	 */
	"nTBody": null,

	/**
	 * Cache the wrapper node (contains all DataTables controlled elements)
	 */
	"nTableWrapper": null,

	/**
	 * Indicate if all required information has been read in
	 */
	"bInitialised": false,

	/**
	 * Information about open rows. Each object in the array has the parameters
	 * 'nTr' and 'nParent'
	 */
	"aoOpenRows": [],

	/**
	 * Dictate the positioning of DataTables' control elements - see
	 * {@link DataTable.model.oInit.sDom}.
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"sDom": null,

	/**
	 * Search delay (in mS)
	 */
	"searchDelay": null,

	/**
	 * Which type of pagination should be used.
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"sPaginationType": "two_button",

	/**
	 * Number of paging controls on the page. Only used for backwards compatibility
	 */
	pagingControls: 0,

	/**
	 * The state duration (for `stateSave`) in seconds.
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"iStateDuration": 0,

	/**
	 * Array of callback functions for state saving. Each array element is an
	 * object with the following parameters:
	 *   <ul>
	 *     <li>function:fn - function to call. Takes two parameters, oSettings
	 *       and the JSON string to save that has been thus far created. Returns
	 *       a JSON string to be inserted into a json object
	 *       (i.e. '"param": [ 0, 1, 2]')</li>
	 *     <li>string:sName - name of callback</li>
	 *   </ul>
	 */
	"aoStateSave": [],

	/**
	 * Array of callback functions for state loading. Each array element is an
	 * object with the following parameters:
	 *   <ul>
	 *     <li>function:fn - function to call. Takes two parameters, oSettings
	 *       and the object stored. May return false to cancel state loading</li>
	 *     <li>string:sName - name of callback</li>
	 *   </ul>
	 */
	"aoStateLoad": [],

	/**
	 * State that was saved. Useful for back reference
	 */
	"oSavedState": null,

	/**
	 * State that was loaded. Useful for back reference
	 */
	"oLoadedState": null,

	/**
	 * Note if draw should be blocked while getting data
	 */
	"bAjaxDataGet": true,

	/**
	 * The last jQuery XHR object that was used for server-side data gathering.
	 * This can be used for working with the XHR information in one of the
	 * callbacks
	 */
	"jqXHR": null,

	/**
	 * JSON returned from the server in the last Ajax request
	 */
	"json": undefined,

	/**
	 * Data submitted as part of the last Ajax request
	 */
	"oAjaxData": undefined,

	/**
	 * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
	 * required).
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"sServerMethod": null,

	/**
	 * Format numbers for display.
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"fnFormatNumber": null,

	/**
	 * List of options that can be used for the user selectable length menu.
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"aLengthMenu": null,

	/**
	 * Counter for the draws that the table does. Also used as a tracker for
	 * server-side processing
	 */
	"iDraw": 0,

	/**
	 * Indicate if a redraw is being done - useful for Ajax
	 */
	"bDrawing": false,

	/**
	 * Draw index (iDraw) of the last error when parsing the returned data
	 */
	"iDrawError": -1,

	/**
	 * Paging display length
	 */
	"_iDisplayLength": 10,

	/**
	 * Paging start point - aiDisplay index
	 */
	"_iDisplayStart": 0,

	/**
	 * Server-side processing - number of records in the result set
	 * (i.e. before filtering), Use fnRecordsTotal rather than
	 * this property to get the value of the number of records, regardless of
	 * the server-side processing setting.
	 */
	"_iRecordsTotal": 0,

	/**
	 * Server-side processing - number of records in the current display set
	 * (i.e. after filtering). Use fnRecordsDisplay rather than
	 * this property to get the value of the number of records, regardless of
	 * the server-side processing setting.
	 */
	"_iRecordsDisplay": 0,

	/**
	 * The classes to use for the table
	 */
	"oClasses": {},

	/**
	 * Flag attached to the settings object so you can check in the draw
	 * callback if filtering has been done in the draw. Deprecated in favour of
	 * events.
	 *  @deprecated
	 */
	"bFiltered": false,

	/**
	 * Flag attached to the settings object so you can check in the draw
	 * callback if sorting has been done in the draw. Deprecated in favour of
	 * events.
	 *  @deprecated
	 */
	"bSorted": false,

	/**
	 * Indicate that if multiple rows are in the header and there is more than
	 * one unique cell per column, if the top one (true) or bottom one (false)
	 * should be used for sorting / title by DataTables.
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"bSortCellsTop": null,

	/**
	 * Initialisation object that is used for the table
	 */
	"oInit": null,

	/**
	 * Destroy callback functions - for plug-ins to attach themselves to the
	 * destroy so they can clean up markup and events.
	 */
	"aoDestroyCallback": [],


	/**
	 * Get the number of records in the current record set, before filtering
	 */
	"fnRecordsTotal": function ()
	{
		return _fnDataSource( this ) == 'ssp' ?
			this._iRecordsTotal * 1 :
			this.aiDisplayMaster.length;
	},

	/**
	 * Get the number of records in the current record set, after filtering
	 */
	"fnRecordsDisplay": function ()
	{
		return _fnDataSource( this ) == 'ssp' ?
			this._iRecordsDisplay * 1 :
			this.aiDisplay.length;
	},

	/**
	 * Get the display end point - aiDisplay index
	 */
	"fnDisplayEnd": function ()
	{
		var
			len      = this._iDisplayLength,
			start    = this._iDisplayStart,
			calc     = start + len,
			records  = this.aiDisplay.length,
			features = this.oFeatures,
			paginate = features.bPaginate;

		if ( features.bServerSide ) {
			return paginate === false || len === -1 ?
				start + records :
				Math.min( start+len, this._iRecordsDisplay );
		}
		else {
			return ! paginate || calc>records || len===-1 ?
				records :
				calc;
		}
	},

	/**
	 * The DataTables object for this table
	 */
	"oInstance": null,

	/**
	 * Unique identifier for each instance of the DataTables object. If there
	 * is an ID on the table node, then it takes that value, otherwise an
	 * incrementing internal counter is used.
	 */
	"sInstance": null,

	/**
	 * tabindex attribute value that is added to DataTables control elements, allowing
	 * keyboard navigation of the table and its controls.
	 */
	"iTabIndex": 0,

	/**
	 * DIV container for the footer scrolling table if scrolling
	 */
	"nScrollHead": null,

	/**
	 * DIV container for the footer scrolling table if scrolling
	 */
	"nScrollFoot": null,

	/**
	 * Last applied sort
	 */
	"aLastSort": [],

	/**
	 * Stored plug-in instances
	 */
	"oPlugins": {},

	/**
	 * Function used to get a row's id from the row's data
	 */
	"rowIdFn": null,

	/**
	 * Data location where to store a row's id
	 */
	"rowId": null,

	caption: '',

	captionNode: null,

	colgroup: null
};

/**
 * Extension object for DataTables that is used to provide all extension
 * options.
 *
 * Note that the `DataTable.ext` object is available through
 * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
 * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
 *  @namespace
 *  @extends DataTable.models.ext
 */


var extPagination = DataTable.ext.pager;

// Paging buttons configuration
$.extend( extPagination, {
	simple: function () {
		return [ 'previous', 'next' ];
	},

	full: function () {
		return [  'first', 'previous', 'next', 'last' ];
	},

	numbers: function () {
		return [ 'numbers' ];
	},

	simple_numbers: function () {
		return [ 'previous', 'numbers', 'next' ];
	},

	full_numbers: function () {
		return [ 'first', 'previous', 'numbers', 'next', 'last' ];
	},
	
	first_last: function () {
		return ['first', 'last'];
	},
	
	first_last_numbers: function () {
		return ['first', 'numbers', 'last'];
	},

	// For testing and plug-ins to use
	_numbers: _pagingNumbers,

	// Number of number buttons - legacy, use `numbers` option for paging feature
	numbers_length: 7
} );


$.extend( true, DataTable.ext.renderer, {
	pagingButton: {
		_: function (settings, buttonType, content, active, disabled) {
			var classes = settings.oClasses.paging;
			var btnClasses = [classes.button];
			var btn;

			if (active) {
				btnClasses.push(classes.active);
			}

			if (disabled) {
				btnClasses.push(classes.disabled)
			}

			if (buttonType === 'ellipsis') {
				btn = $('<span class="ellipsis"></span>').html(content)[0];
			}
			else {
				btn = $('<button>', {
					class: btnClasses.join(' '),
					role: 'link',
					type: 'button'
				}).html(content);
			}

			return {
				display: btn,
				clicker: btn
			}
		}
	},

	pagingContainer: {
		_: function (settings, buttons) {
			// No wrapping element - just append directly to the host
			return buttons;
		}
	}
} );

// Common function to remove new lines, strip HTML and diacritic control
var _filterString = function (stripHtml, normalize) {
	return function (str) {
		if (_empty(str) || typeof str !== 'string') {
			return str;
		}

		str = str.replace( _re_new_lines, " " );

		if (stripHtml) {
			str = _stripHtml(str);
		}

		if (normalize) {
			str = _normalize(str, false);
		}

		return str;
	};
}

/*
 * Public helper functions. These aren't used internally by DataTables, or
 * called by any of the options passed into DataTables, but they can be used
 * externally by developers working with DataTables. They are helper functions
 * to make working with DataTables a little bit easier.
 */

function __mldFnName(name) {
	return name.replace(/[\W]/g, '_')
}

// Common logic for moment, luxon or a date action
function __mld( dt, momentFn, luxonFn, dateFn, arg1 ) {
	if (window.moment) {
		return dt[momentFn]( arg1 );
	}
	else if (window.luxon) {
		return dt[luxonFn]( arg1 );
	}
	
	return dateFn ? dt[dateFn]( arg1 ) : dt;
}


var __mlWarning = false;
function __mldObj (d, format, locale) {
	var dt;

	if (window.moment) {
		dt = window.moment.utc( d, format, locale, true );

		if (! dt.isValid()) {
			return null;
		}
	}
	else if (window.luxon) {
		dt = format && typeof d === 'string'
			? window.luxon.DateTime.fromFormat( d, format )
			: window.luxon.DateTime.fromISO( d );

		if (! dt.isValid) {
			return null;
		}

		dt.setLocale(locale);
	}
	else if (! format) {
		// No format given, must be ISO
		dt = new Date(d);
	}
	else {
		if (! __mlWarning) {
			alert('DataTables warning: Formatted date without Moment.js or Luxon - https://datatables.net/tn/17');
		}

		__mlWarning = true;
	}

	return dt;
}

// Wrapper for date, datetime and time which all operate the same way with the exception of
// the output string for auto locale support
function __mlHelper (localeString) {
	return function ( from, to, locale, def ) {
		// Luxon and Moment support
		// Argument shifting
		if ( arguments.length === 0 ) {
			locale = 'en';
			to = null; // means toLocaleString
			from = null; // means iso8601
		}
		else if ( arguments.length === 1 ) {
			locale = 'en';
			to = from;
			from = null;
		}
		else if ( arguments.length === 2 ) {
			locale = to;
			to = from;
			from = null;
		}

		var typeName = 'datetime' + (to ? '-' + __mldFnName(to) : '');

		// Add type detection and sorting specific to this date format - we need to be able to identify
		// date type columns as such, rather than as numbers in extensions. Hence the need for this.
		if (! DataTable.ext.type.order[typeName]) {
			DataTable.type(typeName, {
				detect: function (d) {
					// The renderer will give the value to type detect as the type!
					return d === typeName ? typeName : false;
				},
				order: {
					pre: function (d) {
						// The renderer gives us Moment, Luxon or Date obects for the sorting, all of which have a
						// `valueOf` which gives milliseconds epoch
						return d.valueOf();
					}
				},
				className: 'dt-right'
			});
		}
	
		return function ( d, type ) {
			// Allow for a default value
			if (d === null || d === undefined) {
				if (def === '--now') {
					// We treat everything as UTC further down, so no changes are
					// made, as such need to get the local date / time as if it were
					// UTC
					var local = new Date();
					d = new Date( Date.UTC(
						local.getFullYear(), local.getMonth(), local.getDate(),
						local.getHours(), local.getMinutes(), local.getSeconds()
					) );
				}
				else {
					d = '';
				}
			}

			if (type === 'type') {
				// Typing uses the type name for fast matching
				return typeName;
			}

			if (d === '') {
				return type !== 'sort'
					? ''
					: __mldObj('0000-01-01 00:00:00', null, locale);
			}

			// Shortcut. If `from` and `to` are the same, we are using the renderer to
			// format for ordering, not display - its already in the display format.
			if ( to !== null && from === to && type !== 'sort' && type !== 'type' && ! (d instanceof Date) ) {
				return d;
			}

			var dt = __mldObj(d, from, locale);

			if (dt === null) {
				return d;
			}

			if (type === 'sort') {
				return dt;
			}
			
			var formatted = to === null
				? __mld(dt, 'toDate', 'toJSDate', '')[localeString]()
				: __mld(dt, 'format', 'toFormat', 'toISOString', to);

			// XSS protection
			return type === 'display' ?
				_escapeHtml( formatted ) :
				formatted;
		};
	}
}

// Based on locale, determine standard number formatting
// Fallback for legacy browsers is US English
var __thousands = ',';
var __decimal = '.';

if (window.Intl !== undefined) {
	try {
		var num = new Intl.NumberFormat().formatToParts(100000.1);
	
		for (var i=0 ; i<num.length ; i++) {
			if (num[i].type === 'group') {
				__thousands = num[i].value;
			}
			else if (num[i].type === 'decimal') {
				__decimal = num[i].value;
			}
		}
	}
	catch (e) {
		// noop
	}
}

// Formatted date time detection - use by declaring the formats you are going to use
DataTable.datetime = function ( format, locale ) {
	var typeName = 'datetime-detect-' + __mldFnName(format);

	if (! locale) {
		locale = 'en';
	}

	if (! DataTable.ext.type.order[typeName]) {
		DataTable.type(typeName, {
			detect: function (d) {
				var dt = __mldObj(d, format, locale);
				return d === '' || dt ? typeName : false;
			},
			order: {
				pre: function (d) {
					return __mldObj(d, format, locale) || 0;
				}
			},
			className: 'dt-right'
		});
	}
}

/**
 * Helpers for `columns.render`.
 *
 * The options defined here can be used with the `columns.render` initialisation
 * option to provide a display renderer. The following functions are defined:
 *
 * * `moment` - Uses the MomentJS library to convert from a given format into another.
 * This renderer has three overloads:
 *   * 1 parameter:
 *     * `string` - Format to convert to (assumes input is ISO8601 and locale is `en`)
 *   * 2 parameters:
 *     * `string` - Format to convert from
 *     * `string` - Format to convert to. Assumes `en` locale
 *   * 3 parameters:
 *     * `string` - Format to convert from
 *     * `string` - Format to convert to
 *     * `string` - Locale
 * * `number` - Will format numeric data (defined by `columns.data`) for
 *   display, retaining the original unformatted data for sorting and filtering.
 *   It takes 5 parameters:
 *   * `string` - Thousands grouping separator
 *   * `string` - Decimal point indicator
 *   * `integer` - Number of decimal points to show
 *   * `string` (optional) - Prefix.
 *   * `string` (optional) - Postfix (/suffix).
 * * `text` - Escape HTML to help prevent XSS attacks. It has no optional
 *   parameters.
 *
 * @example
 *   // Column definition using the number renderer
 *   {
 *     data: "salary",
 *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
 *   }
 *
 * @namespace
 */
DataTable.render = {
	date: __mlHelper('toLocaleDateString'),
	datetime: __mlHelper('toLocaleString'),
	time: __mlHelper('toLocaleTimeString'),
	number: function ( thousands, decimal, precision, prefix, postfix ) {
		// Auto locale detection
		if (thousands === null || thousands === undefined) {
			thousands = __thousands;
		}

		if (decimal === null || decimal === undefined) {
			decimal = __decimal;
		}

		return {
			display: function ( d ) {
				if ( typeof d !== 'number' && typeof d !== 'string' ) {
					return d;
				}

				if (d === '' || d === null) {
					return d;
				}

				var negative = d < 0 ? '-' : '';
				var flo = parseFloat( d );
				var abs = Math.abs(flo);

				// Scientific notation for large and small numbers
				if (abs >= 100000000000 || (abs < 0.0001 && abs !== 0) ) {
					var exp = flo.toExponential(precision).split(/e\+?/);
					return exp[0] + ' x 10<sup>' + exp[1] + '</sup>';
				}

				// If NaN then there isn't much formatting that we can do - just
				// return immediately, escaping any HTML (this was supposed to
				// be a number after all)
				if ( isNaN( flo ) ) {
					return _escapeHtml( d );
				}

				flo = flo.toFixed( precision );
				d = Math.abs( flo );

				var intPart = parseInt( d, 10 );
				var floatPart = precision ?
					decimal+(d - intPart).toFixed( precision ).substring( 2 ):
					'';

				// If zero, then can't have a negative prefix
				if (intPart === 0 && parseFloat(floatPart) === 0) {
					negative = '';
				}

				return negative + (prefix||'') +
					intPart.toString().replace(
						/\B(?=(\d{3})+(?!\d))/g, thousands
					) +
					floatPart +
					(postfix||'');
			}
		};
	},

	text: function () {
		return {
			display: _escapeHtml,
			filter: _escapeHtml
		};
	}
};


var _extTypes = DataTable.ext.type;

// Get / set type
DataTable.type = function (name, prop, val) {
	if (! prop) {
		return {
			className: _extTypes.className[name],
			detect: _extTypes.detect.find(function (fn) {
				return fn.name === name;
			}),
			order: {
				pre: _extTypes.order[name + '-pre'],
				asc: _extTypes.order[name + '-asc'],
				desc: _extTypes.order[name + '-desc']
			},
			render: _extTypes.render[name],
			search: _extTypes.search[name]
		};
	}

	var setProp = function(prop, propVal) {
		_extTypes[prop][name] = propVal;
	};
	var setDetect = function (fn) {
		// Wrap to allow the function to return `true` rather than
		// specifying the type name.
		var cb = function (d, s) {
			var ret = fn(d, s);

			return ret === true
				? name
				: ret;
		};
		Object.defineProperty(cb, "name", {value: name});

		var idx = _extTypes.detect.findIndex(function (fn) {
			return fn.name === name;
		});

		if (idx === -1) {
			_extTypes.detect.unshift(cb);
		}
		else {
			_extTypes.detect.splice(idx, 1, cb);
		}
	};
	var setOrder = function (obj) {
		_extTypes.order[name + '-pre'] = obj.pre; // can be undefined
		_extTypes.order[name + '-asc'] = obj.asc; // can be undefined
		_extTypes.order[name + '-desc'] = obj.desc; // can be undefined
	};

	// prop is optional
	if (val === undefined) {
		val = prop;
		prop = null;
	}

	if (prop === 'className') {
		setProp('className', val);
	}
	else if (prop === 'detect') {
		setDetect(val);
	}
	else if (prop === 'order') {
		setOrder(val);
	}
	else if (prop === 'render') {
		setProp('render', val);
	}
	else if (prop === 'search') {
		setProp('search', val);
	}
	else if (! prop) {
		if (val.className) {
			setProp('className', val.className);
		}

		if (val.detect !== undefined) {
			setDetect(val.detect);
		}

		if (val.order) {
			setOrder(val.order);
		}

		if (val.render !== undefined) {
			setProp('render', val.render);
		}

		if (val.search !== undefined) {
			setProp('search', val.search);
		}
	}
}

// Get a list of types
DataTable.types = function () {
	return _extTypes.detect.map(function (fn) {
		return fn.name;
	});
};

//
// Built in data types
//

DataTable.type('string', {
	detect: function () {
		return 'string';
	},
	order: {
		pre: function ( a ) {
			// This is a little complex, but faster than always calling toString,
			// http://jsperf.com/tostring-v-check
			return _empty(a) ?
				'' :
				typeof a === 'string' ?
					a.toLowerCase() :
					! a.toString ?
						'' :
						a.toString();
		}
	},
	search: _filterString(false, true)
});


DataTable.type('html', {
	detect: function ( d ) {
		return _empty( d ) || (typeof d === 'string' && d.indexOf('<') !== -1) ?
			'html' : null;
	},
	order: {
		pre: function ( a ) {
			return _empty(a) ?
				'' :
				a.replace ?
					_stripHtml(a).trim().toLowerCase() :
					a+'';
		}
	},
	search: _filterString(true, true)
});


DataTable.type('date', {
	className: 'dt-type-date',
	detect: function ( d )
	{
		// V8 tries _very_ hard to make a string passed into `Date.parse()`
		// valid, so we need to use a regex to restrict date formats. Use a
		// plug-in for anything other than ISO8601 style strings
		if ( d && !(d instanceof Date) && ! _re_date.test(d) ) {
			return null;
		}
		var parsed = Date.parse(d);
		return (parsed !== null && !isNaN(parsed)) || _empty(d) ? 'date' : null;
	},
	order: {
		pre: function ( d ) {
			var ts = Date.parse( d );
			return isNaN(ts) ? -Infinity : ts;
		}
	}
});


DataTable.type('html-num-fmt', {
	className: 'dt-type-numeric',
	detect: function ( d, settings )
	{
		var decimal = settings.oLanguage.sDecimal;
		return _htmlNumeric( d, decimal, true ) ? 'html-num-fmt' : null;
	},
	order: {
		pre: function ( d, s ) {
			var dp = s.oLanguage.sDecimal;
			return __numericReplace( d, dp, _re_html, _re_formatted_numeric );
		}
	},
	search: _filterString(true, true)
});


DataTable.type('html-num', {
	className: 'dt-type-numeric',
	detect: function ( d, settings )
	{
		var decimal = settings.oLanguage.sDecimal;
		return _htmlNumeric( d, decimal ) ? 'html-num' : null;
	},
	order: {
		pre: function ( d, s ) {
			var dp = s.oLanguage.sDecimal;
			return __numericReplace( d, dp, _re_html );
		}
	},
	search: _filterString(true, true)
});


DataTable.type('num-fmt', {
	className: 'dt-type-numeric',
	detect: function ( d, settings )
	{
		var decimal = settings.oLanguage.sDecimal;
		return _isNumber( d, decimal, true ) ? 'num-fmt' : null;
	},
	order: {
		pre: function ( d, s ) {
			var dp = s.oLanguage.sDecimal;
			return __numericReplace( d, dp, _re_formatted_numeric );
		}
	}
});


DataTable.type('num', {
	className: 'dt-type-numeric',
	detect: function ( d, settings )
	{
		var decimal = settings.oLanguage.sDecimal;
		return _isNumber( d, decimal ) ? 'num' : null;
	},
	order: {
		pre: function (d, s) {
			var dp = s.oLanguage.sDecimal;
			return __numericReplace( d, dp );
		}
	}
});




var __numericReplace = function ( d, decimalPlace, re1, re2 ) {
	if ( d !== 0 && (!d || d === '-') ) {
		return -Infinity;
	}
	
	var type = typeof d;

	if (type === 'number' || type === 'bigint') {
		return d;
	}

	// If a decimal place other than `.` is used, it needs to be given to the
	// function so we can detect it and replace with a `.` which is the only
	// decimal place Javascript recognises - it is not locale aware.
	if ( decimalPlace ) {
		d = _numToDecimal( d, decimalPlace );
	}

	if ( d.replace ) {
		if ( re1 ) {
			d = d.replace( re1, '' );
		}

		if ( re2 ) {
			d = d.replace( re2, '' );
		}
	}

	return d * 1;
};


$.extend( true, DataTable.ext.renderer, {
	footer: {
		_: function ( settings, cell, classes ) {
			cell.addClass(classes.tfoot.cell);
		}
	},

	header: {
		_: function ( settings, cell, classes ) {
			cell.addClass(classes.thead.cell);

			if (! settings.oFeatures.bSort) {
				cell.addClass(classes.order.none);
			}

			var legacyTop = settings.bSortCellsTop;
			var headerRows = cell.closest('thead').find('tr');
			var rowIdx = cell.parent().index();

			// Conditions to not apply the ordering icons
			if (
				// Cells and rows which have the attribute to disable the icons
				cell.attr('data-dt-order') === 'disable' ||
				cell.parent().attr('data-dt-order') === 'disable' ||

				// Legacy support for `orderCellsTop`. If it is set, then cells
				// which are not in the top or bottom row of the header (depending
				// on the value) do not get the sorting classes applied to them
				(legacyTop === true && rowIdx !== 0) ||
				(legacyTop === false && rowIdx !== headerRows.length - 1)
			) {
				return;
			}

			// No additional mark-up required
			// Attach a sort listener to update on sort - note that using the
			// `DT` namespace will allow the event to be removed automatically
			// on destroy, while the `dt` namespaced event is the one we are
			// listening for
			$(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting ) {
				if ( settings !== ctx ) { // need to check this this is the host
					return;               // table, not a nested one
				}

				var orderClasses = classes.order;
				var columns = ctx.api.columns( cell );
				var col = settings.aoColumns[columns.flatten()[0]];
				var orderable = columns.orderable().includes(true);
				var ariaType = '';
				var indexes = columns.indexes();
				var sortDirs = columns.orderable(true).flatten();
				var orderedColumns = ',' + sorting.map( function (val) {
					return val.col;
				} ).join(',') + ',';

				cell
					.removeClass(
						orderClasses.isAsc +' '+
						orderClasses.isDesc
					)
					.toggleClass( orderClasses.none, ! orderable )
					.toggleClass( orderClasses.canAsc, orderable && sortDirs.includes('asc') )
					.toggleClass( orderClasses.canDesc, orderable && sortDirs.includes('desc') );
				
				var sortIdx = orderedColumns.indexOf( ',' + indexes.toArray().join(',') + ',' );

				if ( sortIdx !== -1 ) {
					// Get the ordering direction for the columns under this cell
					// Note that it is possible for a cell to be asc and desc sorting
					// (column spanning cells)
					var orderDirs = columns.order();

					cell.addClass(
						orderDirs.includes('asc') ? orderClasses.isAsc : '' +
						orderDirs.includes('desc') ? orderClasses.isDesc : ''
					);
				}

				// The ARIA spec says that only one column should be marked with aria-sort
				if ( sortIdx === 0 ) {
					var firstSort = sorting[0];
					var sortOrder = col.asSorting;

					cell.attr('aria-sort', firstSort.dir === 'asc' ? 'ascending' : 'descending');

					// Determine if the next click will remove sorting or change the sort
					ariaType = ! sortOrder[firstSort.index + 1] ? 'Remove' : 'Reverse';
				}
				else {
					cell.removeAttr('aria-sort');
				}

				cell.attr('aria-label', orderable
					? col.ariaTitle + ctx.api.i18n('oAria.orderable' + ariaType)
					: col.ariaTitle
				);

				if (orderable) {
					cell.find('.dt-column-title').attr('role', 'button');
					cell.attr('tabindex', 0)
				}
			} );
		}
	},

	layout: {
		_: function ( settings, container, items ) {
			var row = $('<div/>')
				.addClass('dt-layout-row')
				.appendTo( container );

			$.each( items, function (key, val) {
				var klass = ! val.table ?
					'dt-'+key+' ' :
					'';

				if (val.table) {
					row.addClass('dt-layout-table');
				}

				$('<div/>')
					.attr({
						id: val.id || null,
						"class": 'dt-layout-cell '+klass+(val.className || '')
					})
					.append( val.contents )
					.appendTo( row );
			} );
		}
	}
} );


DataTable.feature = {};

// Third parameter is internal only!
DataTable.feature.register = function ( name, cb, legacy ) {
	DataTable.ext.features[ name ] = cb;

	if (legacy) {
		_ext.feature.push({
			cFeature: legacy,
			fnInit: cb
		});
	}
};

DataTable.feature.register( 'info', function ( settings, opts ) {
	// For compatibility with the legacy `info` top level option
	if (! settings.oFeatures.bInfo) {
		return null;
	}

	var
		lang  = settings.oLanguage,
		tid = settings.sTableId,
		n = $('<div/>', {
			'class': settings.oClasses.info.container,
		} );

	opts = $.extend({
		callback: lang.fnInfoCallback,
		empty: lang.sInfoEmpty,
		postfix: lang.sInfoPostFix,
		search: lang.sInfoFiltered,
		text: lang.sInfo,
	}, opts);


	// Update display on each draw
	settings.aoDrawCallback.push(function (s) {
		_fnUpdateInfo(s, opts, n);
	});

	// For the first info display in the table, we add a callback and aria information.
	if (! settings._infoEl) {
		n.attr({
			'aria-live': 'polite',
			id: tid+'_info',
			role: 'status'
		});

		// Table is described by our info div
		$(settings.nTable).attr( 'aria-describedby', tid+'_info' );

		settings._infoEl = n;
	}

	return n;
}, 'i' );

/**
 * Update the information elements in the display
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnUpdateInfo ( settings, opts, node )
{
	var
		start = settings._iDisplayStart+1,
		end   = settings.fnDisplayEnd(),
		max   = settings.fnRecordsTotal(),
		total = settings.fnRecordsDisplay(),
		out   = total
			? opts.text
			: opts.empty;

	if ( total !== max ) {
		// Record set after filtering
		out += ' ' + opts.search;
	}

	// Convert the macros
	out += opts.postfix;
	out = _fnMacros( settings, out );

	if ( opts.callback ) {
		out = opts.callback.call( settings.oInstance,
			settings, start, end, max, total, out
		);
	}

	node.html( out );

	_fnCallbackFire(settings, null, 'info', [settings, node[0], out]);
}

var __searchCounter = 0;

// opts
// - text
// - placeholder
DataTable.feature.register( 'search', function ( settings, opts ) {
	// Don't show the input if filtering isn't available on the table
	if (! settings.oFeatures.bFilter) {
		return null;
	}

	var classes = settings.oClasses.search;
	var tableId = settings.sTableId;
	var language = settings.oLanguage;
	var previousSearch = settings.oPreviousSearch;
	var input = '<input type="search" class="'+classes.input+'"/>';

	opts = $.extend({
		placeholder: language.sSearchPlaceholder,
		text: language.sSearch
	}, opts);

	// The _INPUT_ is optional - is appended if not present
	if (opts.text.indexOf('_INPUT_') === -1) {
		opts.text += '_INPUT_';
	}

	opts.text = _fnMacros(settings, opts.text);

	// We can put the <input> outside of the label if it is at the start or end
	// which helps improve accessability (not all screen readers like implicit
	// for elements).
	var end = opts.text.match(/_INPUT_$/);
	var start = opts.text.match(/^_INPUT_/);
	var removed = opts.text.replace(/_INPUT_/, '');
	var str = '<label>' + opts.text + '</label>';

	if (start) {
		str = '_INPUT_<label>' + removed + '</label>';
	}
	else if (end) {
		str = '<label>' + removed + '</label>_INPUT_';
	}

	var filter = $('<div>')
		.addClass(classes.container)
		.append(str.replace(/_INPUT_/, input));

	// add for and id to label and input
	filter.find('label').attr('for', 'dt-search-' + __searchCounter);
	filter.find('input').attr('id', 'dt-search-' + __searchCounter);
	__searchCounter++;

	var searchFn = function(event) {
		var val = this.value;

		if(previousSearch.return && event.key !== "Enter") {
			return;
		}

		/* Now do the filter */
		if ( val != previousSearch.search ) {
			previousSearch.search = val;

			_fnFilterComplete( settings, previousSearch );

			// Need to redraw, without resorting
			settings._iDisplayStart = 0;
			_fnDraw( settings );
		}
	};

	var searchDelay = settings.searchDelay !== null ?
		settings.searchDelay :
		0;

	var jqFilter = $('input', filter)
		.val( previousSearch.search )
		.attr( 'placeholder', opts.placeholder )
		.on(
			'keyup.DT search.DT input.DT paste.DT cut.DT',
			searchDelay ?
				DataTable.util.debounce( searchFn, searchDelay ) :
				searchFn
		)
		.on( 'mouseup.DT', function(e) {
			// Edge fix! Edge 17 does not trigger anything other than mouse events when clicking
			// on the clear icon (Edge bug 17584515). This is safe in other browsers as `searchFn`
			// checks the value to see if it has changed. In other browsers it won't have.
			setTimeout( function () {
				searchFn.call(jqFilter[0], e);
			}, 10);
		} )
		.on( 'keypress.DT', function(e) {
			/* Prevent form submission */
			if ( e.keyCode == 13 ) {
				return false;
			}
		} )
		.attr('aria-controls', tableId);

	// Update the input elements whenever the table is filtered
	$(settings.nTable).on( 'search.dt.DT', function ( ev, s ) {
		if ( settings === s && jqFilter[0] !== document.activeElement ) {
			jqFilter.val( typeof previousSearch.search !== 'function'
				? previousSearch.search
				: ''
			);
		}
	} );

	return filter;
}, 'f' );

// opts
// - type - button configuration
// - buttons - number of buttons to show - must be odd
DataTable.feature.register( 'paging', function ( settings, opts ) {
	// Don't show the paging input if the table doesn't have paging enabled
	if (! settings.oFeatures.bPaginate) {
		return null;
	}

	opts = $.extend({
		buttons: DataTable.ext.pager.numbers_length,
		type: settings.sPaginationType,
		boundaryNumbers: true
	}, opts);

	// To be removed in 2.1
	if (opts.numbers) {
		opts.buttons = opts.numbers;
	}

	var host = $('<div/>').addClass( settings.oClasses.paging.container + ' paging_' + opts.type );
	var draw = function () {
		_pagingDraw(settings, host, opts);
	};

	settings.aoDrawCallback.push(draw);

	// Responsive redraw of paging control
	$(settings.nTable).on('column-sizing.dt.DT', draw);

	return host;
}, 'p' );

function _pagingDraw(settings, host, opts) {
	if (! settings._bInitComplete) {
		return;
	}

	var
		plugin = DataTable.ext.pager[ opts.type ],
		aria = settings.oLanguage.oAria.paginate || {},
		start      = settings._iDisplayStart,
		len        = settings._iDisplayLength,
		visRecords = settings.fnRecordsDisplay(),
		all        = len === -1,
		page = all ? 0 : Math.ceil( start / len ),
		pages = all ? 1 : Math.ceil( visRecords / len ),
		buttons = plugin()
			.map(function (val) {
				return val === 'numbers'
					? _pagingNumbers(page, pages, opts.buttons, opts.boundaryNumbers)
					: val;
			})
			.flat();

	var buttonEls = [];

	for (var i=0 ; i<buttons.length ; i++) {
		var button = buttons[i];

		var btnInfo = _pagingButtonInfo(settings, button, page, pages);
		var btn = _fnRenderer( settings, 'pagingButton' )(
			settings,
			button,
			btnInfo.display,
			btnInfo.active,
			btnInfo.disabled
		);

		// Common attributes
		$(btn.clicker).attr({
			'aria-controls': settings.sTableId,
			'aria-disabled': btnInfo.disabled ? 'true' : null,
			'aria-current': btnInfo.active ? 'page' : null,
			'aria-label': aria[ button ],
			'data-dt-idx': button,
			'tabIndex': btnInfo.disabled ? -1 : settings.iTabIndex,
		});

		if (typeof button !== 'number') {
			$(btn.clicker).addClass(button);
		}

		_fnBindAction(
			btn.clicker, {action: button}, function(e) {
				e.preventDefault();

				_fnPageChange( settings, e.data.action, true );
			}
		);

		buttonEls.push(btn.display);
	}

	var wrapped = _fnRenderer(settings, 'pagingContainer')(
		settings, buttonEls
	);

	var activeEl = host.find(document.activeElement).data('dt-idx');

	host.empty().append(wrapped);

	if ( activeEl !== undefined ) {
		host.find( '[data-dt-idx='+activeEl+']' ).trigger('focus');
	}

	// Responsive - check if the buttons are over two lines based on the
	// height of the buttons and the container.
	if (
		buttonEls.length && // any buttons
		opts.numbers > 1 && // prevent infinite
		$(host).height() >= ($(buttonEls[0]).outerHeight() * 2) - 10
	) {
		_pagingDraw(settings, host, $.extend({}, opts, { numbers: opts.numbers - 2 }));
	}
}

/**
 * Get properties for a button based on the current paging state of the table
 *
 * @param {*} settings DT settings object
 * @param {*} button The button type in question
 * @param {*} page Table's current page
 * @param {*} pages Number of pages
 * @returns Info object
 */
function _pagingButtonInfo(settings, button, page, pages) {
	var lang = settings.oLanguage.oPaginate;
	var o = {
		display: '',
		active: false,
		disabled: false
	};

	switch ( button ) {
		case 'ellipsis':
			o.display = '&#x2026;';
			o.disabled = true;
			break;

		case 'first':
			o.display = lang.sFirst;

			if (page === 0) {
				o.disabled = true;
			}
			break;

		case 'previous':
			o.display = lang.sPrevious;

			if ( page === 0 ) {
				o.disabled = true;
			}
			break;

		case 'next':
			o.display = lang.sNext;

			if ( pages === 0 || page === pages-1 ) {
				o.disabled = true;
			}
			break;

		case 'last':
			o.display = lang.sLast;

			if ( pages === 0 || page === pages-1 ) {
				o.disabled = true;
			}
			break;

		default:
			if ( typeof button === 'number' ) {
				o.display = settings.fnFormatNumber( button + 1 );
				
				if (page === button) {
					o.active = true;
				}
			}
			break;
	}

	return o;
}

/**
 * Compute what number buttons to show in the paging control
 *
 * @param {*} page Current page
 * @param {*} pages Total number of pages
 * @param {*} buttons Target number of number buttons
 * @param {boolean} addFirstLast Indicate if page 1 and end should be included
 * @returns Buttons to show
 */
function _pagingNumbers ( page, pages, buttons, addFirstLast ) {
	var
		numbers = [],
		half = Math.floor(buttons / 2),
		before = addFirstLast ? 2 : 1,
		after = addFirstLast ? 1 : 0;

	if ( pages <= buttons ) {
		numbers = _range(0, pages);
	}
	else if (buttons === 1) {
		// Single button - current page only
		numbers = [page];
	}
	else if (buttons === 3) {
		// Special logic for just three buttons
		if (page <= 1) {
			numbers = [0, 1, 'ellipsis'];
		}
		else if (page >= pages - 2) {
			numbers = _range(pages-2, pages);
			numbers.unshift('ellipsis');
		}
		else {
			numbers = ['ellipsis', page, 'ellipsis'];
		}
	}
	else if ( page <= half ) {
		numbers = _range(0, buttons-before);
		numbers.push('ellipsis');

		if (addFirstLast) {
			numbers.push(pages-1);
		}
	}
	else if ( page >= pages - 1 - half ) {
		numbers = _range(pages-(buttons-before), pages);
		numbers.unshift('ellipsis');

		if (addFirstLast) {
			numbers.unshift(0);
		}
	}
	else {
		numbers = _range(page-half+before, page+half-after);
		numbers.push('ellipsis');
		numbers.unshift('ellipsis');

		if (addFirstLast) {
			numbers.push(pages-1);
			numbers.unshift(0);
		}
	}

	return numbers;
}

var __lengthCounter = 0;

// opts
// - menu
// - text
DataTable.feature.register( 'pageLength', function ( settings, opts ) {
	var features = settings.oFeatures;

	// For compatibility with the legacy `pageLength` top level option
	if (! features.bPaginate || ! features.bLengthChange) {
		return null;
	}

	opts = $.extend({
		menu: settings.aLengthMenu,
		text: settings.oLanguage.sLengthMenu
	}, opts);

	var
		classes  = settings.oClasses.length,
		tableId  = settings.sTableId,
		menu     = opts.menu,
		lengths  = [],
		language = [],
		i;

	// Options can be given in a number of ways
	if (Array.isArray( menu[0] )) {
		// Old 1.x style - 2D array
		lengths = menu[0];
		language = menu[1];
	}
	else {
		for ( i=0 ; i<menu.length ; i++ ) {
			// An object with different label and value
			if ($.isPlainObject(menu[i])) {
				lengths.push(menu[i].value);
				language.push(menu[i].label);
			}
			else {
				// Or just a number to display and use
				lengths.push(menu[i]);
				language.push(menu[i]);
			}
		}
	}

	// We can put the <select> outside of the label if it is at the start or
	// end which helps improve accessability (not all screen readers like
	// implicit for elements).
	var end = opts.text.match(/_MENU_$/);
	var start = opts.text.match(/^_MENU_/);
	var removed = opts.text.replace(/_MENU_/, '');
	var str = '<label>' + opts.text + '</label>';

	if (start) {
		str = '_MENU_<label>' + removed + '</label>';
	}
	else if (end) {
		str = '<label>' + removed + '</label>_MENU_';
	}

	// Wrapper element - use a span as a holder for where the select will go
	var div = $('<div/>')
		.addClass( classes.container )
		.append(
			str.replace( '_MENU_', '<span></span>' )
		);

	// Save text node content for macro updating
	var textNodes = [];
	div.find('label')[0].childNodes.forEach(function (el) {
		if (el.nodeType === Node.TEXT_NODE) {
			textNodes.push({
				el: el,
				text: el.textContent
			});
		}
	})

	// Update the label text in case it has an entries value
	var updateEntries = function (len) {
		textNodes.forEach(function (node) {
			node.el.textContent = _fnMacros(settings, node.text, len);
		});
	}

	// Next, the select itself, along with the options
	var select = $('<select/>', {
		'name':          tableId+'_length',
		'aria-controls': tableId,
		'class':         classes.select
	} );

	for ( i=0 ; i<lengths.length ; i++ ) {
		select[0][ i ] = new Option(
			typeof language[i] === 'number' ?
				settings.fnFormatNumber( language[i] ) :
				language[i],
			lengths[i]
		);
	}

	// add for and id to label and input
	div.find('label').attr('for', 'dt-length-' + __lengthCounter);
	select.attr('id', 'dt-length-' + __lengthCounter);
	__lengthCounter++;

	// Swap in the select list
	div.find('span').replaceWith(select);

	// Can't use `select` variable as user might provide their own and the
	// reference is broken by the use of outerHTML
	$('select', div)
		.val( settings._iDisplayLength )
		.on( 'change.DT', function() {
			_fnLengthChange( settings, $(this).val() );
			_fnDraw( settings );
		} );

	// Update node value whenever anything changes the table's length
	$(settings.nTable).on( 'length.dt.DT', function (e, s, len) {
		if ( settings === s ) {
			$('select', div).val( len );

			// Resolve plurals in the text for the new length
			updateEntries(len);
		}
	} );

	updateEntries(settings._iDisplayLength);

	return div;
}, 'l' );

// jQuery access
$.fn.dataTable = DataTable;

// Provide access to the host jQuery object (circular reference)
DataTable.$ = $;

// Legacy aliases
$.fn.dataTableSettings = DataTable.settings;
$.fn.dataTableExt = DataTable.ext;

// With a capital `D` we return a DataTables API instance rather than a
// jQuery object
$.fn.DataTable = function ( opts ) {
	return $(this).dataTable( opts ).api();
};

// All properties that are available to $.fn.dataTable should also be
// available on $.fn.DataTable
$.each( DataTable, function ( prop, val ) {
	$.fn.DataTable[ prop ] = val;
} );

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataTable);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!***********************************!*\
  !*** ./resources/js/datatable.js ***!
  \***********************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var datatables_net_dt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! datatables.net-dt */ "./node_modules/datatables.net-dt/js/dataTables.dataTables.mjs");
/* harmony import */ var datatables_net_buttons_dt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! datatables.net-buttons-dt */ "./node_modules/datatables.net-buttons-dt/js/buttons.dataTables.mjs");
/* harmony import */ var datatables_net_responsive_dt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! datatables.net-responsive-dt */ "./node_modules/datatables.net-responsive-dt/js/responsive.dataTables.mjs");
/* harmony import */ var _js_lib_tailwindcss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../js/lib/tailwindcss */ "./resources/js/lib/tailwindcss.js");
/* harmony import */ var _js_lib_tailwindcss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_js_lib_tailwindcss__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _js_lib_dataTables_tailwindcss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../js/lib/dataTables.tailwindcss */ "./resources/js/lib/dataTables.tailwindcss.js");
/* harmony import */ var _js_lib_dataTables_tailwindcss__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_js_lib_dataTables_tailwindcss__WEBPACK_IMPORTED_MODULE_4__);





})();

/******/ })()
;